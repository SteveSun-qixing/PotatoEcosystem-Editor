# Phase2 - æ ¸å¿ƒé€šä¿¡å±‚ä¸çŠ¶æ€ç®¡ç†

**å‘¨æœŸ**: 1 å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**ä¾èµ–**: Phase1  
**çŠ¶æ€**: å¾…å¼€å‘

---

## 1. é˜¶æ®µç›®æ ‡

å»ºç«‹ç¼–è¾‘å™¨çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼š
- å®ç°ä¸ Chips-SDK çš„è¿æ¥å±‚
- å»ºç«‹ Pinia çŠ¶æ€ç®¡ç†æ¶æ„
- å®ç°äº‹ä»¶ç®¡ç†ç³»ç»Ÿ
- åˆ›å»ºç¼–è¾‘å™¨ä¸»ç±»ï¼ˆEditorï¼‰

---

## 2. ä»»åŠ¡åˆ—è¡¨

### 2.1 å®ç° SDK è¿æ¥å™¨

**ä»»åŠ¡ ID**: P2-T01  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 3h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/connector.ts`

```typescript
import { ChipsSDK, type ChipsSDKOptions } from '@chips/sdk';
import { EventEmitter } from './event-manager';

/**
 * SDK è¿æ¥å™¨
 * è´Ÿè´£ä¸ Chips-SDK çš„é€šä¿¡
 */
export class SDKConnector {
  private sdk: ChipsSDK | null = null;
  private events: EventEmitter;
  private isConnected = false;

  constructor(events: EventEmitter) {
    this.events = events;
  }

  /**
   * åˆå§‹åŒ–å¹¶è¿æ¥ SDK
   */
  async connect(options?: ChipsSDKOptions): Promise<void> {
    if (this.isConnected) {
      throw new Error('SDK already connected');
    }

    try {
      this.sdk = new ChipsSDK(options);
      await this.sdk.initialize();
      this.isConnected = true;
      this.setupEventForwarding();
      this.events.emit('connector:connected', {});
    } catch (error) {
      this.events.emit('connector:error', { error });
      throw error;
    }
  }

  /**
   * æ–­å¼€ SDK è¿æ¥
   */
  disconnect(): void {
    if (this.sdk) {
      this.sdk.destroy();
      this.sdk = null;
      this.isConnected = false;
      this.events.emit('connector:disconnected', {});
    }
  }

  /**
   * è·å– SDK å®ä¾‹
   */
  getSDK(): ChipsSDK {
    if (!this.sdk || !this.isConnected) {
      throw new Error('SDK not connected');
    }
    return this.sdk;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
   */
  get connected(): boolean {
    return this.isConnected;
  }

  /**
   * è®¾ç½®äº‹ä»¶è½¬å‘
   */
  private setupEventForwarding(): void {
    if (!this.sdk) return;

    // è½¬å‘ SDK äº‹ä»¶åˆ°ç¼–è¾‘å™¨äº‹ä»¶ç³»ç»Ÿ
    const eventsToForward = [
      'card:created',
      'card:saved',
      'card:updated',
      'card:deleted',
      'box:created',
      'theme:changed',
      'plugin:enabled',
      'plugin:disabled',
    ];

    eventsToForward.forEach(eventType => {
      this.sdk!.on(eventType, (data) => {
        this.events.emit(`sdk:${eventType}`, data);
      });
    });
  }
}

export type { ChipsSDKOptions };
```

2. åˆ›å»ºè¿æ¥å™¨å·¥å‚å‡½æ•°

```typescript
// src/core/connector.ts (è¿½åŠ )

/**
 * åˆ›å»º SDK è¿æ¥å™¨
 */
export function createConnector(events: EventEmitter): SDKConnector {
  return new SDKConnector(events);
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] è¿æ¥å™¨å¯ä»¥æ­£å¸¸åˆå§‹åŒ–
- [ ] å¯ä»¥è¿æ¥å’Œæ–­å¼€ SDK
- [ ] äº‹ä»¶è½¬å‘æ­£å¸¸å·¥ä½œ
- [ ] é”™è¯¯å¤„ç†å®Œå–„

---

### 2.2 å®ç°äº‹ä»¶ç®¡ç†å™¨

**ä»»åŠ¡ ID**: P2-T02  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 2h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/event-manager.ts`

```typescript
type EventHandler<T = unknown> = (data: T) => void;

interface EventSubscription {
  id: string;
  handler: EventHandler;
  once: boolean;
}

/**
 * äº‹ä»¶å‘å°„å™¨
 * ç®¡ç†ç¼–è¾‘å™¨å†…éƒ¨äº‹ä»¶
 */
export class EventEmitter {
  private subscriptions = new Map<string, EventSubscription[]>();
  private nextId = 1;

  /**
   * è®¢é˜…äº‹ä»¶
   */
  on<T = unknown>(eventType: string, handler: EventHandler<T>): string {
    const id = `sub-${this.nextId++}`;
    const subscription: EventSubscription = {
      id,
      handler: handler as EventHandler,
      once: false,
    };

    if (!this.subscriptions.has(eventType)) {
      this.subscriptions.set(eventType, []);
    }
    this.subscriptions.get(eventType)!.push(subscription);

    return id;
  }

  /**
   * ä¸€æ¬¡æ€§è®¢é˜…
   */
  once<T = unknown>(eventType: string, handler: EventHandler<T>): string {
    const id = `sub-${this.nextId++}`;
    const subscription: EventSubscription = {
      id,
      handler: handler as EventHandler,
      once: true,
    };

    if (!this.subscriptions.has(eventType)) {
      this.subscriptions.set(eventType, []);
    }
    this.subscriptions.get(eventType)!.push(subscription);

    return id;
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  off(eventType: string, handlerOrId?: EventHandler | string): void {
    if (!this.subscriptions.has(eventType)) return;

    if (!handlerOrId) {
      // ç§»é™¤è¯¥äº‹ä»¶ç±»å‹çš„æ‰€æœ‰è®¢é˜…
      this.subscriptions.delete(eventType);
      return;
    }

    const subs = this.subscriptions.get(eventType)!;
    const index = subs.findIndex(sub => 
      typeof handlerOrId === 'string' 
        ? sub.id === handlerOrId 
        : sub.handler === handlerOrId
    );

    if (index !== -1) {
      subs.splice(index, 1);
    }
  }

  /**
   * å‘å¸ƒäº‹ä»¶
   */
  emit<T = unknown>(eventType: string, data: T): void {
    const subs = this.subscriptions.get(eventType);
    if (!subs) return;

    // æ”¯æŒé€šé…ç¬¦è®¢é˜…
    const wildcardSubs = this.subscriptions.get('*') || [];
    const allSubs = [...subs, ...wildcardSubs];

    const toRemove: string[] = [];

    allSubs.forEach(sub => {
      try {
        sub.handler(data);
        if (sub.once) {
          toRemove.push(sub.id);
        }
      } catch (error) {
        console.error(`Event handler error for ${eventType}:`, error);
      }
    });

    // ç§»é™¤ä¸€æ¬¡æ€§è®¢é˜…
    toRemove.forEach(id => this.off(eventType, id));
  }

  /**
   * ç­‰å¾…äº‹ä»¶
   */
  waitFor<T = unknown>(eventType: string, timeout = 30000): Promise<T> {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        this.off(eventType, id);
        reject(new Error(`Timeout waiting for event: ${eventType}`));
      }, timeout);

      const id = this.once<T>(eventType, (data) => {
        clearTimeout(timer);
        resolve(data);
      });
    });
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰è®¢é˜…è€…
   */
  hasListeners(eventType: string): boolean {
    return (this.subscriptions.get(eventType)?.length ?? 0) > 0;
  }

  /**
   * è·å–è®¢é˜…è€…æ•°é‡
   */
  listenerCount(eventType: string): number {
    return this.subscriptions.get(eventType)?.length ?? 0;
  }

  /**
   * æ¸…é™¤æ‰€æœ‰è®¢é˜…
   */
  clear(): void {
    this.subscriptions.clear();
  }
}

/**
 * åˆ›å»ºäº‹ä»¶å‘å°„å™¨
 */
export function createEventEmitter(): EventEmitter {
  return new EventEmitter();
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] äº‹ä»¶è®¢é˜…/å–æ¶ˆè®¢é˜…æ­£å¸¸
- [ ] ä¸€æ¬¡æ€§è®¢é˜…æ­£å¸¸
- [ ] é€šé…ç¬¦è®¢é˜…æ­£å¸¸
- [ ] waitFor åŠŸèƒ½æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†å®Œå–„

---

### 2.3 åˆ›å»º Pinia çŠ¶æ€ç®¡ç† - ç¼–è¾‘å™¨çŠ¶æ€

**ä»»åŠ¡ ID**: P2-T03  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 2h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/state/stores/editor.ts`

```typescript
import { defineStore } from 'pinia';
import type { EditorState, LayoutType } from '@/types';

interface EditorStoreState {
  /** ç¼–è¾‘å™¨çŠ¶æ€ */
  state: EditorState;
  /** å½“å‰å¸ƒå±€ */
  currentLayout: LayoutType;
  /** æ˜¯å¦å·²è¿æ¥ SDK */
  isConnected: boolean;
  /** è°ƒè¯•æ¨¡å¼ */
  debug: boolean;
  /** è‡ªåŠ¨ä¿å­˜é—´éš” */
  autoSaveInterval: number;
  /** æœ€åä¿å­˜æ—¶é—´ */
  lastSaveTime: number | null;
  /** æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹ */
  hasUnsavedChanges: boolean;
  /** é”™è¯¯ä¿¡æ¯ */
  error: Error | null;
}

export const useEditorStore = defineStore('editor', {
  state: (): EditorStoreState => ({
    state: 'idle',
    currentLayout: 'infinite-canvas',
    isConnected: false,
    debug: false,
    autoSaveInterval: 30000,
    lastSaveTime: null,
    hasUnsavedChanges: false,
    error: null,
  }),

  getters: {
    /** ç¼–è¾‘å™¨æ˜¯å¦å°±ç»ª */
    isReady: (state) => state.state === 'ready',
    
    /** ç¼–è¾‘å™¨æ˜¯å¦æ­£åœ¨åˆå§‹åŒ– */
    isInitializing: (state) => state.state === 'initializing',
    
    /** ç¼–è¾‘å™¨æ˜¯å¦æœ‰é”™è¯¯ */
    hasError: (state) => state.error !== null,
  },

  actions: {
    /** è®¾ç½®ç¼–è¾‘å™¨çŠ¶æ€ */
    setState(newState: EditorState) {
      this.state = newState;
    },

    /** è®¾ç½®å¸ƒå±€ */
    setLayout(layout: LayoutType) {
      this.currentLayout = layout;
    },

    /** è®¾ç½®è¿æ¥çŠ¶æ€ */
    setConnected(connected: boolean) {
      this.isConnected = connected;
    },

    /** è®¾ç½®è°ƒè¯•æ¨¡å¼ */
    setDebug(debug: boolean) {
      this.debug = debug;
    },

    /** æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹ */
    markUnsaved() {
      this.hasUnsavedChanges = true;
    },

    /** æ ‡è®°å·²ä¿å­˜ */
    markSaved() {
      this.hasUnsavedChanges = false;
      this.lastSaveTime = Date.now();
    },

    /** è®¾ç½®é”™è¯¯ */
    setError(error: Error | null) {
      this.error = error;
      if (error) {
        this.state = 'error';
      }
    },

    /** é‡ç½®çŠ¶æ€ */
    reset() {
      this.state = 'idle';
      this.isConnected = false;
      this.hasUnsavedChanges = false;
      this.error = null;
    },
  },
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] çŠ¶æ€å®šä¹‰å®Œæ•´
- [ ] getters æ­£å¸¸å·¥ä½œ
- [ ] actions æ­£å¸¸å·¥ä½œ
- [ ] TypeScript ç±»å‹æ­£ç¡®

---

### 2.4 åˆ›å»º Pinia çŠ¶æ€ç®¡ç† - å¡ç‰‡çŠ¶æ€

**ä»»åŠ¡ ID**: P2-T04  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 2h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/state/stores/card.ts`

```typescript
import { defineStore } from 'pinia';
import type { Card, CardMetadata, BaseCardInfo } from '@chips/sdk';

interface CardInfo {
  id: string;
  metadata: CardMetadata;
  structure: BaseCardInfo[];
  isLoading: boolean;
  isModified: boolean;
  lastModified: number;
}

interface CardStoreState {
  /** æ‰“å¼€çš„å¡ç‰‡åˆ—è¡¨ */
  openCards: Map<string, CardInfo>;
  /** å½“å‰æ´»åŠ¨çš„å¡ç‰‡ ID */
  activeCardId: string | null;
  /** å½“å‰é€‰ä¸­çš„åŸºç¡€å¡ç‰‡ ID */
  selectedBaseCardId: string | null;
  /** å¡ç‰‡åŠ è½½çŠ¶æ€ */
  loadingCards: Set<string>;
}

export const useCardStore = defineStore('card', {
  state: (): CardStoreState => ({
    openCards: new Map(),
    activeCardId: null,
    selectedBaseCardId: null,
    loadingCards: new Set(),
  }),

  getters: {
    /** è·å–æ‰“å¼€çš„å¡ç‰‡åˆ—è¡¨ */
    openCardList: (state) => Array.from(state.openCards.values()),
    
    /** è·å–å½“å‰æ´»åŠ¨çš„å¡ç‰‡ */
    activeCard: (state) => {
      if (!state.activeCardId) return null;
      return state.openCards.get(state.activeCardId) ?? null;
    },
    
    /** æ˜¯å¦æœ‰æ‰“å¼€çš„å¡ç‰‡ */
    hasOpenCards: (state) => state.openCards.size > 0,
    
    /** æ‰“å¼€çš„å¡ç‰‡æ•°é‡ */
    openCardCount: (state) => state.openCards.size,
    
    /** æ˜¯å¦æœ‰ä¿®æ”¹è¿‡çš„å¡ç‰‡ */
    hasModifiedCards: (state) => {
      for (const card of state.openCards.values()) {
        if (card.isModified) return true;
      }
      return false;
    },
  },

  actions: {
    /** æ·»åŠ å¡ç‰‡ */
    addCard(card: Card) {
      const cardInfo: CardInfo = {
        id: card.id,
        metadata: card.metadata,
        structure: card.structure.structure,
        isLoading: false,
        isModified: false,
        lastModified: Date.now(),
      };
      this.openCards.set(card.id, cardInfo);
    },

    /** ç§»é™¤å¡ç‰‡ */
    removeCard(cardId: string) {
      this.openCards.delete(cardId);
      if (this.activeCardId === cardId) {
        // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¡ç‰‡æˆ–è®¾ä¸º null
        const cards = Array.from(this.openCards.keys());
        this.activeCardId = cards.length > 0 ? cards[0] : null;
      }
    },

    /** è®¾ç½®æ´»åŠ¨å¡ç‰‡ */
    setActiveCard(cardId: string | null) {
      this.activeCardId = cardId;
    },

    /** è®¾ç½®é€‰ä¸­çš„åŸºç¡€å¡ç‰‡ */
    setSelectedBaseCard(baseCardId: string | null) {
      this.selectedBaseCardId = baseCardId;
    },

    /** æ›´æ–°å¡ç‰‡å…ƒæ•°æ® */
    updateCardMetadata(cardId: string, metadata: Partial<CardMetadata>) {
      const card = this.openCards.get(cardId);
      if (card) {
        card.metadata = { ...card.metadata, ...metadata };
        card.isModified = true;
        card.lastModified = Date.now();
      }
    },

    /** æ›´æ–°å¡ç‰‡ç»“æ„ */
    updateCardStructure(cardId: string, structure: BaseCardInfo[]) {
      const card = this.openCards.get(cardId);
      if (card) {
        card.structure = structure;
        card.isModified = true;
        card.lastModified = Date.now();
      }
    },

    /** æ ‡è®°å¡ç‰‡ä¸ºå·²ä¿å­˜ */
    markCardSaved(cardId: string) {
      const card = this.openCards.get(cardId);
      if (card) {
        card.isModified = false;
      }
    },

    /** è®¾ç½®å¡ç‰‡åŠ è½½çŠ¶æ€ */
    setCardLoading(cardId: string, loading: boolean) {
      const card = this.openCards.get(cardId);
      if (card) {
        card.isLoading = loading;
      }
      if (loading) {
        this.loadingCards.add(cardId);
      } else {
        this.loadingCards.delete(cardId);
      }
    },

    /** æ¸…é™¤æ‰€æœ‰å¡ç‰‡ */
    clearAll() {
      this.openCards.clear();
      this.activeCardId = null;
      this.selectedBaseCardId = null;
      this.loadingCards.clear();
    },
  },
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å¡ç‰‡çŠ¶æ€ç®¡ç†å®Œæ•´
- [ ] æ”¯æŒå¤šå¡ç‰‡ç®¡ç†
- [ ] ä¿®æ”¹çŠ¶æ€è·Ÿè¸ªæ­£å¸¸
- [ ] TypeScript ç±»å‹æ­£ç¡®

---

### 2.5 åˆ›å»º Pinia çŠ¶æ€ç®¡ç† - UI çŠ¶æ€

**ä»»åŠ¡ ID**: P2-T05  
**ä¼˜å…ˆçº§**: ğŸŸ¡ é«˜  
**é¢„è®¡å·¥æ—¶**: 2h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/state/stores/ui.ts`

```typescript
import { defineStore } from 'pinia';
import type { 
  WindowConfig, 
  CardWindowConfig, 
  ToolWindowConfig,
  CanvasState 
} from '@/types';

interface UIStoreState {
  /** çª—å£åˆ—è¡¨ */
  windows: Map<string, WindowConfig>;
  /** å½“å‰ç„¦ç‚¹çª—å£ ID */
  focusedWindowId: string | null;
  /** æœ€é«˜ z-index */
  maxZIndex: number;
  /** ç”»å¸ƒçŠ¶æ€ */
  canvas: CanvasState;
  /** ä¾§è¾¹æ æ˜¯å¦å±•å¼€ */
  sidebarExpanded: boolean;
  /** ç¨‹åºåä½ç½® */
  dockPosition: 'bottom' | 'left' | 'right';
  /** ä¸»é¢˜ */
  theme: string;
  /** æ˜¯å¦æ˜¾ç¤ºç½‘æ ¼ */
  showGrid: boolean;
  /** å·¥å…·çª—å£æœ€å°åŒ–çŠ¶æ€ */
  minimizedTools: Set<string>;
}

export const useUIStore = defineStore('ui', {
  state: (): UIStoreState => ({
    windows: new Map(),
    focusedWindowId: null,
    maxZIndex: 100,
    canvas: {
      zoom: 1,
      panX: 0,
      panY: 0,
    },
    sidebarExpanded: true,
    dockPosition: 'bottom',
    theme: 'default-light',
    showGrid: true,
    minimizedTools: new Set(),
  }),

  getters: {
    /** è·å–çª—å£åˆ—è¡¨ */
    windowList: (state) => Array.from(state.windows.values()),
    
    /** è·å–å¡ç‰‡çª—å£ */
    cardWindows: (state) => {
      return Array.from(state.windows.values())
        .filter((w): w is CardWindowConfig => w.type === 'card');
    },
    
    /** è·å–å·¥å…·çª—å£ */
    toolWindows: (state) => {
      return Array.from(state.windows.values())
        .filter((w): w is ToolWindowConfig => w.type === 'tool');
    },
    
    /** è·å–ç„¦ç‚¹çª—å£ */
    focusedWindow: (state) => {
      if (!state.focusedWindowId) return null;
      return state.windows.get(state.focusedWindowId) ?? null;
    },
    
    /** è·å–ç¼©æ”¾ç™¾åˆ†æ¯” */
    zoomPercent: (state) => Math.round(state.canvas.zoom * 100),
  },

  actions: {
    /** æ·»åŠ çª—å£ */
    addWindow(config: WindowConfig) {
      config.zIndex = ++this.maxZIndex;
      this.windows.set(config.id, config);
    },

    /** ç§»é™¤çª—å£ */
    removeWindow(windowId: string) {
      this.windows.delete(windowId);
      if (this.focusedWindowId === windowId) {
        this.focusedWindowId = null;
      }
    },

    /** æ›´æ–°çª—å£é…ç½® */
    updateWindow(windowId: string, updates: Partial<WindowConfig>) {
      const window = this.windows.get(windowId);
      if (window) {
        Object.assign(window, updates);
      }
    },

    /** èšç„¦çª—å£ */
    focusWindow(windowId: string) {
      this.focusedWindowId = windowId;
      const window = this.windows.get(windowId);
      if (window) {
        window.zIndex = ++this.maxZIndex;
      }
    },

    /** ç§»åŠ¨çª—å£ */
    moveWindow(windowId: string, x: number, y: number) {
      const window = this.windows.get(windowId);
      if (window) {
        window.position = { x, y };
      }
    },

    /** è°ƒæ•´çª—å£å¤§å° */
    resizeWindow(windowId: string, width: number, height: number) {
      const window = this.windows.get(windowId);
      if (window) {
        window.size = { width, height };
      }
    },

    /** è®¾ç½®çª—å£çŠ¶æ€ */
    setWindowState(windowId: string, state: WindowConfig['state']) {
      const window = this.windows.get(windowId);
      if (window) {
        window.state = state;
      }
    },

    /** æ›´æ–°ç”»å¸ƒçŠ¶æ€ */
    updateCanvas(updates: Partial<CanvasState>) {
      Object.assign(this.canvas, updates);
    },

    /** è®¾ç½®ç¼©æ”¾ */
    setZoom(zoom: number) {
      this.canvas.zoom = Math.max(0.1, Math.min(5, zoom));
    },

    /** å¹³ç§»ç”»å¸ƒ */
    pan(deltaX: number, deltaY: number) {
      this.canvas.panX += deltaX;
      this.canvas.panY += deltaY;
    },

    /** é‡ç½®ç”»å¸ƒ */
    resetCanvas() {
      this.canvas = { zoom: 1, panX: 0, panY: 0 };
    },

    /** åˆ‡æ¢ä¾§è¾¹æ  */
    toggleSidebar() {
      this.sidebarExpanded = !this.sidebarExpanded;
    },

    /** è®¾ç½®ç¨‹åºåä½ç½® */
    setDockPosition(position: 'bottom' | 'left' | 'right') {
      this.dockPosition = position;
    },

    /** è®¾ç½®ä¸»é¢˜ */
    setTheme(theme: string) {
      this.theme = theme;
    },

    /** åˆ‡æ¢ç½‘æ ¼æ˜¾ç¤º */
    toggleGrid() {
      this.showGrid = !this.showGrid;
    },

    /** æœ€å°åŒ–å·¥å…·çª—å£ */
    minimizeTool(toolId: string) {
      this.minimizedTools.add(toolId);
      const window = this.windows.get(toolId);
      if (window) {
        window.state = 'minimized';
      }
    },

    /** æ¢å¤å·¥å…·çª—å£ */
    restoreTool(toolId: string) {
      this.minimizedTools.delete(toolId);
      const window = this.windows.get(toolId);
      if (window) {
        window.state = 'normal';
      }
    },

    /** æ¸…é™¤æ‰€æœ‰çª—å£ */
    clearWindows() {
      this.windows.clear();
      this.focusedWindowId = null;
    },
  },
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] UI çŠ¶æ€ç®¡ç†å®Œæ•´
- [ ] çª—å£ç®¡ç†åŠŸèƒ½æ­£å¸¸
- [ ] ç”»å¸ƒçŠ¶æ€ç®¡ç†æ­£å¸¸
- [ ] TypeScript ç±»å‹æ­£ç¡®

---

### 2.6 åˆ›å»ºçŠ¶æ€ç®¡ç†ç´¢å¼•

**ä»»åŠ¡ ID**: P2-T06  
**ä¼˜å…ˆçº§**: ğŸŸ¡ é«˜  
**é¢„è®¡å·¥æ—¶**: 0.5h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/state/stores/index.ts`

```typescript
export { useEditorStore } from './editor';
export { useCardStore } from './card';
export { useUIStore } from './ui';
```

2. åˆ›å»º `src/core/state/index.ts`

```typescript
export * from './stores';

// ç±»å‹é‡å¯¼å‡º
export type { EditorStoreState } from './stores/editor';
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å¯¼å‡ºç»“æ„æ­£ç¡®
- [ ] å¯ä»¥æ­£å¸¸å¯¼å…¥ä½¿ç”¨

---

### 2.7 åˆ›å»ºç¼–è¾‘å™¨ä¸»ç±»

**ä»»åŠ¡ ID**: P2-T07  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 4h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/editor.ts`

```typescript
import type { ChipsSDKOptions, Card, Box } from '@chips/sdk';
import { SDKConnector, createConnector } from './connector';
import { EventEmitter, createEventEmitter } from './event-manager';
import { useEditorStore, useCardStore, useUIStore } from './state';
import type { EditorConfig, EditorState, LayoutType } from '@/types';

/**
 * Chips ç¼–è¾‘å™¨ä¸»ç±»
 * 
 * è´Ÿè´£åè°ƒå„æ¨¡å—ï¼Œæä¾›ç»Ÿä¸€çš„ç¼–è¾‘å™¨ API
 */
export class ChipsEditor {
  private config: EditorConfig;
  private events: EventEmitter;
  private connector: SDKConnector;
  private editorStore: ReturnType<typeof useEditorStore>;
  private cardStore: ReturnType<typeof useCardStore>;
  private uiStore: ReturnType<typeof useUIStore>;

  constructor(config: Partial<EditorConfig>) {
    this.config = {
      sdk: config.sdk!,
      layout: config.layout ?? 'infinite-canvas',
      debug: config.debug ?? false,
      autoSaveInterval: config.autoSaveInterval ?? 30000,
    };

    this.events = createEventEmitter();
    this.connector = createConnector(this.events);
    
    // è·å– Pinia storesï¼ˆéœ€è¦åœ¨ Vue åº”ç”¨ä¸­ä½¿ç”¨ï¼‰
    this.editorStore = useEditorStore();
    this.cardStore = useCardStore();
    this.uiStore = useUIStore();

    this.setupEventHandlers();
  }

  /**
   * åˆå§‹åŒ–ç¼–è¾‘å™¨
   */
  async initialize(): Promise<void> {
    if (this.editorStore.state !== 'idle') {
      throw new Error('Editor already initialized or initializing');
    }

    this.editorStore.setState('initializing');
    this.editorStore.setDebug(this.config.debug ?? false);

    try {
      // è¿æ¥ SDK
      await this.connector.connect();
      this.editorStore.setConnected(true);

      // è®¾ç½®å¸ƒå±€
      this.editorStore.setLayout(this.config.layout);

      // å¯åŠ¨è‡ªåŠ¨ä¿å­˜
      if (this.config.autoSaveInterval && this.config.autoSaveInterval > 0) {
        this.startAutoSave();
      }

      this.editorStore.setState('ready');
      this.events.emit('editor:ready', {});

      this.log('Editor initialized successfully');
    } catch (error) {
      this.editorStore.setError(error as Error);
      this.events.emit('editor:error', { error });
      throw error;
    }
  }

  /**
   * é”€æ¯ç¼–è¾‘å™¨
   */
  destroy(): void {
    this.stopAutoSave();
    this.connector.disconnect();
    this.cardStore.clearAll();
    this.uiStore.clearWindows();
    this.editorStore.reset();
    this.events.clear();
    this.editorStore.setState('destroyed');
    this.events.emit('editor:destroyed', {});
  }

  // ==================== å¡ç‰‡æ“ä½œ ====================

  /**
   * åˆ›å»ºæ–°å¡ç‰‡
   */
  async createCard(options: { name: string; type?: string }): Promise<Card> {
    const sdk = this.connector.getSDK();
    const card = await sdk.card.create({
      name: options.name,
      type: options.type,
    });

    this.cardStore.addCard(card);
    this.events.emit('card:created', { cardId: card.id });
    this.log(`Card created: ${card.id}`);

    return card;
  }

  /**
   * æ‰“å¼€å¡ç‰‡
   */
  async openCard(pathOrId: string): Promise<Card> {
    this.cardStore.setCardLoading(pathOrId, true);

    try {
      const sdk = this.connector.getSDK();
      const card = await sdk.card.get(pathOrId);

      this.cardStore.addCard(card);
      this.cardStore.setActiveCard(card.id);
      this.events.emit('card:opened', { cardId: card.id });
      this.log(`Card opened: ${card.id}`);

      return card;
    } finally {
      this.cardStore.setCardLoading(pathOrId, false);
    }
  }

  /**
   * ä¿å­˜å¡ç‰‡
   */
  async saveCard(cardId: string, path?: string): Promise<void> {
    const sdk = this.connector.getSDK();
    const cardInfo = this.cardStore.openCards.get(cardId);

    if (!cardInfo) {
      throw new Error(`Card not found: ${cardId}`);
    }

    // TODO: ä» store æ„å»ºå®Œæ•´çš„ Card å¯¹è±¡
    // await sdk.card.save(path ?? cardId, card);

    this.cardStore.markCardSaved(cardId);
    this.editorStore.markSaved();
    this.events.emit('card:saved', { cardId });
    this.log(`Card saved: ${cardId}`);
  }

  /**
   * å…³é—­å¡ç‰‡
   */
  closeCard(cardId: string): void {
    this.cardStore.removeCard(cardId);
    this.events.emit('card:closed', { cardId });
    this.log(`Card closed: ${cardId}`);
  }

  // ==================== å¸ƒå±€æ“ä½œ ====================

  /**
   * åˆ‡æ¢å¸ƒå±€
   */
  setLayout(layout: LayoutType): void {
    this.editorStore.setLayout(layout);
    this.events.emit('layout:changed', { layout });
    this.log(`Layout changed to: ${layout}`);
  }

  /**
   * è·å–å½“å‰å¸ƒå±€
   */
  getLayout(): LayoutType {
    return this.editorStore.currentLayout;
  }

  // ==================== äº‹ä»¶ç³»ç»Ÿ ====================

  /**
   * è®¢é˜…äº‹ä»¶
   */
  on<T = unknown>(eventType: string, handler: (data: T) => void): string {
    return this.events.on(eventType, handler);
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  off(eventType: string, handlerOrId?: ((data: unknown) => void) | string): void {
    this.events.off(eventType, handlerOrId);
  }

  /**
   * å‘å¸ƒäº‹ä»¶
   */
  emit<T = unknown>(eventType: string, data: T): void {
    this.events.emit(eventType, data);
  }

  // ==================== çŠ¶æ€è®¿é—® ====================

  /**
   * è·å–ç¼–è¾‘å™¨çŠ¶æ€
   */
  get state(): EditorState {
    return this.editorStore.state;
  }

  /**
   * æ˜¯å¦å°±ç»ª
   */
  get isReady(): boolean {
    return this.editorStore.isReady;
  }

  /**
   * è·å– SDK å®ä¾‹
   */
  get sdk() {
    return this.connector.getSDK();
  }

  // ==================== ç§æœ‰æ–¹æ³• ====================

  private autoSaveTimer: ReturnType<typeof setInterval> | null = null;

  /**
   * å¯åŠ¨è‡ªåŠ¨ä¿å­˜
   */
  private startAutoSave(): void {
    this.autoSaveTimer = setInterval(() => {
      if (this.cardStore.hasModifiedCards) {
        this.saveAllModified();
      }
    }, this.config.autoSaveInterval);
  }

  /**
   * åœæ­¢è‡ªåŠ¨ä¿å­˜
   */
  private stopAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }

  /**
   * ä¿å­˜æ‰€æœ‰ä¿®æ”¹è¿‡çš„å¡ç‰‡
   */
  private async saveAllModified(): Promise<void> {
    const modifiedCards = this.cardStore.openCardList.filter(c => c.isModified);
    
    for (const card of modifiedCards) {
      try {
        await this.saveCard(card.id);
      } catch (error) {
        this.log(`Failed to auto-save card ${card.id}:`, error);
      }
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†å™¨
   */
  private setupEventHandlers(): void {
    // ç›‘å¬è¿æ¥çŠ¶æ€
    this.events.on('connector:connected', () => {
      this.editorStore.setConnected(true);
    });

    this.events.on('connector:disconnected', () => {
      this.editorStore.setConnected(false);
    });

    this.events.on('connector:error', ({ error }) => {
      this.editorStore.setError(error as Error);
    });
  }

  /**
   * æ—¥å¿—è¾“å‡º
   */
  private log(...args: unknown[]): void {
    if (this.config.debug) {
      console.log('[ChipsEditor]', ...args);
    }
  }
}

/**
 * åˆ›å»ºç¼–è¾‘å™¨å®ä¾‹
 */
export function createEditor(config: Partial<EditorConfig>): ChipsEditor {
  return new ChipsEditor(config);
}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç¼–è¾‘å™¨ä¸»ç±»åŠŸèƒ½å®Œæ•´
- [ ] åˆå§‹åŒ–æµç¨‹æ­£ç¡®
- [ ] å¡ç‰‡æ“ä½œæ­£å¸¸
- [ ] äº‹ä»¶ç³»ç»Ÿé›†æˆæ­£å¸¸
- [ ] çŠ¶æ€ç®¡ç†é›†æˆæ­£å¸¸

---

### 2.8 åˆ›å»ºæ ¸å¿ƒæ¨¡å—ç´¢å¼•

**ä»»åŠ¡ ID**: P2-T08  
**ä¼˜å…ˆçº§**: ğŸŸ¡ é«˜  
**é¢„è®¡å·¥æ—¶**: 0.5h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `src/core/index.ts`

```typescript
// ç¼–è¾‘å™¨ä¸»ç±»
export { ChipsEditor, createEditor } from './editor';

// è¿æ¥å™¨
export { SDKConnector, createConnector } from './connector';

// äº‹ä»¶ç®¡ç†
export { EventEmitter, createEventEmitter } from './event-manager';

// çŠ¶æ€ç®¡ç†
export * from './state';

// ç±»å‹
export type { EditorConfig } from '@/types';
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å¯¼å‡ºç»“æ„æ­£ç¡®
- [ ] å¯ä»¥æ­£å¸¸å¯¼å…¥ä½¿ç”¨

---

### 2.9 ç¼–å†™å•å…ƒæµ‹è¯•

**ä»»åŠ¡ ID**: P2-T09  
**ä¼˜å…ˆçº§**: ğŸŸ¡ é«˜  
**é¢„è®¡å·¥æ—¶**: 3h

**è¯¦ç»†æ­¥éª¤**:

1. åˆ›å»º `tests/unit/core/event-manager.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { EventEmitter, createEventEmitter } from '@/core/event-manager';

describe('EventEmitter', () => {
  let emitter: EventEmitter;

  beforeEach(() => {
    emitter = createEventEmitter();
  });

  describe('on', () => {
    it('should subscribe to events', () => {
      const handler = vi.fn();
      emitter.on('test', handler);
      emitter.emit('test', { data: 'value' });
      expect(handler).toHaveBeenCalledWith({ data: 'value' });
    });

    it('should return subscription id', () => {
      const id = emitter.on('test', () => {});
      expect(id).toMatch(/^sub-\d+$/);
    });
  });

  describe('once', () => {
    it('should only fire once', () => {
      const handler = vi.fn();
      emitter.once('test', handler);
      emitter.emit('test', {});
      emitter.emit('test', {});
      expect(handler).toHaveBeenCalledTimes(1);
    });
  });

  describe('off', () => {
    it('should unsubscribe by id', () => {
      const handler = vi.fn();
      const id = emitter.on('test', handler);
      emitter.off('test', id);
      emitter.emit('test', {});
      expect(handler).not.toHaveBeenCalled();
    });

    it('should unsubscribe by handler', () => {
      const handler = vi.fn();
      emitter.on('test', handler);
      emitter.off('test', handler);
      emitter.emit('test', {});
      expect(handler).not.toHaveBeenCalled();
    });
  });

  describe('waitFor', () => {
    it('should resolve when event fires', async () => {
      setTimeout(() => {
        emitter.emit('test', { value: 42 });
      }, 10);
      
      const result = await emitter.waitFor<{ value: number }>('test');
      expect(result.value).toBe(42);
    });

    it('should reject on timeout', async () => {
      await expect(emitter.waitFor('test', 50)).rejects.toThrow('Timeout');
    });
  });
});
```

2. åˆ›å»º `tests/unit/core/state/editor.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useEditorStore } from '@/core/state/stores/editor';

describe('useEditorStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should have correct initial state', () => {
    const store = useEditorStore();
    expect(store.state).toBe('idle');
    expect(store.currentLayout).toBe('infinite-canvas');
    expect(store.isConnected).toBe(false);
  });

  it('should update state', () => {
    const store = useEditorStore();
    store.setState('ready');
    expect(store.state).toBe('ready');
    expect(store.isReady).toBe(true);
  });

  it('should update layout', () => {
    const store = useEditorStore();
    store.setLayout('workbench');
    expect(store.currentLayout).toBe('workbench');
  });

  it('should track unsaved changes', () => {
    const store = useEditorStore();
    expect(store.hasUnsavedChanges).toBe(false);
    store.markUnsaved();
    expect(store.hasUnsavedChanges).toBe(true);
    store.markSaved();
    expect(store.hasUnsavedChanges).toBe(false);
    expect(store.lastSaveTime).not.toBeNull();
  });

  it('should handle errors', () => {
    const store = useEditorStore();
    const error = new Error('Test error');
    store.setError(error);
    expect(store.error).toBe(error);
    expect(store.hasError).toBe(true);
    expect(store.state).toBe('error');
  });
});
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æµ‹è¯•è¦†ç›–ç‡ >= 80%
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æµ‹è¯•ç”¨ä¾‹å®Œæ•´

---

### 2.10 æäº¤ä»£ç 

**ä»»åŠ¡ ID**: P2-T10  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**é¢„è®¡å·¥æ—¶**: 0.5h

**è¯¦ç»†æ­¥éª¤**:
1. è¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼Œç¡®ä¿é€šè¿‡
2. è¿è¡Œ lintï¼Œç¡®ä¿æ— é”™è¯¯
3. æäº¤ä»£ç ï¼š`git commit -m "feat(core): æ ¸å¿ƒé€šä¿¡å±‚ä¸çŠ¶æ€ç®¡ç†"`

**éªŒæ”¶æ ‡å‡†**:
- [ ] æµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] ä»£ç æ—  lint é”™è¯¯
- [ ] æäº¤å®Œæˆ

---

## 3. ä»»åŠ¡ä¾èµ–å…³ç³»

```
P2-T02 (äº‹ä»¶ç®¡ç†å™¨)
    â†“
P2-T01 (SDKè¿æ¥å™¨) â”€â”€â†’ P2-T03 (ç¼–è¾‘å™¨çŠ¶æ€)
    â†“                        â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ P2-T04 (å¡ç‰‡çŠ¶æ€)
                             â†“
                   P2-T05 (UIçŠ¶æ€)
                             â†“
                   P2-T06 (çŠ¶æ€ç´¢å¼•)
                             â†“
                   P2-T07 (ç¼–è¾‘å™¨ä¸»ç±»)
                             â†“
                   P2-T08 (æ ¸å¿ƒç´¢å¼•)
                             â†“
                   P2-T09 (å•å…ƒæµ‹è¯•)
                             â†“
                   P2-T10 (æäº¤)
```

---

## 4. å®Œæˆæ ‡å‡†

- [ ] SDK è¿æ¥å™¨å®ç°å®Œæˆ
- [ ] äº‹ä»¶ç®¡ç†å™¨å®ç°å®Œæˆ
- [ ] Pinia çŠ¶æ€ç®¡ç†å®Œæˆï¼ˆeditorã€cardã€uiï¼‰
- [ ] ç¼–è¾‘å™¨ä¸»ç±»å®ç°å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >= 80%
- [ ] ä»£ç æäº¤å®Œæˆ

---

**ä»»åŠ¡åˆ†é…**: å­ä»£ç†-01  
**å¼€å§‹æ—¶é—´**: å¾…å®š  
**å®Œæˆæ—¶é—´**: å¾…å®š
