# 卡片编辑引擎 - 无限画布实现

## 1. 无限画布概述

### 1.1 设计目标

无限画布布局提供一个可缩放、可平移的二维工作空间,让用户自由组织和布置卡片和箱子窗口。

**核心特性**:
- 无限大的二维画布
- 流畅的缩放和平移
- 两层设计(桌面层和窗口层)
- 高性能渲染
- 直观的交互

### 1.2 技术挑战

- **性能**: 大量窗口时保持流畅
- **精度**: 缩放和平移的精确计算
- **交互**: 区分不同的拖拽操作
- **兼容性**: 支持不同输入设备

## 2. 两层设计实现

### 2.1 DOM 结构

```html
<div class="infinite-canvas-layout">
  <!-- 桌面层 -->
  <div class="desktop-layer">
    <div class="desktop-background"></div>
    <div class="desktop-content" id="desktop-transform-container">
      <!-- 卡片和箱子窗口放这里 -->
      <div class="card-window" data-window-id="window-1">...</div>
      <div class="card-window" data-window-id="window-2">...</div>
      <div class="box-window" data-window-id="window-3">...</div>
    </div>
  </div>
  
  <!-- 窗口层 -->
  <div class="window-layer">
    <!-- 工具窗口 -->
    <div class="tool-window file-manager">...</div>
    <div class="tool-window edit-panel">...</div>
    <div class="tool-window cardbox-library">...</div>
    
    <!-- 程序坞 -->
    <div class="dock">...</div>
    
    <!-- 缩放控制器 -->
    <div class="zoom-control">
      <input type="range" class="zoom-slider" min="10" max="500" value="100" />
      <span class="zoom-percentage">100%</span>
    </div>
  </div>
</div>
```

### 2.2 CSS 样式

```css
.infinite-canvas-layout {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

/* 桌面层 */
.desktop-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
}

.desktop-background {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    linear-gradient(rgba(200, 200, 200, 0.2) 1px, transparent 1px),
    linear-gradient(90deg, rgba(200, 200, 200, 0.2) 1px, transparent 1px);
  background-size: 50px 50px;
  /* 背景网格会随桌面变换 */
}

.desktop-content {
  position: absolute;
  top: 0;
  left: 0;
  transform-origin: 0 0;
  /* transform 由 JS 动态设置 */
  will-change: transform;
}

/* 窗口层 */
.window-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;  /* 让事件穿透到桌面层 */
  z-index: 1000;
}

.window-layer > * {
  pointer-events: auto;  /* 恢复子元素的事件 */
}

/* 卡片窗口 */
.card-window {
  position: absolute;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  /* 位置由 JS 动态设置 */
}

/* 工具窗口 */
.tool-window {
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}
```

### 2.3 TypeScript 实现

```typescript
interface Transform {
  scale: number;
  translateX: number;
  translateY: number;
}

class InfiniteCanvasLayout implements LayoutPlugin {
  private desktopTransform: Transform = {
    scale: 1,
    translateX: 0,
    translateY: 0,
  };
  
  private desktopContentElement: HTMLElement;
  private desktopBackgroundElement: HTMLElement;
  
  // 应用变换到桌面
  private applyTransform(): void {
    const { scale, translateX, translateY } = this.desktopTransform;
    
    // 应用到内容容器
    this.desktopContentElement.style.transform = 
      `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    
    // 应用到背景(网格)
    this.desktopBackgroundElement.style.transform = 
      `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    
    // 调整网格大小
    this.updateGridSize(scale);
  }
  
  // 根据缩放级别调整网格
  private updateGridSize(scale: number): void {
    const baseGridSize = 50;
    
    let gridSize = baseGridSize;
    let opacity = 0.2;
    
    // 缩放很小时,使用更粗的网格
    if (scale < 0.5) {
      gridSize = baseGridSize * 4;
      opacity = 0.15;
    } else if (scale < 1) {
      gridSize = baseGridSize * 2;
      opacity = 0.18;
    } else if (scale > 2) {
      gridSize = baseGridSize / 2;
      opacity = 0.22;
    }
    
    this.desktopBackgroundElement.style.backgroundSize = 
      `${gridSize}px ${gridSize}px`;
    this.desktopBackgroundElement.style.opacity = String(opacity);
  }
}
```

## 3. 缩放功能实现

### 3.1 缩放方法

```typescript
class InfiniteCanvasLayout {
  private minScale = 0.1;
  private maxScale = 5.0;
  
  /**
   * 缩放到指定级别
   * @param newScale 新的缩放级别
   * @param centerX 缩放中心的屏幕X坐标 (可选,默认屏幕中心)
   * @param centerY 缩放中心的屏幕Y坐标 (可选,默认屏幕中心)
   */
  zoomTo(newScale: number, centerX?: number, centerY?: number): void {
    // 限制缩放范围
    newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
    
    // 如果未指定中心点,使用屏幕中心
    if (centerX === undefined || centerY === undefined) {
      centerX = window.innerWidth / 2;
      centerY = window.innerHeight / 2;
    }
    
    // 计算缩放中心在世界坐标中的位置(缩放前)
    const worldX = (centerX - this.desktopTransform.translateX) / this.desktopTransform.scale;
    const worldY = (centerY - this.desktopTransform.translateY) / this.desktopTransform.scale;
    
    // 应用新的缩放
    const oldScale = this.desktopTransform.scale;
    this.desktopTransform.scale = newScale;
    
    // 调整平移,使缩放中心保持在相同的屏幕位置
    this.desktopTransform.translateX = centerX - worldX * newScale;
    this.desktopTransform.translateY = centerY - worldY * newScale;
    
    // 应用变换
    this.applyTransform();
    
    // 更新UI
    this.updateZoomUI();
  }
  
  /**
   * 增量缩放
   * @param delta 缩放增量 (>1 放大, <1 缩小)
   * @param centerX 缩放中心X
   * @param centerY 缩放中心Y
   */
  zoomBy(delta: number, centerX?: number, centerY?: number): void {
    const newScale = this.desktopTransform.scale * delta;
    this.zoomTo(newScale, centerX, centerY);
  }
  
  /**
   * 缩放到适应所有内容
   */
  zoomToFit(): void {
    const windows = this.getWindows();
    if (windows.length === 0) {
      // 没有窗口,重置到默认视图
      this.resetView();
      return;
    }
    
    // 计算所有窗口的边界框
    const bounds = this.calculateBounds(windows);
    
    // 添加一些边距
    const padding = 50;
    const boundsWidth = bounds.maxX - bounds.minX + padding * 2;
    const boundsHeight = bounds.maxY - bounds.minY + padding * 2;
    
    // 计算合适的缩放级别
    const scaleX = window.innerWidth / boundsWidth;
    const scaleY = window.innerHeight / boundsHeight;
    const scale = Math.min(scaleX, scaleY, 1.0);  // 不超过100%
    
    // 计算居中位置
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    
    // 应用变换
    this.desktopTransform.scale = scale;
    this.desktopTransform.translateX = window.innerWidth / 2 - centerX * scale;
    this.desktopTransform.translateY = window.innerHeight / 2 - centerY * scale;
    
    // 平滑动画到新视图
    this.animateTransform(this.desktopTransform, 400);
  }
  
  /**
   * 重置视图
   */
  resetView(): void {
    const targetTransform: Transform = {
      scale: 1,
      translateX: 0,
      translateY: 0,
    };
    this.animateTransform(targetTransform, 300);
  }
  
  // 计算窗口边界
  private calculateBounds(windows: Window[]): Bounds {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    
    for (const window of windows) {
      minX = Math.min(minX, window.position.x);
      minY = Math.min(minY, window.position.y);
      maxX = Math.max(maxX, window.position.x + window.size.width);
      maxY = Math.max(maxY, window.position.y + window.size.height);
    }
    
    return { minX, minY, maxX, maxY };
  }
  
  // 动画过渡到目标变换
  private animateTransform(target: Transform, duration: number): void {
    const start = { ...this.desktopTransform };
    const startTime = Date.now();
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // 使用 easeInOutCubic 缓动函数
      const eased = progress < 0.5
        ? 4 * progress * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      
      // 插值
      this.desktopTransform.scale = start.scale + (target.scale - start.scale) * eased;
      this.desktopTransform.translateX = start.translateX + (target.translateX - start.translateX) * eased;
      this.desktopTransform.translateY = start.translateY + (target.translateY - start.translateY) * eased;
      
      this.applyTransform();
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    
    animate();
  }
}
```

### 3.2 鼠标滚轮缩放

```typescript
class InfiniteCanvasLayout {
  private setupZoomHandlers(): void {
    // 鼠标滚轮缩放
    this.desktopLayerElement.addEventListener('wheel', (e) => {
      // 检查是否在空白区域(非窗口上)
      if (!this.isOverWindow(e.target as HTMLElement)) {
        e.preventDefault();
        
        // 计算缩放增量
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        
        // 以鼠标位置为中心缩放
        this.zoomBy(delta, e.clientX, e.clientY);
      }
    }, { passive: false });
    
    // Ctrl + 滚轮缩放 (在任何位置)
    window.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.zoomBy(delta, e.clientX, e.clientY);
      }
    }, { passive: false });
  }
  
  private isOverWindow(element: HTMLElement): boolean {
    return element.closest('.card-window, .box-window, .tool-window') !== null;
  }
}
```

### 3.3 触摸手势缩放

```typescript
class InfiniteCanvasLayout {
  private touchState = {
    isPinching: false,
    initialDistance: 0,
    initialScale: 1,
    centerX: 0,
    centerY: 0,
  };
  
  private setupTouchHandlers(): void {
    this.desktopLayerElement.addEventListener('touchstart', this.onTouchStart);
    this.desktopLayerElement.addEventListener('touchmove', this.onTouchMove);
    this.desktopLayerElement.addEventListener('touchend', this.onTouchEnd);
  }
  
  private onTouchStart = (e: TouchEvent) => {
    if (e.touches.length === 2) {
      // 双指触摸,开始缩放手势
      e.preventDefault();
      
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      // 计算两指距离
      this.touchState.initialDistance = this.getDistance(touch1, touch2);
      this.touchState.initialScale = this.desktopTransform.scale;
      this.touchState.isPinching = true;
      
      // 计算中心点
      this.touchState.centerX = (touch1.clientX + touch2.clientX) / 2;
      this.touchState.centerY = (touch1.clientY + touch2.clientY) / 2;
    }
  };
  
  private onTouchMove = (e: TouchEvent) => {
    if (this.touchState.isPinching && e.touches.length === 2) {
      e.preventDefault();
      
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      // 计算当前距离
      const currentDistance = this.getDistance(touch1, touch2);
      
      // 计算缩放比例
      const scale = (currentDistance / this.touchState.initialDistance) * this.touchState.initialScale;
      
      // 应用缩放
      this.zoomTo(scale, this.touchState.centerX, this.touchState.centerY);
    }
  };
  
  private onTouchEnd = (e: TouchEvent) => {
    if (e.touches.length < 2) {
      this.touchState.isPinching = false;
    }
  };
  
  private getDistance(touch1: Touch, touch2: Touch): number {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
}
```

### 3.4 缩放滑块

```typescript
class InfiniteCanvasLayout {
  private zoomSlider: HTMLInputElement;
  private zoomPercentage: HTMLElement;
  
  private setupZoomSlider(): void {
    this.zoomSlider = this.container.querySelector('.zoom-slider')!;
    this.zoomPercentage = this.container.querySelector('.zoom-percentage')!;
    
    // 滑块输入
    this.zoomSlider.addEventListener('input', () => {
      const scale = parseInt(this.zoomSlider.value) / 100;
      this.zoomTo(scale);
    });
    
    // 双击重置
    this.zoomPercentage.addEventListener('dblclick', () => {
      this.zoomTo(1.0);
    });
  }
  
  private updateZoomUI(): void {
    const percentage = Math.round(this.desktopTransform.scale * 100);
    this.zoomSlider.value = String(percentage);
    this.zoomPercentage.textContent = `${percentage}%`;
  }
}
```

### 3.5 键盘快捷键

```typescript
class InfiniteCanvasLayout {
  private setupKeyboardHandlers(): void {
    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case '=':
          case '+':
            e.preventDefault();
            this.zoomBy(1.2);  // 放大
            break;
          case '-':
            e.preventDefault();
            this.zoomBy(0.8);  // 缩小
            break;
          case '0':
            e.preventDefault();
            if (e.shiftKey) {
              this.zoomToFit();  // 适应所有内容
            } else {
              this.resetView();  // 重置到100%
            }
            break;
        }
      }
    });
  }
}
```

## 4. 平移功能实现

### 4.1 鼠标拖拽平移

```typescript
class InfiniteCanvasLayout {
  private panState = {
    isPanning: false,
    startX: 0,
    startY: 0,
    initialTranslateX: 0,
    initialTranslateY: 0,
  };
  
  private setupPanHandlers(): void {
    this.desktopLayerElement.addEventListener('mousedown', this.onPanStart);
    window.addEventListener('mousemove', this.onPanMove);
    window.addEventListener('mouseup', this.onPanEnd);
  }
  
  private onPanStart = (e: MouseEvent) => {
    // 只在空白区域开始平移
    if (!this.isOverWindow(e.target as HTMLElement)) {
      // 或者按住 Space 键
      if (e.button === 0 && (e.target === this.desktopLayerElement || e.spaceKey)) {
        e.preventDefault();
        
        this.panState.isPanning = true;
        this.panState.startX = e.clientX;
        this.panState.startY = e.clientY;
        this.panState.initialTranslateX = this.desktopTransform.translateX;
        this.panState.initialTranslateY = this.desktopTransform.translateY;
        
        // 改变鼠标指针
        this.desktopLayerElement.style.cursor = 'grabbing';
      }
    }
  };
  
  private onPanMove = (e: MouseEvent) => {
    if (this.panState.isPanning) {
      const dx = e.clientX - this.panState.startX;
      const dy = e.clientY - this.panState.startY;
      
      this.desktopTransform.translateX = this.panState.initialTranslateX + dx;
      this.desktopTransform.translateY = this.panState.initialTranslateY + dy;
      
      this.applyTransform();
    }
  };
  
  private onPanEnd = (e: MouseEvent) => {
    if (this.panState.isPanning) {
      this.panState.isPanning = false;
      this.desktopLayerElement.style.cursor = '';
    }
  };
}
```

### 4.2 按住 Space 键平移

```typescript
class InfiniteCanvasLayout {
  private spaceKeyDown = false;
  
  private setupSpaceKeyPan(): void {
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !this.spaceKeyDown) {
        this.spaceKeyDown = true;
        this.desktopLayerElement.style.cursor = 'grab';
      }
    });
    
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        this.spaceKeyDown = false;
        this.desktopLayerElement.style.cursor = '';
      }
    });
    
    // 修改鼠标按下判断
    this.onPanStart = (e: MouseEvent) => {
      if (!this.isOverWindow(e.target as HTMLElement) || this.spaceKeyDown) {
        // 允许平移
      }
    };
  }
}
```

### 4.3 触摸板双指平移

```typescript
class InfiniteCanvasLayout {
  private setupTouchpadPan(): void {
    this.desktopLayerElement.addEventListener('wheel', (e) => {
      // 检测是否是触摸板的平移手势
      if (e.ctrlKey === false && Math.abs(e.deltaX) > 0) {
        e.preventDefault();
        
        // 应用平移
        this.desktopTransform.translateX -= e.deltaX;
        this.desktopTransform.translateY -= e.deltaY;
        
        this.applyTransform();
      }
    }, { passive: false });
  }
}
```

### 4.4 触摸屏双指平移

```typescript
class InfiniteCanvasLayout {
  private panTouchState = {
    isPanning: false,
    startX: 0,
    startY: 0,
    initialTranslateX: 0,
    initialTranslateY: 0,
  };
  
  private onTouchStart = (e: TouchEvent) => {
    if (e.touches.length === 2 && !this.touchState.isPinching) {
      // 双指触摸,开始平移
      e.preventDefault();
      
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      
      this.panTouchState.isPanning = true;
      this.panTouchState.startX = centerX;
      this.panTouchState.startY = centerY;
      this.panTouchState.initialTranslateX = this.desktopTransform.translateX;
      this.panTouchState.initialTranslateY = this.desktopTransform.translateY;
    }
  };
  
  private onTouchMove = (e: TouchEvent) => {
    if (this.panTouchState.isPanning && e.touches.length === 2) {
      e.preventDefault();
      
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      
      const dx = centerX - this.panTouchState.startX;
      const dy = centerY - this.panTouchState.startY;
      
      this.desktopTransform.translateX = this.panTouchState.initialTranslateX + dx;
      this.desktopTransform.translateY = this.panTouchState.initialTranslateY + dy;
      
      this.applyTransform();
    }
  };
}
```

## 5. 窗口管理

### 5.1 窗口创建和定位

```typescript
class InfiniteCanvasLayout {
  createWindow(file: File, options?: WindowOptions): Window {
    const window: Window = {
      id: generateId(),
      type: 'card',
      fileId: file.id,
      position: options?.position || this.getDefaultWindowPosition(),
      size: options?.size || { width: 400, height: 600 },
      state: 'expanded',
      zIndex: this.getNextZIndex(),
      layer: 'desktop',
    };
    
    this.windows.set(window.id, window);
    
    // 创建 DOM 元素
    const windowElement = this.createWindowElement(window);
    this.desktopContentElement.appendChild(windowElement);
    
    // 渲染内容
    this.renderWindowContent(window, windowElement);
    
    return window;
  }
  
  private getDefaultWindowPosition(): Position {
    // 在视口中心创建窗口(世界坐标)
    const screenCenterX = window.innerWidth / 2;
    const screenCenterY = window.innerHeight / 2;
    
    // 转换到世界坐标
    const worldX = (screenCenterX - this.desktopTransform.translateX) / this.desktopTransform.scale;
    const worldY = (screenCenterY - this.desktopTransform.translateY) / this.desktopTransform.scale;
    
    return { x: worldX - 200, y: worldY - 300 };  // 偏移使窗口居中
  }
  
  private createWindowElement(window: Window): HTMLElement {
    const element = document.createElement('div');
    element.className = 'card-window';
    element.dataset.windowId = window.id;
    element.style.left = `${window.position.x}px`;
    element.style.top = `${window.position.y}px`;
    element.style.width = `${window.size.width}px`;
    element.style.height = `${window.size.height}px`;
    element.style.zIndex = String(window.zIndex);
    
    return element;
  }
}
```

### 5.2 窗口移动

```typescript
class InfiniteCanvasLayout {
  private windowDragState = {
    isDragging: false,
    windowId: '',
    startX: 0,
    startY: 0,
    initialX: 0,
    initialY: 0,
  };
  
  private setupWindowDrag(windowElement: HTMLElement, window: Window): void {
    const titleBar = windowElement.querySelector('.window-title-bar');
    
    titleBar.addEventListener('mousedown', (e: MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      
      this.windowDragState.isDragging = true;
      this.windowDragState.windowId = window.id;
      this.windowDragState.startX = e.clientX;
      this.windowDragState.startY = e.clientY;
      this.windowDragState.initialX = window.position.x;
      this.windowDragState.initialY = window.position.y;
      
      // 聚焦窗口
      this.focusWindow(window.id);
    });
  }
  
  private onWindowDragMove = (e: MouseEvent) => {
    if (this.windowDragState.isDragging) {
      const window = this.windows.get(this.windowDragState.windowId);
      if (!window) return;
      
      // 计算鼠标移动距离(屏幕坐标)
      const screenDx = e.clientX - this.windowDragState.startX;
      const screenDy = e.clientY - this.windowDragState.startY;
      
      // 转换到世界坐标(考虑缩放)
      const worldDx = screenDx / this.desktopTransform.scale;
      const worldDy = screenDy / this.desktopTransform.scale;
      
      // 更新窗口位置
      window.position.x = this.windowDragState.initialX + worldDx;
      window.position.y = this.windowDragState.initialY + worldDy;
      
      // 更新 DOM
      const windowElement = this.getWindowElement(window.id);
      windowElement.style.left = `${window.position.x}px`;
      windowElement.style.top = `${window.position.y}px`;
      
      // 标记为脏,触发保存
      this.markDirty();
    }
  };
  
  private onWindowDragEnd = (e: MouseEvent) => {
    if (this.windowDragState.isDragging) {
      this.windowDragState.isDragging = false;
    }
  };
}
```

### 5.3 窗口调整大小

```typescript
class InfiniteCanvasLayout {
  private resizeState = {
    isResizing: false,
    windowId: '',
    direction: '',  // 'e', 's', 'se' 等
    startX: 0,
    startY: 0,
    initialWidth: 0,
    initialHeight: 0,
    initialX: 0,
    initialY: 0,
  };
  
  private setupWindowResize(windowElement: HTMLElement, window: Window): void {
    // 添加调整大小手柄
    const handles = ['e', 's', 'w', 'n', 'se', 'sw', 'ne', 'nw'];
    
    for (const direction of handles) {
      const handle = document.createElement('div');
      handle.className = `resize-handle resize-${direction}`;
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.startResize(e, window, direction);
      });
      windowElement.appendChild(handle);
    }
  }
  
  private startResize(e: MouseEvent, window: Window, direction: string): void {
    this.resizeState.isResizing = true;
    this.resizeState.windowId = window.id;
    this.resizeState.direction = direction;
    this.resizeState.startX = e.clientX;
    this.resizeState.startY = e.clientY;
    this.resizeState.initialWidth = window.size.width;
    this.resizeState.initialHeight = window.size.height;
    this.resizeState.initialX = window.position.x;
    this.resizeState.initialY = window.position.y;
  }
  
  private onWindowResize = (e: MouseEvent) => {
    if (this.resizeState.isResizing) {
      const window = this.windows.get(this.resizeState.windowId);
      if (!window) return;
      
      const screenDx = e.clientX - this.resizeState.startX;
      const screenDy = e.clientY - this.resizeState.startY;
      
      // 转换到世界坐标
      const worldDx = screenDx / this.desktopTransform.scale;
      const worldDy = screenDy / this.desktopTransform.scale;
      
      const direction = this.resizeState.direction;
      
      // 根据方向调整大小
      if (direction.includes('e')) {
        window.size.width = this.resizeState.initialWidth + worldDx;
      }
      if (direction.includes('s')) {
        window.size.height = this.resizeState.initialHeight + worldDy;
      }
      if (direction.includes('w')) {
        window.size.width = this.resizeState.initialWidth - worldDx;
        window.position.x = this.resizeState.initialX + worldDx;
      }
      if (direction.includes('n')) {
        window.size.height = this.resizeState.initialHeight - worldDy;
        window.position.y = this.resizeState.initialY + worldDy;
      }
      
      // 限制最小尺寸
      window.size.width = Math.max(window.size.width, 200);
      window.size.height = Math.max(window.size.height, 100);
      
      // 更新 DOM
      this.updateWindowElement(window);
    }
  };
}
```

## 6. 性能优化

### 6.1 视口裁剪

```typescript
class InfiniteCanvasLayout {
  private updateVisibility(): void {
    // 计算可见区域(世界坐标)
    const viewportBounds = this.getViewportBounds();
    
    for (const [windowId, window] of this.windows) {
      const windowElement = this.getWindowElement(windowId);
      
      // 检查窗口是否在视口内
      const isVisible = this.isWindowVisible(window, viewportBounds);
      
      if (isVisible) {
        windowElement.style.display = '';
      } else {
        // 隐藏不可见窗口
        windowElement.style.display = 'none';
      }
    }
  }
  
  private getViewportBounds(): Bounds {
    const { scale, translateX, translateY } = this.desktopTransform;
    
    return {
      minX: -translateX / scale,
      minY: -translateY / scale,
      maxX: (window.innerWidth - translateX) / scale,
      maxY: (window.innerHeight - translateY) / scale,
    };
  }
  
  private isWindowVisible(window: Window, viewportBounds: Bounds): boolean {
    const wx1 = window.position.x;
    const wy1 = window.position.y;
    const wx2 = window.position.x + window.size.width;
    const wy2 = window.position.y + window.size.height;
    
    // AABB 碰撞检测
    return !(wx2 < viewportBounds.minX ||
             wx1 > viewportBounds.maxX ||
             wy2 < viewportBounds.minY ||
             wy1 > viewportBounds.maxY);
  }
  
  // 在平移或缩放后调用
  private applyTransform(): void {
    // ... 应用变换
    
    // 更新可见性
    this.updateVisibility();
  }
}
```

### 6.2 LOD (细节层次)

```typescript
class InfiniteCanvasLayout {
  private updateWindowLOD(): void {
    const scale = this.desktopTransform.scale;
    
    for (const [windowId, window] of this.windows) {
      const windowElement = this.getWindowElement(windowId);
      
      if (scale < 0.3) {
        // 非常小,显示简化版本
        windowElement.classList.add('lod-minimal');
        windowElement.classList.remove('lod-simple', 'lod-full');
      } else if (scale < 0.7) {
        // 较小,显示简单版本
        windowElement.classList.add('lod-simple');
        windowElement.classList.remove('lod-minimal', 'lod-full');
      } else {
        // 正常或放大,显示完整版本
        windowElement.classList.add('lod-full');
        windowElement.classList.remove('lod-minimal', 'lod-simple');
      }
    }
  }
}
```

```css
/* LOD 样式 */
.card-window.lod-minimal {
  /* 只显示封面或简化内容 */
}

.card-window.lod-minimal .card-content {
  display: none;
}

.card-window.lod-simple .card-content {
  /* 简化内容显示 */
  font-size: 12px;
}

.card-window.lod-full .card-content {
  /* 完整显示 */
}
```

### 6.3 节流和防抖

```typescript
class InfiniteCanvasLayout {
  private throttledUpdateVisibility = throttle(
    () => this.updateVisibility(),
    100  // 每100ms最多执行一次
  );
  
  private debouncedSave = debounce(
    () => this.saveState(),
    1000  // 1秒后执行
  );
  
  private applyTransform(): void {
    // 应用变换
    this.desktopContentElement.style.transform = /* ... */;
    
    // 节流更新可见性
    this.throttledUpdateVisibility();
  }
  
  private onWindowMove(): void {
    // 窗口移动
    
    // 防抖保存
    this.debouncedSave();
  }
}

// 工具函数
function throttle<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let lastTime = 0;
  return function(...args: Parameters<T>) {
    const now = Date.now();
    if (now - lastTime >= wait) {
      lastTime = now;
      func(...args);
    }
  };
}

function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  return function(...args: Parameters<T>) {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}
```

## 7. 坐标转换

### 7.1 屏幕坐标与世界坐标转换

```typescript
class InfiniteCanvasLayout {
  /**
   * 屏幕坐标转世界坐标
   */
  screenToWorld(screenX: number, screenY: number): Position {
    const { scale, translateX, translateY } = this.desktopTransform;
    
    return {
      x: (screenX - translateX) / scale,
      y: (screenY - translateY) / scale,
    };
  }
  
  /**
   * 世界坐标转屏幕坐标
   */
  worldToScreen(worldX: number, worldY: number): Position {
    const { scale, translateX, translateY } = this.desktopTransform;
    
    return {
      x: worldX * scale + translateX,
      y: worldY * scale + translateY,
    };
  }
}
```

## 8. 总结

无限画布布局的实现要点:

1. **两层设计**: 桌面层和窗口层分离,各司其职
2. **CSS Transform**: 使用 transform 实现高性能缩放和平移
3. **坐标系统**: 正确处理屏幕坐标和世界坐标的转换
4. **多种输入**: 支持鼠标、触摸板、触摸屏
5. **性能优化**: 视口裁剪、LOD、节流防抖
6. **流畅体验**: 动画过渡、即时反馈

通过精心的实现,无限画布提供了自由、流畅的工作空间,让用户可以自由组织和管理卡片。
