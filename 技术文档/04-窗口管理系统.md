# 卡片编辑引擎 - 窗口管理系统

## 1. 窗口管理系统概述

### 1.1 系统职责

窗口管理系统负责:
- 窗口的创建、显示、关闭
- 窗口状态管理
- 窗口堆叠顺序管理
- 窗口事件处理
- 窗口持久化

### 1.2 窗口类型

**卡片窗口 (Card Window)**:
- 显示复合卡片内容
- 包含多个基础卡片
- 支持多种显示状态

**箱子窗口 (Box Window)**:
- 显示箱子内容
- 布局由箱子插件决定

**工具窗口 (Tool Window)**:
- 文件管理器
- 编辑面板
- 卡箱库
- 设置面板等

**封面窗口 (Cover Window)**:
- 显示卡片封面
- 固定尺寸
- 点击展开为完整卡片

## 2. 数据结构设计

### 2.1 窗口数据模型

```typescript
interface Window {
  // 基本信息
  id: string;                    // 唯一标识符
  type: WindowType;              // 窗口类型
  
  // 关联数据
  fileId?: string;               // 关联的文件ID(卡片/箱子窗口)
  
  // 位置和大小
  position: Position;            // 位置(世界坐标或屏幕坐标)
  size: Size;                    // 尺寸
  
  // 状态
  state: WindowState;            // 显示状态
  zIndex: number;                // 堆叠层级
  layer: WindowLayer;            // 所在层级
  
  // 可选属性
  title?: string;                // 标题
  icon?: string;                 // 图标
  resizable?: boolean;           // 是否可调整大小
  movable?: boolean;             // 是否可移动
  closable?: boolean;            // 是否可关闭
  
  // 元数据
  createdAt: number;             // 创建时间
  updatedAt: number;             // 更新时间
}

enum WindowType {
  CARD = 'card',
  BOX = 'box',
  TOOL = 'tool',
  COVER = 'cover',
}

enum WindowState {
  EXPANDED = 'expanded',         // 展开(完整显示)
  COLLAPSED = 'collapsed',       // 收起(固定高度)
  COVER = 'cover',              // 封面模式
  MINIMIZED = 'minimized',      // 最小化
}

enum WindowLayer {
  DESKTOP = 'desktop',          // 桌面层
  WINDOW = 'window',            // 窗口层
}

interface Position {
  x: number;
  y: number;
}

interface Size {
  width: number;
  height: number;
}
```

### 2.2 窗口管理器类

```typescript
class WindowManager {
  // 窗口存储
  private windows: Map<string, Window> = new Map();
  
  // 焦点窗口
  private focusedWindowId: string | null = null;
  
  // z-index 管理
  private nextZIndex = 1000;
  private zIndexOrder: string[] = [];
  
  // 事件总线
  private eventBus: EventBus;
  
  // 布局上下文
  private layout: LayoutPlugin;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
  }
  
  // ===== 窗口生命周期 =====
  
  /**
   * 创建窗口
   */
  createWindow(options: CreateWindowOptions): Window {
    const window: Window = {
      id: generateId(),
      type: options.type,
      fileId: options.fileId,
      position: options.position || { x: 0, y: 0 },
      size: options.size || this.getDefaultSize(options.type),
      state: options.state || WindowState.EXPANDED,
      zIndex: this.getNextZIndex(),
      layer: options.layer || this.getDefaultLayer(options.type),
      title: options.title,
      icon: options.icon,
      resizable: options.resizable ?? true,
      movable: options.movable ?? true,
      closable: options.closable ?? true,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    
    // 保存窗口
    this.windows.set(window.id, window);
    
    // 添加到 z-index 顺序
    this.zIndexOrder.push(window.id);
    
    // 触发事件
    this.eventBus.emit('window:created', window);
    
    // 自动聚焦
    this.focusWindow(window.id);
    
    return window;
  }
  
  /**
   * 关闭窗口
   */
  closeWindow(windowId: string): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 触发关闭前事件(可取消)
    const event = { window, cancelled: false };
    this.eventBus.emit('window:before-close', event);
    if (event.cancelled) return;
    
    // 从存储中删除
    this.windows.delete(windowId);
    
    // 从 z-index 顺序中删除
    const index = this.zIndexOrder.indexOf(windowId);
    if (index !== -1) {
      this.zIndexOrder.splice(index, 1);
    }
    
    // 如果是焦点窗口,转移焦点
    if (this.focusedWindowId === windowId) {
      this.focusedWindowId = null;
      if (this.zIndexOrder.length > 0) {
        this.focusWindow(this.zIndexOrder[this.zIndexOrder.length - 1]);
      }
    }
    
    // 触发关闭事件
    this.eventBus.emit('window:closed', window);
  }
  
  /**
   * 销毁所有窗口
   */
  destroyAll(): void {
    const windowIds = Array.from(this.windows.keys());
    for (const windowId of windowIds) {
      this.closeWindow(windowId);
    }
  }
  
  // ===== 窗口查询 =====
  
  /**
   * 获取窗口
   */
  getWindow(windowId: string): Window | undefined {
    return this.windows.get(windowId);
  }
  
  /**
   * 获取所有窗口
   */
  getWindows(filter?: WindowFilter): Window[] {
    let windows = Array.from(this.windows.values());
    
    if (filter) {
      if (filter.type) {
        windows = windows.filter(w => w.type === filter.type);
      }
      if (filter.layer) {
        windows = windows.filter(w => w.layer === filter.layer);
      }
      if (filter.fileId) {
        windows = windows.filter(w => w.fileId === filter.fileId);
      }
    }
    
    return windows;
  }
  
  /**
   * 获取焦点窗口
   */
  getFocusedWindow(): Window | null {
    return this.focusedWindowId ? this.windows.get(this.focusedWindowId) || null : null;
  }
  
  /**
   * 根据文件ID查找窗口
   */
  findWindowByFileId(fileId: string): Window | undefined {
    return Array.from(this.windows.values()).find(w => w.fileId === fileId);
  }
  
  // ===== 窗口操作 =====
  
  /**
   * 聚焦窗口
   */
  focusWindow(windowId: string): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 更新焦点
    const previousFocusedId = this.focusedWindowId;
    this.focusedWindowId = windowId;
    
    // 提升到最前
    this.bringToFront(windowId);
    
    // 触发事件
    this.eventBus.emit('window:focused', { window, previousFocusedId });
  }
  
  /**
   * 移动窗口
   */
  moveWindow(windowId: string, position: Position): void {
    const window = this.windows.get(windowId);
    if (!window || !window.movable) return;
    
    window.position = position;
    window.updatedAt = Date.now();
    
    this.eventBus.emit('window:moved', window);
  }
  
  /**
   * 调整窗口大小
   */
  resizeWindow(windowId: string, size: Size): void {
    const window = this.windows.get(windowId);
    if (!window || !window.resizable) return;
    
    window.size = size;
    window.updatedAt = Date.now();
    
    this.eventBus.emit('window:resized', window);
  }
  
  /**
   * 改变窗口状态
   */
  changeWindowState(windowId: string, state: WindowState): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    const oldState = window.state;
    window.state = state;
    window.updatedAt = Date.now();
    
    this.eventBus.emit('window:state-changed', { window, oldState, newState: state });
  }
  
  /**
   * 更新窗口
   */
  updateWindow(windowId: string, updates: Partial<Window>): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    Object.assign(window, updates);
    window.updatedAt = Date.now();
    
    this.eventBus.emit('window:updated', window);
  }
  
  // ===== Z-Index 管理 =====
  
  /**
   * 提升到最前
   */
  bringToFront(windowId: string): void {
    // 从当前位置移除
    const index = this.zIndexOrder.indexOf(windowId);
    if (index !== -1) {
      this.zIndexOrder.splice(index, 1);
    }
    
    // 添加到末尾(最前)
    this.zIndexOrder.push(windowId);
    
    // 重新分配 z-index
    this.reassignZIndexes();
  }
  
  /**
   * 发送到最后
   */
  sendToBack(windowId: string): void {
    // 从当前位置移除
    const index = this.zIndexOrder.indexOf(windowId);
    if (index !== -1) {
      this.zIndexOrder.splice(index, 1);
    }
    
    // 添加到开头(最后)
    this.zIndexOrder.unshift(windowId);
    
    // 重新分配 z-index
    this.reassignZIndexes();
  }
  
  /**
   * 重新分配 z-index
   */
  private reassignZIndexes(): void {
    for (let i = 0; i < this.zIndexOrder.length; i++) {
      const windowId = this.zIndexOrder[i];
      const window = this.windows.get(windowId);
      if (window) {
        window.zIndex = 1000 + i;
      }
    }
  }
  
  /**
   * 获取下一个 z-index
   */
  private getNextZIndex(): number {
    return 1000 + this.zIndexOrder.length;
  }
  
  // ===== 辅助方法 =====
  
  /**
   * 获取默认大小
   */
  private getDefaultSize(type: WindowType): Size {
    switch (type) {
      case WindowType.CARD:
        return { width: 400, height: 600 };
      case WindowType.BOX:
        return { width: 600, height: 400 };
      case WindowType.TOOL:
        return { width: 300, height: 500 };
      case WindowType.COVER:
        return { width: 300, height: 400 };
      default:
        return { width: 400, height: 300 };
    }
  }
  
  /**
   * 获取默认层级
   */
  private getDefaultLayer(type: WindowType): WindowLayer {
    return type === WindowType.TOOL ? WindowLayer.WINDOW : WindowLayer.DESKTOP;
  }
}

interface CreateWindowOptions {
  type: WindowType;
  fileId?: string;
  position?: Position;
  size?: Size;
  state?: WindowState;
  layer?: WindowLayer;
  title?: string;
  icon?: string;
  resizable?: boolean;
  movable?: boolean;
  closable?: boolean;
}

interface WindowFilter {
  type?: WindowType;
  layer?: WindowLayer;
  fileId?: string;
}
```

## 3. 窗口组件实现

### 3.1 卡片窗口组件

```typescript
interface CardWindowProps {
  window: Window;
  onMove: (windowId: string, position: Position) => void;
  onResize: (windowId: string, size: Size) => void;
  onFocus: (windowId: string) => void;
  onClose: (windowId: string) => void;
  onStateChange: (windowId: string, state: WindowState) => void;
}

const CardWindow: React.FC<CardWindowProps> = ({
  window,
  onMove,
  onResize,
  onFocus,
  onClose,
  onStateChange,
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  
  // 拖动处理
  const handleDragStart = (e: React.MouseEvent) => {
    setIsDragging(true);
    onFocus(window.id);
    // ... 拖动逻辑
  };
  
  // 调整大小处理
  const handleResizeStart = (e: React.MouseEvent, direction: string) => {
    setIsResizing(true);
    // ... 调整大小逻辑
  };
  
  return (
    <div
      className={`card-window ${window.state}`}
      style={{
        left: window.position.x,
        top: window.position.y,
        width: window.size.width,
        height: window.state === WindowState.EXPANDED ? 'auto' : window.size.height,
        zIndex: window.zIndex,
      }}
      onClick={() => onFocus(window.id)}
    >
      {/* 标题栏 */}
      <div className="window-title-bar" onMouseDown={handleDragStart}>
        <div className="window-title">{window.title || '未命名卡片'}</div>
        <div className="window-controls">
          <button onClick={() => onStateChange(window.id, WindowState.MINIMIZED)}>
            <MinimizeIcon />
          </button>
          <button onClick={() => {
            const newState = window.state === WindowState.EXPANDED
              ? WindowState.COLLAPSED
              : WindowState.EXPANDED;
            onStateChange(window.id, newState);
          }}>
            <CollapseIcon />
          </button>
          <button onClick={() => onClose(window.id)}>
            <CloseIcon />
          </button>
        </div>
      </div>
      
      {/* 内容区 */}
      <div className="window-content">
        {/* 渲染卡片内容 */}
        <CardContent fileId={window.fileId!} />
      </div>
      
      {/* 调整大小手柄 */}
      {window.resizable && (
        <>
          <div className="resize-handle resize-e" onMouseDown={(e) => handleResizeStart(e, 'e')} />
          <div className="resize-handle resize-s" onMouseDown={(e) => handleResizeStart(e, 's')} />
          <div className="resize-handle resize-se" onMouseDown={(e) => handleResizeStart(e, 'se')} />
          {/* ... 其他方向 */}
        </>
      )}
    </div>
  );
};
```

### 3.2 工具窗口组件

```typescript
interface ToolWindowProps {
  window: Window;
  children: React.ReactNode;
  onMove: (windowId: string, position: Position) => void;
  onResize: (windowId: string, size: Size) => void;
  onClose: (windowId: string) => void;
  onCollapse: (windowId: string) => void;
}

const ToolWindow: React.FC<ToolWindowProps> = ({
  window,
  children,
  onMove,
  onResize,
  onClose,
  onCollapse,
}) => {
  const [isCollapsed, setIsCollapsed] = useState(false);
  
  const handleCollapse = () => {
    setIsCollapsed(!isCollapsed);
    onCollapse(window.id);
  };
  
  return (
    <div
      className={`tool-window ${isCollapsed ? 'collapsed' : ''}`}
      style={{
        left: window.position.x,
        top: window.position.y,
        width: window.size.width,
        height: isCollapsed ? 'auto' : window.size.height,
        zIndex: window.zIndex,
      }}
    >
      <div className="tool-window-header">
        <span className="tool-window-title">{window.title}</span>
        <div className="tool-window-controls">
          <button onClick={handleCollapse}>
            {isCollapsed ? <ExpandIcon /> : <CollapseIcon />}
          </button>
          <button onClick={() => onClose(window.id)}>
            <CloseIcon />
          </button>
        </div>
      </div>
      
      {!isCollapsed && (
        <div className="tool-window-content">
          {children}
        </div>
      )}
    </div>
  );
};
```

## 4. 窗口状态持久化

### 4.1 状态保存

```typescript
class WindowManager {
  /**
   * 获取所有窗口状态(用于持久化)
   */
  getState(): WindowManagerState {
    return {
      windows: Array.from(this.windows.values()).map(w => ({
        ...w,
      })),
      focusedWindowId: this.focusedWindowId,
      zIndexOrder: [...this.zIndexOrder],
    };
  }
  
  /**
   * 恢复窗口状态
   */
  setState(state: WindowManagerState): void {
    // 清空当前窗口
    this.windows.clear();
    this.zIndexOrder = [];
    
    // 恢复窗口
    for (const windowData of state.windows) {
      this.windows.set(windowData.id, windowData);
    }
    
    // 恢复 z-index 顺序
    this.zIndexOrder = [...state.zIndexOrder];
    
    // 恢复焦点
    this.focusedWindowId = state.focusedWindowId;
    
    // 触发事件
    this.eventBus.emit('windows:restored', state);
  }
  
  /**
   * 保存到本地存储
   */
  async save(): Promise<void> {
    const state = this.getState();
    await storage.set('windowManager', state);
  }
  
  /**
   * 从本地存储加载
   */
  async load(): Promise<void> {
    const state = await storage.get('windowManager');
    if (state) {
      this.setState(state);
    }
  }
}

interface WindowManagerState {
  windows: Window[];
  focusedWindowId: string | null;
  zIndexOrder: string[];
}
```

### 4.2 自动保存

```typescript
class WindowManager {
  private saveDebounced = debounce(() => this.save(), 1000);
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    
    // 监听窗口变化,自动保存
    this.eventBus.on('window:created', () => this.saveDebounced());
    this.eventBus.on('window:closed', () => this.saveDebounced());
    this.eventBus.on('window:moved', () => this.saveDebounced());
    this.eventBus.on('window:resized', () => this.saveDebounced());
    this.eventBus.on('window:state-changed', () => this.saveDebounced());
  }
}
```

## 5. 窗口事件处理

### 5.1 事件类型

```typescript
enum WindowEvent {
  // 生命周期事件
  CREATED = 'window:created',
  CLOSED = 'window:closed',
  BEFORE_CLOSE = 'window:before-close',
  
  // 状态事件
  FOCUSED = 'window:focused',
  BLURRED = 'window:blurred',
  STATE_CHANGED = 'window:state-changed',
  
  // 操作事件
  MOVED = 'window:moved',
  RESIZED = 'window:resized',
  UPDATED = 'window:updated',
  
  // 批量事件
  RESTORED = 'windows:restored',
}
```

### 5.2 事件监听

```typescript
// 在布局插件或其他模块中监听窗口事件
class MyLayoutPlugin {
  init(context: LayoutContext) {
    // 监听窗口创建
    context.events.on('window:created', (window: Window) => {
      console.log('Window created:', window);
      // 渲染窗口 DOM
      this.renderWindow(window);
    });
    
    // 监听窗口关闭
    context.events.on('window:closed', (window: Window) => {
      console.log('Window closed:', window);
      // 移除窗口 DOM
      this.removeWindow(window.id);
    });
    
    // 监听窗口移动
    context.events.on('window:moved', (window: Window) => {
      // 更新窗口位置
      this.updateWindowPosition(window);
    });
  }
}
```

## 6. 窗口查找和过滤

### 6.1 查找方法

```typescript
class WindowManager {
  /**
   * 查找窗口(通用方法)
   */
  findWindow(predicate: (window: Window) => boolean): Window | undefined {
    return Array.from(this.windows.values()).find(predicate);
  }
  
  /**
   * 查找所有符合条件的窗口
   */
  findWindows(predicate: (window: Window) => boolean): Window[] {
    return Array.from(this.windows.values()).filter(predicate);
  }
  
  /**
   * 根据文件ID查找
   */
  findWindowByFileId(fileId: string): Window | undefined {
    return this.findWindow(w => w.fileId === fileId);
  }
  
  /**
   * 根据类型查找
   */
  findWindowsByType(type: WindowType): Window[] {
    return this.findWindows(w => w.type === type);
  }
  
  /**
   * 查找桌面层窗口
   */
  getDesktopWindows(): Window[] {
    return this.findWindows(w => w.layer === WindowLayer.DESKTOP);
  }
  
  /**
   * 查找窗口层窗口
   */
  getWindowLayerWindows(): Window[] {
    return this.findWindows(w => w.layer === WindowLayer.WINDOW);
  }
  
  /**
   * 按 z-index 排序的窗口列表
   */
  getWindowsByZIndex(): Window[] {
    return this.zIndexOrder
      .map(id => this.windows.get(id))
      .filter((w): w is Window => w !== undefined);
  }
}
```

## 7. 窗口布局辅助

### 7.1 窗口排列

```typescript
class WindowManager {
  /**
   * 平铺窗口
   */
  tileWindows(): void {
    const windows = this.getDesktopWindows();
    if (windows.length === 0) return;
    
    // 计算网格布局
    const cols = Math.ceil(Math.sqrt(windows.length));
    const rows = Math.ceil(windows.length / cols);
    
    const cellWidth = window.innerWidth / cols;
    const cellHeight = window.innerHeight / rows;
    
    windows.forEach((win, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);
      
      this.moveWindow(win.id, {
        x: col * cellWidth,
        y: row * cellHeight,
      });
      
      this.resizeWindow(win.id, {
        width: cellWidth - 20,
        height: cellHeight - 20,
      });
    });
  }
  
  /**
   * 层叠窗口
   */
  cascadeWindows(): void {
    const windows = this.getDesktopWindows();
    const offset = 30;
    
    windows.forEach((win, index) => {
      this.moveWindow(win.id, {
        x: index * offset,
        y: index * offset,
      });
    });
  }
}
```

### 7.2 窗口对齐

```typescript
class WindowManager {
  /**
   * 对齐窗口
   */
  alignWindow(windowId: string, alignment: Alignment): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    let newPosition: Position;
    
    switch (alignment) {
      case 'top-left':
        newPosition = { x: 0, y: 0 };
        break;
      case 'top-center':
        newPosition = { x: (viewportWidth - window.size.width) / 2, y: 0 };
        break;
      case 'top-right':
        newPosition = { x: viewportWidth - window.size.width, y: 0 };
        break;
      case 'center':
        newPosition = {
          x: (viewportWidth - window.size.width) / 2,
          y: (viewportHeight - window.size.height) / 2,
        };
        break;
      // ... 其他对齐方式
    }
    
    this.moveWindow(windowId, newPosition);
  }
}

type Alignment = 
  | 'top-left' | 'top-center' | 'top-right'
  | 'center-left' | 'center' | 'center-right'
  | 'bottom-left' | 'bottom-center' | 'bottom-right';
```

## 8. 性能优化

### 8.1 批量更新

```typescript
class WindowManager {
  private updateQueue: Array<() => void> = [];
  private isUpdating = false;
  
  /**
   * 批量更新
   */
  batchUpdate(updates: Array<() => void>): void {
    this.updateQueue.push(...updates);
    
    if (!this.isUpdating) {
      this.isUpdating = true;
      requestAnimationFrame(() => {
        this.flushUpdates();
      });
    }
  }
  
  private flushUpdates(): void {
    while (this.updateQueue.length > 0) {
      const update = this.updateQueue.shift();
      update?.();
    }
    this.isUpdating = false;
  }
}
```

### 8.2 虚拟化

```typescript
class WindowManager {
  /**
   * 获取可见窗口
   */
  getVisibleWindows(viewportBounds: Bounds): Window[] {
    return this.getWindows().filter(window => {
      return this.isWindowInViewport(window, viewportBounds);
    });
  }
  
  private isWindowInViewport(window: Window, bounds: Bounds): boolean {
    const wx1 = window.position.x;
    const wy1 = window.position.y;
    const wx2 = window.position.x + window.size.width;
    const wy2 = window.position.y + window.size.height;
    
    return !(wx2 < bounds.minX || wx1 > bounds.maxX ||
             wy2 < bounds.minY || wy1 > bounds.maxY);
  }
}
```

## 9. 总结

窗口管理系统的设计要点:

1. **清晰的数据模型**: 完善的窗口数据结构
2. **生命周期管理**: 创建、更新、关闭的完整流程
3. **状态管理**: 窗口状态和堆叠顺序的管理
4. **事件驱动**: 通过事件实现模块解耦
5. **持久化**: 自动保存和恢复窗口状态
6. **性能优化**: 批量更新和虚拟化
7. **辅助功能**: 窗口排列、对齐等实用功能

通过完善的窗口管理系统,为编辑引擎提供了强大的窗口操作能力,保证了良好的用户体验。
