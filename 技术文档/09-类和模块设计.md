# 卡片编辑引擎 - 类和模块设计

## 1. 核心类图

```
EditorEngine (编辑引擎主类)
├── LayoutManager (布局管理器)
├── WindowManager (窗口管理器)
├── FileManager (文件管理器)
├── DragDropHandler (拖拽处理器)
├── SaveManager (保存管理器)
└── EventBus (事件总线)

LayoutManager
└── currentLayout: LayoutPlugin

WindowManager
├── windows: Map<string, Window>
└── zIndexOrder: string[]

FileManager
├── files: Map<string, File>
└── watcher: FSWatcher

DragDropHandler
├── currentDrag: DragState
└── dropTargets: Map<string, DropTarget>

SaveManager
├── dirtyFiles: Set<string>
└── saveQueue: SaveTask[]
```

## 2. 主要类设计

### 2.1 EditorEngine 编辑引擎主类

```typescript
class EditorEngine {
  // 核心组件
  private layoutManager: LayoutManager;
  private windowManager: WindowManager;
  private fileManager: FileManager;
  private dragDropHandler: DragDropHandler;
  private saveManager: SaveManager;
  private eventBus: EventBus;
  
  // 内核
  private kernel: Kernel;
  
  // 容器
  private container: HTMLElement;
  
  // 配置
  private config: EditorConfig;
  
  constructor(container: HTMLElement, config?: EditorConfig) {
    this.container = container;
    this.config = { ...defaultConfig, ...config };
    
    // 初始化事件总线
    this.eventBus = new EventBus();
    
    // 初始化内核
    this.kernel = new ChipsKernel(this.config.kernelConfig);
    
    // 初始化管理器
    this.fileManager = new FileManager(this.config.basePath, this.eventBus);
    this.windowManager = new WindowManager(this.eventBus);
    this.dragDropHandler = new DragDropHandler(this.eventBus);
    this.saveManager = new SaveManager(this.fileManager, this.eventBus);
    this.layoutManager = new LayoutManager(
      container,
      this.createLayoutContext(),
      this.eventBus
    );
  }
  
  // ===== 生命周期 =====
  
  async init(): Promise<void> {
    // 初始化文件管理器
    await this.fileManager.init();
    
    // 扫描布局插件
    await this.layoutManager.scanLayouts();
    
    // 加载默认布局
    const defaultLayout = this.config.defaultLayout || 'infinite-canvas';
    await this.layoutManager.switchLayout(defaultLayout);
    
    // 启动自动保存
    this.saveManager.start();
    
    // 触发初始化完成事件
    this.eventBus.emit('engine:initialized');
  }
  
  destroy(): void {
    // 停止自动保存
    this.saveManager.stop();
    
    // 销毁当前布局
    this.layoutManager.destroy();
    
    // 销毁所有窗口
    this.windowManager.destroyAll();
    
    // 停止文件监听
    this.fileManager.destroy();
    
    // 触发销毁事件
    this.eventBus.emit('engine:destroyed');
  }
  
  // ===== 布局操作 =====
  
  async switchLayout(layoutId: string): Promise<void> {
    await this.layoutManager.switchLayout(layoutId);
  }
  
  getLayouts(): LayoutInfo[] {
    return this.layoutManager.getLayouts();
  }
  
  getCurrentLayout(): LayoutPlugin | null {
    return this.layoutManager.getCurrentLayout();
  }
  
  // ===== 文件操作 =====
  
  async createFile(type: FileType, name: string): Promise<File> {
    return await this.fileManager.createFile(type, name);
  }
  
  async openFile(fileId: string): Promise<void> {
    const file = this.fileManager.getFile(fileId);
    if (!file) {
      throw new Error(`File not found: ${fileId}`);
    }
    
    // 检查是否已打开
    const existingWindow = this.windowManager.findWindowByFileId(fileId);
    if (existingWindow) {
      this.windowManager.focusWindow(existingWindow.id);
      return;
    }
    
    // 创建窗口
    const layout = this.layoutManager.getCurrentLayout();
    if (layout) {
      layout.createWindow(file);
    }
  }
  
  getFiles(): File[] {
    return this.fileManager.getFiles();
  }
  
  searchFiles(query: string): File[] {
    return this.fileManager.searchFiles(query);
  }
  
  // ===== 窗口操作 =====
  
  getWindows(): Window[] {
    return this.windowManager.getWindows();
  }
  
  getFocusedWindow(): Window | null {
    return this.windowManager.getFocusedWindow();
  }
  
  closeWindow(windowId: string): void {
    this.windowManager.closeWindow(windowId);
  }
  
  // ===== 事件订阅 =====
  
  on(event: string, handler: EventHandler): void {
    this.eventBus.on(event, handler);
  }
  
  off(event: string, handler: EventHandler): void {
    this.eventBus.off(event, handler);
  }
  
  // ===== 私有方法 =====
  
  private createLayoutContext(): LayoutContext {
    return {
      kernel: this.kernel,
      windowManager: this.windowManager,
      fileManager: this.fileManager,
      dragDropHandler: this.dragDropHandler,
      eventBus: this.eventBus,
      config: this.config,
    };
  }
}

interface EditorConfig {
  basePath: string;
  defaultLayout?: string;
  autoSaveInterval?: number;
  kernelConfig?: any;
}

const defaultConfig: EditorConfig = {
  basePath: './data',
  defaultLayout: 'infinite-canvas',
  autoSaveInterval: 5000,
};
```

### 2.2 LayoutManager 布局管理器

```typescript
class LayoutManager {
  private layouts: Map<string, LayoutPluginInfo>;
  private currentLayout: LayoutPlugin | null;
  private container: HTMLElement;
  private context: LayoutContext;
  private eventBus: EventBus;
  private savedStates: Map<string, LayoutState>;
  
  constructor(
    container: HTMLElement,
    context: LayoutContext,
    eventBus: EventBus
  ) {
    this.container = container;
    this.context = context;
    this.eventBus = eventBus;
    this.layouts = new Map();
    this.savedStates = new Map();
  }
  
  async scanLayouts(): Promise<void> { /* ... */ }
  async switchLayout(layoutId: string): Promise<void> { /* ... */ }
  getLayouts(): LayoutInfo[] { /* ... */ }
  getCurrentLayout(): LayoutPlugin | null { /* ... */ }
  destroy(): void { /* ... */ }
}
```

### 2.3 WindowManager 窗口管理器

```typescript
class WindowManager {
  private windows: Map<string, Window>;
  private focusedWindowId: string | null;
  private nextZIndex: number;
  private zIndexOrder: string[];
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    this.windows = new Map();
    this.zIndexOrder = [];
    this.nextZIndex = 1000;
  }
  
  createWindow(options: CreateWindowOptions): Window { /* ... */ }
  closeWindow(windowId: string): void { /* ... */ }
  focusWindow(windowId: string): void { /* ... */ }
  getWindow(windowId: string): Window | undefined { /* ... */ }
  getWindows(filter?: WindowFilter): Window[] { /* ... */ }
  findWindowByFileId(fileId: string): Window | undefined { /* ... */ }
  // ... 其他方法
}
```

### 2.4 FileManager 文件管理器

```typescript
class FileManager {
  private files: Map<string, File>;
  private basePath: string;
  private eventBus: EventBus;
  private watcher: FSWatcher | null;
  
  constructor(basePath: string, eventBus: EventBus) {
    this.basePath = basePath;
    this.eventBus = eventBus;
    this.files = new Map();
  }
  
  async init(): Promise<void> { /* ... */ }
  async createFile(type: FileType, name: string): Promise<File> { /* ... */ }
  async readFile(fileId: string): Promise<any> { /* ... */ }
  async updateFile(fileId: string, data: any): Promise<void> { /* ... */ }
  async deleteFile(fileId: string): Promise<void> { /* ... */ }
  getFile(fileId: string): File | undefined { /* ... */ }
  getFiles(options?: FileListOptions): File[] { /* ... */ }
  searchFiles(query: string): File[] { /* ... */ }
  destroy(): void { /* ... */ }
}
```

### 2.5 DragDropHandler 拖拽处理器

```typescript
class DragDropHandler {
  private currentDrag: DragState | null;
  private dropTargets: Map<string, DropTarget>;
  private dragPreview: HTMLElement | null;
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    this.dropTargets = new Map();
    this.setupGlobalListeners();
  }
  
  startDrag(source: DragSource, event: MouseEvent | TouchEvent): void { /* ... */ }
  registerDropTarget(id: string, target: DropTarget): void { /* ... */ }
  unregisterDropTarget(id: string): void { /* ... */ }
  // ... 其他方法
}
```

### 2.6 SaveManager 保存管理器

```typescript
class SaveManager {
  private fileManager: FileManager;
  private eventBus: EventBus;
  private dirtyFiles: Set<string>;
  private saveQueue: SaveTask[];
  private saveTimer: NodeJS.Timeout | null;
  private interval: number;
  
  constructor(fileManager: FileManager, eventBus: EventBus, interval = 5000) {
    this.fileManager = fileManager;
    this.eventBus = eventBus;
    this.interval = interval;
    this.dirtyFiles = new Set();
    this.saveQueue = [];
  }
  
  markDirty(fileId: string): void { /* ... */ }
  async saveNow(fileId: string): Promise<void> { /* ... */ }
  async saveAll(): Promise<void> { /* ... */ }
  start(): void { /* ... */ }
  stop(): void { /* ... */ }
}
```

### 2.7 EventBus 事件总线

```typescript
class EventBus {
  private events: Map<string, Set<EventHandler>>;
  
  constructor() {
    this.events = new Map();
  }
  
  on(event: string, handler: EventHandler): void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }
  
  off(event: string, handler: EventHandler): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }
  
  emit(event: string, data?: any): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in event handler for ${event}:`, error);
        }
      });
    }
  }
  
  once(event: string, handler: EventHandler): void {
    const onceHandler = (data: any) => {
      handler(data);
      this.off(event, onceHandler);
    };
    this.on(event, onceHandler);
  }
}

type EventHandler = (data?: any) => void;
```

## 3. 模块组织

### 3.1 目录结构

```
src/
├── engine/                    # 编辑引擎核心
│   ├── EditorEngine.ts       # 主类
│   ├── LayoutManager.ts
│   ├── WindowManager.ts
│   ├── FileManager.ts
│   ├── DragDropHandler.ts
│   ├── SaveManager.ts
│   └── EventBus.ts
│
├── kernel/                    # 内核
│   ├── Kernel.ts
│   ├── PluginLoader.ts
│   ├── FileRecognizer.ts
│   ├── DataProcessor.ts
│   ├── ResourceManager.ts
│   └── ConfigManager.ts
│
├── layouts/                   # 布局插件
│   ├── infinite-canvas/
│   │   ├── InfiniteCanvasLayout.ts
│   │   ├── components/
│   │   └── styles/
│   └── workbench/
│       ├── WorkbenchLayout.ts
│       ├── components/
│       └── styles/
│
├── plugins/                   # 其他插件
│   ├── editors/              # 编辑组件插件
│   ├── renderers/            # 渲染器插件
│   └── themes/               # 主题插件
│
├── ui/                        # UI 组件
│   ├── components/
│   ├── styles/
│   └── utils/
│
├── types/                     # 类型定义
│   ├── engine.ts
│   ├── kernel.ts
│   ├── plugins.ts
│   └── index.ts
│
└── utils/                     # 工具函数
    ├── id.ts
    ├── file.ts
    ├── dom.ts
    └── index.ts
```

### 3.2 模块导出

```typescript
// src/index.ts
export { EditorEngine } from './engine/EditorEngine';
export { EventBus } from './engine/EventBus';

export type {
  Window,
  WindowType,
  WindowState,
  File,
  FileType,
  LayoutPlugin,
  EditorPlugin,
  RendererPlugin,
} from './types';

// 默认导出
export default EditorEngine;
```

## 4. 依赖关系

```
EditorEngine
  ├─> LayoutManager ─> LayoutPlugin
  ├─> WindowManager
  ├─> FileManager ─> fs-extra, chokidar
  ├─> DragDropHandler
  ├─> SaveManager ─> FileManager
  ├─> EventBus
  └─> Kernel
        ├─> PluginLoader
        ├─> FileRecognizer
        └─> ResourceManager
```

## 5. 设计模式

### 5.1 单例模式

```typescript
// EditorEngine 可以作为单例使用
class EditorEngine {
  private static instance: EditorEngine | null = null;
  
  static getInstance(container?: HTMLElement, config?: EditorConfig): EditorEngine {
    if (!EditorEngine.instance) {
      if (!container) {
        throw new Error('Container required for first initialization');
      }
      EditorEngine.instance = new EditorEngine(container, config);
    }
    return EditorEngine.instance;
  }
}
```

### 5.2 发布-订阅模式

```typescript
// EventBus 实现发布-订阅
this.eventBus.on('file:opened', handler);
this.eventBus.emit('file:opened', fileData);
```

### 5.3 策略模式

```typescript
// 不同的布局策略
interface LayoutStrategy {
  createWindow(file: File): Window;
  arrangeWindows(): void;
}
```

### 5.4 工厂模式

```typescript
// PluginLoader 作为插件工厂
class PluginLoader {
  async createPlugin(type: PluginType, id: string): Promise<Plugin> {
    // 根据类型创建不同的插件实例
  }
}
```

### 5.5 观察者模式

```typescript
// WindowManager 观察窗口变化
this.eventBus.on('window:created', this.onWindowCreated);
this.eventBus.on('window:closed', this.onWindowClosed);
```

## 6. 测试结构

```
tests/
├── unit/                      # 单元测试
│   ├── LayoutManager.test.ts
│   ├── WindowManager.test.ts
│   ├── FileManager.test.ts
│   └── EventBus.test.ts
│
├── integration/               # 集成测试
│   ├── layout-switching.test.ts
│   ├── file-operations.test.ts
│   └── drag-drop.test.ts
│
└── e2e/                       # 端到端测试
    ├── create-card.test.ts
    ├── edit-card.test.ts
    └── switch-layout.test.ts
```

## 7. 总结

类和模块设计的要点:

1. **清晰的职责分离**: 每个类负责特定功能
2. **依赖注入**: 通过构造函数注入依赖
3. **接口驱动**: 定义清晰的接口和类型
4. **事件解耦**: 通过事件总线实现模块间通信
5. **可测试性**: 设计便于单元测试
6. **可扩展性**: 使用插件模式支持扩展

通过良好的类和模块设计,代码结构清晰,易于理解、维护和扩展。
