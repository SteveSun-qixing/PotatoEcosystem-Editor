# 卡片编辑引擎 - 编辑面板系统

## 1. 编辑面板概述

### 1.1 定位

编辑面板是容器,不提供具体编辑功能。实际的编辑界面由编辑组件插件提供。

### 1.2 职责

- 提供插件挂载点
- 管理插件加载和卸载
- 处理插件与数据的交互
- 显示和隐藏面板

## 2. 编辑面板数据结构

```typescript
interface EditPanel {
  visible: boolean;
  currentCardId: string | null;
  currentBaseCardId: string | null;
  currentPlugin: EditorPlugin | null;
  position: 'right' | 'left' | 'bottom';
  width?: number;
  height?: number;
}

interface EditorPlugin {
  id: string;
  mount(container: HTMLElement, data: any): void | Promise<void>;
  unmount(): void | Promise<void>;
  getData(): any;
  validate?(): boolean;
}
```

## 3. 编辑面板管理器

```typescript
class EditPanelManager {
  private panel: EditPanel;
  private container: HTMLElement;
  private pluginContainer: HTMLElement;
  private eventBus: EventBus;
  private kernel: Kernel;
  
  constructor(container: HTMLElement, eventBus: EventBus, kernel: Kernel) {
    this.container = container;
    this.eventBus = eventBus;
    this.kernel = kernel;
    
    this.panel = {
      visible: false,
      currentCardId: null,
      currentBaseCardId: null,
      currentPlugin: null,
      position: 'right',
    };
    
    this.init();
  }
  
  private init(): void {
    this.createPanelUI();
    this.setupEventListeners();
  }
  
  // ===== 面板操作 =====
  
  async open(cardId: string, baseCardId: string): Promise<void> {
    // 如果已打开相同的卡片,不重复加载
    if (this.panel.currentCardId === cardId && 
        this.panel.currentBaseCardId === baseCardId) {
      return;
    }
    
    // 卸载当前插件
    if (this.panel.currentPlugin) {
      await this.unloadPlugin();
    }
    
    // 获取基础卡片类型
    const baseCard = await this.kernel.getBaseCard(cardId, baseCardId);
    const cardType = baseCard.type;
    
    // 加载对应的编辑组件插件
    const plugin = await this.kernel.getEditorPlugin(cardType);
    
    // 挂载插件
    await plugin.mount(this.pluginContainer, baseCard.data);
    
    // 更新状态
    this.panel.currentCardId = cardId;
    this.panel.currentBaseCardId = baseCardId;
    this.panel.currentPlugin = plugin;
    this.panel.visible = true;
    
    // 显示面板
    this.show();
    
    // 触发事件
    this.eventBus.emit('edit-panel:opened', { cardId, baseCardId });
  }
  
  async close(): Promise<void> {
    if (!this.panel.visible) return;
    
    // 卸载插件
    if (this.panel.currentPlugin) {
      await this.unloadPlugin();
    }
    
    // 重置状态
    this.panel.currentCardId = null;
    this.panel.currentBaseCardId = null;
    this.panel.currentPlugin = null;
    this.panel.visible = false;
    
    // 隐藏面板
    this.hide();
    
    // 触发事件
    this.eventBus.emit('edit-panel:closed');
  }
  
  private show(): void {
    this.container.classList.add('visible');
  }
  
  private hide(): void {
    this.container.classList.remove('visible');
  }
  
  // ===== 插件管理 =====
  
  private async unloadPlugin(): Promise<void> {
    if (!this.panel.currentPlugin) return;
    
    // 获取数据
    const data = this.panel.currentPlugin.getData();
    
    // 保存数据
    if (this.panel.currentCardId && this.panel.currentBaseCardId) {
      await this.kernel.updateBaseCard(
        this.panel.currentCardId,
        this.panel.currentBaseCardId,
        data
      );
    }
    
    // 卸载插件
    await this.panel.currentPlugin.unmount();
    
    // 清空容器
    this.pluginContainer.innerHTML = '';
  }
  
  // ===== UI 创建 =====
  
  private createPanelUI(): void {
    this.container.innerHTML = `
      <div class="edit-panel-header">
        <span class="edit-panel-title">编辑</span>
        <button class="edit-panel-close">×</button>
      </div>
      <div class="edit-panel-content"></div>
    `;
    
    this.pluginContainer = this.container.querySelector('.edit-panel-content')!;
    
    // 关闭按钮
    const closeButton = this.container.querySelector('.edit-panel-close')!;
    closeButton.addEventListener('click', () => this.close());
  }
  
  // ===== 事件监听 =====
  
  private setupEventListeners(): void {
    // 监听基础卡片选中事件
    this.eventBus.on('base-card:selected', (event) => {
      this.open(event.cardId, event.baseCardId);
    });
    
    // 监听编辑模式切换
    this.eventBus.on('card:edit-mode-changed', (event) => {
      if (!event.editMode) {
        this.close();
      }
    });
  }
}
```

## 4. React 实现示例

```typescript
const EditPanel: React.FC<{
  visible: boolean;
  cardId: string | null;
  baseCardId: string | null;
  onClose: () => void;
}> = ({ visible, cardId, baseCardId, onClose }) => {
  const pluginContainerRef = useRef<HTMLDivElement>(null);
  const [plugin, setPlugin] = useState<EditorPlugin | null>(null);
  
  // 加载插件
  useEffect(() => {
    if (!visible || !cardId || !baseCardId) return;
    
    let mounted = true;
    
    (async () => {
      try {
        // 获取基础卡片数据
        const baseCard = await kernel.getBaseCard(cardId, baseCardId);
        
        // 加载编辑组件插件
        const editorPlugin = await kernel.getEditorPlugin(baseCard.type);
        
        if (!mounted) return;
        
        // 挂载插件
        await editorPlugin.mount(pluginContainerRef.current!, baseCard.data);
        
        setPlugin(editorPlugin);
      } catch (error) {
        console.error('Failed to load editor plugin:', error);
      }
    })();
    
    return () => {
      mounted = false;
      
      // 卸载插件
      if (plugin) {
        (async () => {
          const data = plugin.getData();
          await kernel.updateBaseCard(cardId, baseCardId, data);
          await plugin.unmount();
        })();
      }
    };
  }, [visible, cardId, baseCardId]);
  
  if (!visible) return null;
  
  return (
    <div className="edit-panel">
      <div className="edit-panel-header">
        <span>编辑</span>
        <button onClick={onClose}>×</button>
      </div>
      <div ref={pluginContainerRef} className="edit-panel-content" />
    </div>
  );
};
```

## 5. 编辑组件插件接口

```typescript
interface EditorPlugin {
  // 元数据
  id: string;
  name: string;
  version: string;
  
  // 生命周期
  mount(container: HTMLElement, data: any): void | Promise<void>;
  unmount(): void | Promise<void>;
  
  // 数据操作
  getData(): any;
  setData(data: any): void;
  
  // 验证
  validate?(): boolean | Promise<boolean>;
  
  // 事件
  onSave?(): void | Promise<void>;
  onReset?(): void;
}
```

## 6. 编辑组件插件示例

```typescript
// 富文本编辑组件
class RichTextEditorPlugin implements EditorPlugin {
  id = 'rich-text-editor';
  name = 'Rich Text Editor';
  version = '1.0.0';
  
  private editor: any; // Quill editor 实例
  private container: HTMLElement | null = null;
  
  async mount(container: HTMLElement, data: any): Promise<void> {
    this.container = container;
    
    // 创建编辑器容器
    const editorElement = document.createElement('div');
    editorElement.className = 'rich-text-editor';
    container.appendChild(editorElement);
    
    // 初始化 Quill 编辑器
    this.editor = new Quill(editorElement, {
      theme: 'snow',
      modules: {
        toolbar: [
          ['bold', 'italic', 'underline'],
          ['link', 'image'],
          [{ list: 'ordered' }, { list: 'bullet' }],
        ],
      },
    });
    
    // 设置初始内容
    if (data.content) {
      this.editor.setContents(data.content);
    }
  }
  
  async unmount(): Promise<void> {
    if (this.container) {
      this.container.innerHTML = '';
    }
    this.editor = null;
  }
  
  getData(): any {
    return {
      content: this.editor.getContents(),
      text: this.editor.getText(),
    };
  }
  
  setData(data: any): void {
    if (this.editor && data.content) {
      this.editor.setContents(data.content);
    }
  }
  
  validate(): boolean {
    // 检查是否有内容
    return this.editor.getText().trim().length > 0;
  }
}

// 图片编辑组件
class ImageEditorPlugin implements EditorPlugin {
  id = 'image-editor';
  name = 'Image Editor';
  version = '1.0.0';
  
  private container: HTMLElement | null = null;
  private imageUrl: string = '';
  private caption: string = '';
  private fitMode: 'contain' | 'cover' | 'fill' = 'contain';
  
  async mount(container: HTMLElement, data: any): Promise<void> {
    this.container = container;
    this.imageUrl = data.url || '';
    this.caption = data.caption || '';
    this.fitMode = data.fitMode || 'contain';
    
    this.render();
  }
  
  private render(): void {
    if (!this.container) return;
    
    this.container.innerHTML = `
      <div class="image-editor">
        <div class="image-editor-preview">
          ${this.imageUrl 
            ? `<img src="${this.imageUrl}" alt="${this.caption}" />` 
            : '<div class="image-placeholder">点击上传图片</div>'}
        </div>
        
        <div class="image-editor-controls">
          <label>
            图片:
            <input type="file" accept="image/*" class="image-upload" />
          </label>
          
          <label>
            标题:
            <input type="text" class="image-caption" value="${this.caption}" />
          </label>
          
          <label>
            适配模式:
            <select class="image-fit-mode">
              <option value="contain" ${this.fitMode === 'contain' ? 'selected' : ''}>包含</option>
              <option value="cover" ${this.fitMode === 'cover' ? 'selected' : ''}>覆盖</option>
              <option value="fill" ${this.fitMode === 'fill' ? 'selected' : ''}>填充</option>
            </select>
          </label>
        </div>
      </div>
    `;
    
    // 绑定事件
    this.bindEvents();
  }
  
  private bindEvents(): void {
    const uploadInput = this.container!.querySelector('.image-upload') as HTMLInputElement;
    const captionInput = this.container!.querySelector('.image-caption') as HTMLInputElement;
    const fitModeSelect = this.container!.querySelector('.image-fit-mode') as HTMLSelectElement;
    
    uploadInput.addEventListener('change', async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        this.imageUrl = await this.uploadImage(file);
        this.render();
      }
    });
    
    captionInput.addEventListener('input', (e) => {
      this.caption = (e.target as HTMLInputElement).value;
    });
    
    fitModeSelect.addEventListener('change', (e) => {
      this.fitMode = (e.target as HTMLSelectElement).value as any;
    });
  }
  
  private async uploadImage(file: File): Promise<string> {
    // 上传图片到资源目录
    // 返回图片URL
    return 'uploaded-image-url';
  }
  
  async unmount(): Promise<void> {
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
  
  getData(): any {
    return {
      url: this.imageUrl,
      caption: this.caption,
      fitMode: this.fitMode,
    };
  }
  
  setData(data: any): void {
    this.imageUrl = data.url || '';
    this.caption = data.caption || '';
    this.fitMode = data.fitMode || 'contain';
    this.render();
  }
  
  validate(): boolean {
    return !!this.imageUrl;
  }
}
```

## 7. 实时保存

```typescript
class EditPanelManager {
  private autoSaveInterval = 5000; // 5秒
  private autoSaveTimer: NodeJS.Timeout | null = null;
  
  private startAutoSave(): void {
    this.autoSaveTimer = setInterval(() => {
      this.saveCurrentData();
    }, this.autoSaveInterval);
  }
  
  private stopAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }
  
  private async saveCurrentData(): Promise<void> {
    if (!this.panel.currentPlugin || 
        !this.panel.currentCardId || 
        !this.panel.currentBaseCardId) {
      return;
    }
    
    // 获取数据
    const data = this.panel.currentPlugin.getData();
    
    // 保存到文件
    await this.kernel.updateBaseCard(
      this.panel.currentCardId,
      this.panel.currentBaseCardId,
      data
    );
    
    // 触发保存事件
    this.eventBus.emit('edit-panel:data-saved');
  }
  
  async open(cardId: string, baseCardId: string): Promise<void> {
    // ... 加载插件
    
    // 启动自动保存
    this.startAutoSave();
  }
  
  async close(): Promise<void> {
    // 停止自动保存
    this.stopAutoSave();
    
    // 最后一次保存
    await this.saveCurrentData();
    
    // ... 卸载插件
  }
}
```

## 8. 推荐的编辑器库

### 8.1 富文本编辑器

- **Quill**: 轻量、可扩展
- **TinyMCE**: 功能丰富
- **Slate**: React 友好
- **ProseMirror**: 强大灵活

### 8.2 Markdown 编辑器

- **CodeMirror**: 功能强大
- **Monaco Editor**: VS Code 编辑器
- **SimpleMDE**: 简单易用

### 8.3 代码编辑器

- **Monaco Editor**: 推荐
- **CodeMirror**: 轻量
- **Ace Editor**: 经典

### 8.4 图片编辑

- **Cropper.js**: 裁剪
- **Fabric.js**: 画布编辑
- **Tui.Image-Editor**: 综合编辑器

## 9. 总结

编辑面板系统的设计要点:

1. **容器定位**: 面板是容器,编辑功能由插件提供
2. **插件管理**: 动态加载和卸载编辑组件插件
3. **数据交互**: 插件与数据的双向绑定
4. **实时保存**: 自动保存机制
5. **生命周期**: 完善的插件生命周期管理
6. **接口标准**: 统一的插件接口规范

通过编辑面板系统,为不同类型的基础卡片提供了灵活的编辑能力,同时保持了系统的可扩展性。
