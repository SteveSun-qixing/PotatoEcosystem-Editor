# 卡片编辑引擎 - 与内核交互

## 1. 内核概述

### 1.1 内核职责

内核(Kernel)是编辑引擎和插件系统之间的桥梁,负责:

- 插件加载和管理
- 文件识别和路由
- 数据处理和转换
- 资源管理
- 配置管理

### 1.2 架构关系

```
编辑引擎 ←→ 内核 ←→ 插件系统
  ↓
布局管理器    文件识别器
窗口管理器    插件加载器
文件管理器    路由调度器
拖拽处理器    数据处理器
保存管理器    资源管理器
```

## 2. 内核接口定义

```typescript
interface Kernel {
  // ===== 插件管理 =====
  
  /**
   * 加载布局插件
   */
  loadLayoutPlugin(layoutId: string): Promise<LayoutPlugin>;
  
  /**
   * 加载编辑组件插件
   */
  loadEditorPlugin(cardType: string): Promise<EditorPlugin>;
  
  /**
   * 加载渲染器插件
   */
  loadRendererPlugin(cardType: string): Promise<RendererPlugin>;
  
  /**
   * 获取已安装的插件列表
   */
  getInstalledPlugins(type?: PluginType): Promise<PluginInfo[]>;
  
  // ===== 文件操作 =====
  
  /**
   * 识别文件类型
   */
  recognizeFile(filePath: string): Promise<FileType>;
  
  /**
   * 读取卡片文件
   */
  readCard(cardId: string): Promise<CardData>;
  
  /**
   * 写入卡片文件
   */
  writeCard(cardId: string, data: CardData): Promise<void>;
  
  /**
   * 读取箱子文件
   */
  readBox(boxId: string): Promise<BoxData>;
  
  /**
   * 写入箱子文件
   */
  writeBox(boxId: string, data: BoxData): Promise<void>;
  
  // ===== 基础卡片操作 =====
  
  /**
   * 获取基础卡片数据
   */
  getBaseCard(cardId: string, baseCardId: string): Promise<BaseCardData>;
  
  /**
   * 更新基础卡片数据
   */
  updateBaseCard(cardId: string, baseCardId: string, data: any): Promise<void>;
  
  /**
   * 添加基础卡片
   */
  addBaseCard(cardId: string, cardType: string, data: any, index?: number): Promise<BaseCardData>;
  
  /**
   * 删除基础卡片
   */
  deleteBaseCard(cardId: string, baseCardId: string): Promise<void>;
  
  /**
   * 调整基础卡片顺序
   */
  reorderBaseCards(cardId: string, baseCardIds: string[]): Promise<void>;
  
  // ===== 渲染 =====
  
  /**
   * 渲染卡片
   */
  renderCard(cardId: string, container: HTMLElement, options?: RenderOptions): Promise<void>;
  
  /**
   * 渲染箱子
   */
  renderBox(boxId: string, container: HTMLElement, options?: RenderOptions): Promise<void>;
  
  // ===== 资源管理 =====
  
  /**
   * 上传资源
   */
  uploadResource(file: File, targetPath?: string): Promise<string>;
  
  /**
   * 获取资源URL
   */
  getResourceURL(resourcePath: string): string;
  
  /**
   * 删除资源
   */
  deleteResource(resourcePath: string): Promise<void>;
  
  // ===== 配置 =====
  
  /**
   * 获取配置
   */
  getConfig(key: string): any;
  
  /**
   * 设置配置
   */
  setConfig(key: string, value: any): void;
  
  // ===== 事件 =====
  
  /**
   * 订阅事件
   */
  on(event: string, handler: EventHandler): void;
  
  /**
   * 取消订阅
   */
  off(event: string, handler: EventHandler): void;
  
  /**
   * 触发事件
   */
  emit(event: string, data?: any): void;
}
```

## 3. 内核实现

```typescript
class ChipsKernel implements Kernel {
  private pluginLoader: PluginLoader;
  private fileRecognizer: FileRecognizer;
  private dataProcessor: DataProcessor;
  private resourceManager: ResourceManager;
  private configManager: ConfigManager;
  private eventBus: EventBus;
  
  constructor() {
    this.eventBus = new EventBus();
    this.pluginLoader = new PluginLoader(this.eventBus);
    this.fileRecognizer = new FileRecognizer();
    this.dataProcessor = new DataProcessor();
    this.resourceManager = new ResourceManager();
    this.configManager = new ConfigManager();
  }
  
  // ===== 插件管理实现 =====
  
  async loadLayoutPlugin(layoutId: string): Promise<LayoutPlugin> {
    return await this.pluginLoader.loadPlugin('layout', layoutId);
  }
  
  async loadEditorPlugin(cardType: string): Promise<EditorPlugin> {
    // 根据卡片类型路由到对应的编辑组件插件
    const pluginId = this.routeToEditorPlugin(cardType);
    return await this.pluginLoader.loadPlugin('editor', pluginId);
  }
  
  async loadRendererPlugin(cardType: string): Promise<RendererPlugin> {
    // 根据卡片类型路由到对应的渲染器插件
    const pluginId = this.routeToRendererPlugin(cardType);
    return await this.pluginLoader.loadPlugin('renderer', pluginId);
  }
  
  private routeToEditorPlugin(cardType: string): string {
    // 路由映射
    const routeMap: Record<string, string> = {
      'rich-text': 'rich-text-editor',
      'markdown': 'markdown-editor',
      'image': 'image-editor',
      'video': 'video-editor',
      // ... 其他映射
    };
    
    return routeMap[cardType] || 'default-editor';
  }
  
  private routeToRendererPlugin(cardType: string): string {
    const routeMap: Record<string, string> = {
      'rich-text': 'rich-text-renderer',
      'markdown': 'markdown-renderer',
      'image': 'image-renderer',
      // ... 其他映射
    };
    
    return routeMap[cardType] || 'default-renderer';
  }
  
  // ===== 文件操作实现 =====
  
  async recognizeFile(filePath: string): Promise<FileType> {
    return await this.fileRecognizer.recognize(filePath);
  }
  
  async readCard(cardId: string): Promise<CardData> {
    const filePath = this.getCardFilePath(cardId);
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content);
  }
  
  async writeCard(cardId: string, data: CardData): Promise<void> {
    const filePath = this.getCardFilePath(cardId);
    const content = JSON.stringify(data, null, 2);
    await fs.writeFile(filePath, content, 'utf-8');
    
    // 触发事件
    this.emit('card:saved', { cardId, data });
  }
  
  // ===== 基础卡片操作实现 =====
  
  async getBaseCard(cardId: string, baseCardId: string): Promise<BaseCardData> {
    const card = await this.readCard(cardId);
    const baseCard = card.baseCards.find(bc => bc.id === baseCardId);
    
    if (!baseCard) {
      throw new Error(`Base card not found: ${baseCardId}`);
    }
    
    return baseCard;
  }
  
  async updateBaseCard(cardId: string, baseCardId: string, data: any): Promise<void> {
    const card = await this.readCard(cardId);
    const baseCard = card.baseCards.find(bc => bc.id === baseCardId);
    
    if (!baseCard) {
      throw new Error(`Base card not found: ${baseCardId}`);
    }
    
    // 更新数据
    baseCard.data = data;
    baseCard.updatedAt = Date.now();
    
    // 保存
    await this.writeCard(cardId, card);
    
    // 触发事件
    this.emit('base-card:updated', { cardId, baseCardId, data });
  }
  
  async addBaseCard(
    cardId: string,
    cardType: string,
    data: any,
    index?: number
  ): Promise<BaseCardData> {
    const card = await this.readCard(cardId);
    
    const baseCard: BaseCardData = {
      id: generateId(),
      type: cardType,
      data,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    
    // 插入到指定位置
    if (index !== undefined && index >= 0 && index <= card.baseCards.length) {
      card.baseCards.splice(index, 0, baseCard);
    } else {
      card.baseCards.push(baseCard);
    }
    
    // 保存
    await this.writeCard(cardId, card);
    
    // 触发事件
    this.emit('base-card:added', { cardId, baseCard });
    
    return baseCard;
  }
  
  async deleteBaseCard(cardId: string, baseCardId: string): Promise<void> {
    const card = await this.readCard(cardId);
    const index = card.baseCards.findIndex(bc => bc.id === baseCardId);
    
    if (index === -1) {
      throw new Error(`Base card not found: ${baseCardId}`);
    }
    
    // 删除
    card.baseCards.splice(index, 1);
    
    // 保存
    await this.writeCard(cardId, card);
    
    // 触发事件
    this.emit('base-card:deleted', { cardId, baseCardId });
  }
  
  async reorderBaseCards(cardId: string, baseCardIds: string[]): Promise<void> {
    const card = await this.readCard(cardId);
    
    // 重新排序
    const newOrder: BaseCardData[] = [];
    for (const id of baseCardIds) {
      const baseCard = card.baseCards.find(bc => bc.id === id);
      if (baseCard) {
        newOrder.push(baseCard);
      }
    }
    
    card.baseCards = newOrder;
    
    // 保存
    await this.writeCard(cardId, card);
    
    // 触发事件
    this.emit('base-cards:reordered', { cardId, order: baseCardIds });
  }
  
  // ===== 渲染实现 =====
  
  async renderCard(cardId: string, container: HTMLElement, options?: RenderOptions): Promise<void> {
    const card = await this.readCard(cardId);
    
    // 清空容器
    container.innerHTML = '';
    
    // 渲染每个基础卡片
    for (const baseCard of card.baseCards) {
      const renderer = await this.loadRendererPlugin(baseCard.type);
      
      // 创建基础卡片容器
      const baseCardContainer = document.createElement('div');
      baseCardContainer.className = 'base-card-container';
      baseCardContainer.dataset.baseCardId = baseCard.id;
      
      // 渲染
      await renderer.render(baseCardContainer, baseCard.data, options);
      
      // 添加到容器
      container.appendChild(baseCardContainer);
    }
  }
  
  // ===== 资源管理实现 =====
  
  async uploadResource(file: File, targetPath?: string): Promise<string> {
    return await this.resourceManager.upload(file, targetPath);
  }
  
  getResourceURL(resourcePath: string): string {
    return this.resourceManager.getURL(resourcePath);
  }
  
  // ===== 配置实现 =====
  
  getConfig(key: string): any {
    return this.configManager.get(key);
  }
  
  setConfig(key: string, value: any): void {
    this.configManager.set(key, value);
  }
  
  // ===== 事件实现 =====
  
  on(event: string, handler: EventHandler): void {
    this.eventBus.on(event, handler);
  }
  
  off(event: string, handler: EventHandler): void {
    this.eventBus.off(event, handler);
  }
  
  emit(event: string, data?: any): void {
    this.eventBus.emit(event, data);
  }
  
  // ===== 辅助方法 =====
  
  private getCardFilePath(cardId: string): string {
    const basePath = this.configManager.get('basePath');
    return path.join(basePath, `${cardId}.card`);
  }
}
```

## 4. 编辑引擎使用内核

```typescript
class InfiniteCanvasLayout implements LayoutPlugin {
  private kernel: Kernel;
  private context: LayoutContext;
  
  init(context: LayoutContext): void {
    this.context = context;
    this.kernel = context.kernel; // 从上下文获取内核实例
    
    // 订阅内核事件
    this.kernel.on('card:saved', this.onCardSaved);
    this.kernel.on('base-card:updated', this.onBaseCardUpdated);
  }
  
  async createCardFromCardboxItem(cardboxItem: any, position: Position): Promise<void> {
    // 1. 创建新卡片文件
    const card: CardData = {
      id: generateId(),
      name: 'New Card',
      baseCards: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    
    // 2. 添加基础卡片
    await this.kernel.addBaseCard(card.id, cardboxItem.cardType, {});
    
    // 3. 创建窗口显示卡片
    const window = this.windowManager.createWindow({
      type: WindowType.CARD,
      fileId: card.id,
      position,
    });
    
    // 4. 渲染卡片内容
    const windowElement = this.getWindowElement(window.id);
    const contentContainer = windowElement.querySelector('.window-content')!;
    await this.kernel.renderCard(card.id, contentContainer as HTMLElement);
  }
  
  private onCardSaved = (event: any) => {
    console.log('Card saved:', event.cardId);
    // 可能需要重新渲染
  };
  
  private onBaseCardUpdated = (event: any) => {
    console.log('Base card updated:', event.cardId, event.baseCardId);
    // 实时更新显示
    this.refreshBaseCardDisplay(event.cardId, event.baseCardId);
  };
  
  private async refreshBaseCardDisplay(cardId: string, baseCardId: string): Promise<void> {
    // 找到对应的 DOM 元素
    const element = document.querySelector(
      `[data-window-card-id="${cardId}"] [data-base-card-id="${baseCardId}"]`
    );
    
    if (element) {
      // 重新渲染
      const baseCard = await this.kernel.getBaseCard(cardId, baseCardId);
      const renderer = await this.kernel.loadRendererPlugin(baseCard.type);
      await renderer.render(element as HTMLElement, baseCard.data);
    }
  }
}
```

## 5. 插件使用内核

```typescript
class RichTextEditorPlugin implements EditorPlugin {
  private kernel: Kernel;
  private cardId: string;
  private baseCardId: string;
  
  async mount(container: HTMLElement, data: any, context: any): Promise<void> {
    this.kernel = context.kernel;
    this.cardId = context.cardId;
    this.baseCardId = context.baseCardId;
    
    // ... 初始化编辑器
    
    // 监听内核事件
    this.kernel.on('card:theme-changed', this.onThemeChanged);
  }
  
  async saveData(): Promise<void> {
    const data = this.getData();
    
    // 通过内核保存数据
    await this.kernel.updateBaseCard(this.cardId, this.baseCardId, data);
  }
  
  async uploadImage(file: File): Promise<string> {
    // 通过内核上传资源
    const resourcePath = await this.kernel.uploadResource(file, 'images/');
    return this.kernel.getResourceURL(resourcePath);
  }
  
  private onThemeChanged = (event: any) => {
    // 应用新主题
    this.applyTheme(event.theme);
  };
}
```

## 6. 数据结构

```typescript
interface CardData {
  id: string;
  name: string;
  baseCards: BaseCardData[];
  theme?: string;
  cover?: string;
  tags?: string[];
  metadata?: Record<string, any>;
  createdAt: number;
  updatedAt: number;
}

interface BaseCardData {
  id: string;
  type: string;
  data: any;
  theme?: string;
  createdAt: number;
  updatedAt: number;
}

interface BoxData {
  id: string;
  name: string;
  layout: string;
  cards: string[];
  metadata?: Record<string, any>;
  createdAt: number;
  updatedAt: number;
}
```

## 7. 错误处理

```typescript
class ChipsKernel {
  async loadEditorPlugin(cardType: string): Promise<EditorPlugin> {
    try {
      const pluginId = this.routeToEditorPlugin(cardType);
      return await this.pluginLoader.loadPlugin('editor', pluginId);
    } catch (error) {
      console.error(`Failed to load editor plugin for ${cardType}:`, error);
      
      // 回退到默认编辑器
      return await this.pluginLoader.loadPlugin('editor', 'default-editor');
    }
  }
  
  async readCard(cardId: string): Promise<CardData> {
    try {
      const filePath = this.getCardFilePath(cardId);
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`Card file not found: ${cardId}`);
      } else if (error instanceof SyntaxError) {
        throw new Error(`Invalid card file format: ${cardId}`);
      }
      throw error;
    }
  }
}
```

## 8. 总结

与内核交互的设计要点:

1. **统一接口**: 内核提供统一的API供编辑引擎和插件使用
2. **路由调度**: 内核负责将操作路由到正确的插件
3. **数据管理**: 内核处理所有文件和数据操作
4. **事件通信**: 通过事件实现模块间解耦通信
5. **错误处理**: 完善的错误处理和回退机制
6. **资源管理**: 统一的资源上传和访问

通过内核,编辑引擎和插件系统实现了清晰的职责分离和灵活的扩展能力。
