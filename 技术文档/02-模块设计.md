# 卡片编辑引擎 - 模块设计

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 模块概述

### 1.1 模块架构

编辑引擎采用模块化架构，每个模块负责特定的功能领域。所有模块通过薯片SDK与微内核通信，使用薯片组件库构建界面。

```
编辑引擎模块架构
├── 核心模块 (Core Modules)
│   ├── LayoutManager        布局管理器
│   ├── WindowManager        窗口管理器
│   ├── FileManager          文件管理器
│   ├── DragDropHandler      拖拽处理器
│   ├── SaveManager          保存管理器
│   ├── CommandManager       命令管理器
│   └── EventBus             事件总线
│
├── 服务模块 (Service Modules)
│   ├── CardService          卡片服务
│   ├── BoxService           箱子服务
│   ├── ResourceService      资源服务
│   ├── PluginService        插件服务
│   └── ConfigService        配置服务
│
├── 界面模块 (UI Modules) - 使用薯片组件库
│   ├── CardWindow           卡片窗口
│   ├── CoverWindow          封面窗口
│   ├── FileManager          文件管理器
│   ├── EditPanel            编辑面板
│   ├── CardBox              卡箱库
│   ├── Dock                 程序坞
│   └── ZoomControl          缩放控制器
│
└── 工具模块 (Utility Modules)
    ├── CoordinateSystem     坐标系统
    ├── ValidationUtils      验证工具
    ├── DebounceUtils        防抖节流
    └── IDGenerator          ID生成器
```

### 1.2 模块通信规则

**强制规则** ⭐:
- ✅ 所有模块间通信通过微内核路由
- ✅ 所有对公共基础层的调用通过微内核
- ✅ 所有对插件的调用通过微内核
- ❌ 禁止模块之间直接导入和调用

**通信方式**:
- 请求/响应：通过 `Core.request()`
- 事件通知：通过 `Core.event.publish/subscribe()`

---

## 2. 核心模块详细设计

### 2.1 布局管理器 (LayoutManager)

#### 2.1.1 职责

- 管理布局插件的生命周期
- 处理布局切换
- 维护布局状态
- 提供布局API给其他模块

#### 2.1.2 接口定义

```typescript
export class LayoutManager {
  private core: Core;
  private currentLayout: LayoutPlugin | null = null;
  private currentLayoutId: string = '';
  private layoutCache: Map<string, LayoutPlugin> = new Map();
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 初始化布局管理器
   */
  async initialize(): Promise<void> {
    // 1. 通过微内核读取默认布局配置
    const config = await this.core.request({
      service: "config.get",
      payload: { key: "editor.default_layout" }
    });
    
    const defaultLayoutId = config.value || 'infinite-canvas';
    
    // 2. 加载默认布局
    await this.loadLayout(defaultLayoutId);
  }
  
  /**
   * 加载布局插件（通过微内核）
   */
  async loadLayout(layoutId: string): Promise<LayoutPlugin> {
    // 检查缓存
    if (this.layoutCache.has(layoutId)) {
      return this.layoutCache.get(layoutId)!;
    }
    
    // 通过微内核加载插件
    const response = await this.core.request({
      service: "plugin.load",
      payload: { 
        pluginId: layoutId,
        pluginType: "layout"
      }
    });
    
    const layout = response.plugin as LayoutPlugin;
    
    // 缓存布局
    this.layoutCache.set(layoutId, layout);
    
    return layout;
  }
  
  /**
   * 切换布局
   */
  async switchLayout(newLayoutId: string): Promise<void> {
    // 详见架构设计文档中的实现
    // ... (实现代码)
  }
  
  /**
   * 卸载布局（通过微内核）
   */
  async unloadLayout(layoutId: string): Promise<void> {
    await this.core.request({
      service: "plugin.unload",
      payload: { pluginId: layoutId }
    });
    
    this.layoutCache.delete(layoutId);
  }
  
  /**
   * 获取已安装布局列表（通过微内核）
   */
  async getInstalledLayouts(): Promise<LayoutInfo[]> {
    const response = await this.core.request({
      service: "plugin.list",
      payload: { filter: { type: "layout" } }
    });
    
    return response.plugins;
  }
  
  /**
   * 获取当前布局
   */
  getCurrentLayout(): LayoutPlugin | null {
    return this.currentLayout;
  }
  
  /**
   * 获取当前布局ID
   */
  getCurrentLayoutId(): string {
    return this.currentLayoutId;
  }
}
```

#### 2.1.3 状态管理

```typescript
// 布局状态（Pinia Store）
interface LayoutState {
  // 无限画布状态
  infiniteCanvas: {
    scale: number;
    translateX: number;
    translateY: number;
    gridSize: number;
    snapToGrid: boolean;
  };
  
  // 工作台布局状态
  workbench: {
    leftWidth: number;
    rightWidth: number;
    bottomHeight: number;
    leftCollapsed: boolean;
    rightCollapsed: boolean;
    bottomCollapsed: boolean;
  };
  
  // 当前布局
  currentLayoutId: string;
}
```

---

### 2.2 窗口管理器 (WindowManager)

#### 2.2.1 职责

- 创建、关闭、聚焦窗口
- 维护窗口堆叠顺序
- 管理窗口状态和位置
- 处理窗口事件

#### 2.2.2 数据结构

```typescript
/**
 * 窗口数据结构
 */
export interface Window {
  // === 基本信息 ===
  id: string;                      // 窗口唯一ID
  type: WindowType;                // 窗口类型
  fileId?: string;                 // 关联的文件ID
  
  // === 位置和大小 ===
  position: Position;              // 位置（世界坐标或屏幕坐标）
  size: Size;                      // 尺寸
  
  // === 状态 ===
  state: WindowState;              // 显示状态
  zIndex: number;                  // 层级
  layer: WindowLayer;              // 所在层（desktop/window）
  
  // === 时间戳 ===
  createdAt: number;               // 创建时间
  updatedAt: number;               // 更新时间
  
  // === 数据 ===
  data?: any;                      // 窗口关联的数据
}

export enum WindowType {
  CARD = 'card',                   // 卡片窗口
  COVER = 'cover',                 // 封面窗口
  BOX = 'box',                     // 箱子窗口
  TOOL = 'tool'                    // 工具窗口
}

export enum WindowState {
  EXPANDED = 'expanded',           // 展开
  COLLAPSED = 'collapsed',         // 收起
  COVER = 'cover',                 // 封面
  MINIMIZED = 'minimized'          // 最小化
}

export enum WindowLayer {
  DESKTOP = 'desktop',             // 桌面层
  WINDOW = 'window'                // 窗口层
}

export interface Position {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}
```

#### 2.2.3 核心方法

```typescript
export class WindowManager {
  private core: Core;
  private windows: Map<string, Window> = new Map();
  private zIndexOrder: string[] = [];
  private focusedWindowId: string | null = null;
  private readonly BASE_Z_INDEX = 1000;
  private readonly MIN_WINDOW_WIDTH = 400;
  private readonly MIN_WINDOW_HEIGHT = 300;
  
  constructor(core: Core) {
    this.core = core;
    this.initEventListeners();
  }
  
  /**
   * 创建窗口（详细实现见架构设计文档）
   */
  async createWindow(
    fileId: string,
    options?: WindowOptions
  ): Promise<Window> {
    // 实现...
  }
  
  /**
   * 关闭窗口
   */
  async closeWindow(windowId: string): Promise<void> {
    // 实现...
  }
  
  /**
   * 聚焦窗口
   */
  async focusWindow(windowId: string): Promise<void> {
    // 实现...
  }
  
  /**
   * 移动窗口
   */
  async moveWindow(windowId: string, position: Position): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    window.position = position;
    window.updatedAt = Date.now();
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.window.moved",
      payload: { windowId, position }
    });
    
    // 防抖保存
    this.debouncedSaveWindowState(windowId);
  }
  
  /**
   * 调整窗口大小
   */
  async resizeWindow(windowId: string, size: Size): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 应用最小尺寸限制
    size.width = Math.max(size.width, this.MIN_WINDOW_WIDTH);
    size.height = Math.max(size.height, this.MIN_WINDOW_HEIGHT);
    
    window.size = size;
    window.updatedAt = Date.now();
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.window.resized",
      payload: { windowId, size }
    });
    
    // 防抖保存
    this.debouncedSaveWindowState(windowId);
  }
  
  /**
   * 切换窗口状态
   */
  async setWindowState(windowId: string, state: WindowState): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    window.state = state;
    window.updatedAt = Date.now();
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.window.state-changed",
      payload: { windowId, state }
    });
    
    // 立即保存状态变化
    await this.saveWindowState(windowId);
  }
  
  /**
   * 获取所有窗口
   */
  getWindows(filter?: WindowFilter): Window[] {
    const windows = Array.from(this.windows.values());
    
    if (!filter) return windows;
    
    return windows.filter(w => {
      if (filter.type && w.type !== filter.type) return false;
      if (filter.layer && w.layer !== filter.layer) return false;
      if (filter.state && w.state !== filter.state) return false;
      return true;
    });
  }
  
  /**
   * 获取焦点窗口
   */
  getFocusedWindow(): Window | null {
    if (!this.focusedWindowId) return null;
    return this.windows.get(this.focusedWindowId) || null;
  }
  
  /**
   * 提升窗口到最前
   */
  private bringToFront(windowId: string): void {
    // 实现见架构设计文档
  }
  
  /**
   * 重新分配z-index
   */
  private reassignZIndexes(): void {
    // 实现见架构设计文档
  }
  
  /**
   * 保存窗口状态（通过微内核）
   */
  private async saveWindowState(windowId: string): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    await this.core.request({
      service: "config.set",
      payload: {
        key: `window.${windowId}.state`,
        value: {
          position: window.position,
          size: window.size,
          state: window.state,
          zIndex: window.zIndex
        },
        scope: "user"
      }
    });
  }
  
  /**
   * 恢复窗口状态（通过微内核）
   */
  private async restoreWindowState(windowId: string): Promise<Partial<Window> | null> {
    const response = await this.core.request({
      service: "config.get",
      payload: { key: `window.${windowId}.state` }
    });
    
    return response.value || null;
  }
  
  /**
   * 初始化事件监听
   */
  private initEventListeners(): void {
    // 订阅文件删除事件，关闭相关窗口
    this.core.event.subscribe("file.deleted", async (event) => {
      const fileId = event.payload.fileId;
      
      // 查找关联窗口
      for (const [windowId, window] of this.windows) {
        if (window.fileId === fileId) {
          await this.closeWindow(windowId);
        }
      }
    });
  }
  
  /**
   * 防抖保存
   */
  private debouncedSaveWindowState = debounce((windowId: string) => {
    this.saveWindowState(windowId);
  }, 300);
}
```

---

### 2.3 文件管理器 (FileManager)

#### 2.3.1 职责

- 管理卡片和箱子文件
- 提供文件CRUD操作
- 文件搜索和过滤
- 监听文件系统变化

#### 2.3.2 接口定义

```typescript
export class FileManager {
  private core: Core;
  private filesCache: Map<string, File> = new Map();
  private watchers: Map<string, FileWatcher> = new Map();
  
  constructor(core: Core) {
    this.core = core;
    this.initFileWatcher();
  }
  
  /**
   * 初始化文件监听器（通过微内核）
   */
  private initFileWatcher(): void {
    // 订阅文件系统事件
    this.core.event.subscribe("file.created", (event) => {
      this.handleFileCreated(event.payload);
    });
    
    this.core.event.subscribe("file.modified", (event) => {
      this.handleFileModified(event.payload);
    });
    
    this.core.event.subscribe("file.deleted", (event) => {
      this.handleFileDeleted(event.payload);
    });
  }
  
  /**
   * 获取文件列表（通过微内核）
   */
  async getFiles(options?: FileListOptions): Promise<File[]> {
    const response = await this.core.request({
      service: "file.list",
      payload: {
        path: options?.path,
        recursive: options?.recursive ?? false,
        filter: options?.filter
      }
    });
    
    // 更新缓存
    for (const file of response.files) {
      this.filesCache.set(file.id, file);
    }
    
    return response.files;
  }
  
  /**
   * 搜索文件（通过微内核）
   */
  async searchFiles(query: string, options?: SearchOptions): Promise<File[]> {
    const response = await this.core.request({
      service: "file.search",
      payload: {
        query,
        searchContent: options?.searchContent ?? false,
        searchTags: options?.searchTags ?? true,
        limit: options?.limit || 50
      }
    });
    
    return response.files;
  }
  
  /**
   * 按标签查询文件（通过微内核）
   */
  async queryByTags(tags: string[]): Promise<File[]> {
    const response = await this.core.request({
      service: "tag.query",
      payload: {
        tags,
        targetType: "card",
        operator: "and"
      }
    });
    
    return response.results;
  }
  
  /**
   * 导入文件（通过微内核）
   */
  async importFile(sourcePath: string): Promise<File> {
    // 1. 识别文件类型
    const identifyResponse = await this.core.request({
      service: "file.identify",
      payload: { filePath: sourcePath }
    });
    
    const fileType = identifyResponse.fileType;
    
    // 2. 根据类型导入
    let response;
    
    if (fileType === 'card') {
      // 直接导入卡片文件
      response = await this.core.request({
        service: "card.import",
        payload: { 
          sourcePath,
          targetPath: this.getImportPath()
        }
      });
    } else {
      // 从文件创建卡片
      response = await this.core.request({
        service: "card.create-from-file",
        payload: {
          filePath: sourcePath,
          fileType,
          extractResources: true
        }
      });
    }
    
    const file: File = {
      id: response.cardId,
      name: response.name,
      type: 'card',
      path: response.filePath,
      createdAt: Date.now()
    };
    
    // 更新缓存
    this.filesCache.set(file.id, file);
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.file.imported",
      payload: { file }
    });
    
    return file;
  }
  
  /**
   * 批量导入文件（通过微内核批量请求）
   */
  async importFiles(filePaths: string[]): Promise<File[]> {
    const results: File[] = [];
    
    // 并发导入（微内核支持并发请求）
    const promises = filePaths.map(path => this.importFile(path));
    const files = await Promise.all(promises);
    
    return files;
  }
  
  /**
   * 导出文件（通过微内核）
   */
  async exportFile(
    fileId: string,
    targetPath: string,
    format: ExportFormat,
    options?: ExportOptions
  ): Promise<void> {
    await this.core.request({
      service: "card.export",
      payload: {
        cardId: fileId,
        exportPath: targetPath,
        format,
        mode: options?.mode || 'full',
        includeNested: options?.includeNested ?? true
      }
    });
    
    // 显示成功提示
    Message.success(t('message.export_success'));
  }
  
  /**
   * 获取工作空间路径
   */
  private getWorkspacePath(): string {
    // 通过微内核获取
    // ...
  }
  
  /**
   * 获取导入路径
   */
  private getImportPath(): string {
    // 通过微内核获取
    // ...
  }
  
  /**
   * 处理文件创建事件
   */
  private handleFileCreated(payload: any): void {
    const file = payload.file;
    this.filesCache.set(file.id, file);
    
    // 通知界面更新
    // （通过Pinia Store响应式更新）
  }
  
  /**
   * 处理文件修改事件
   */
  private handleFileModified(payload: any): void {
    const fileId = payload.fileId;
    
    // 检测冲突
    if (this.hasUnsavedChanges(fileId)) {
      this.showConflictDialog(fileId);
    } else {
      // 重新加载文件
      this.reloadFile(fileId);
    }
  }
  
  /**
   * 处理文件删除事件
   */
  private handleFileDeleted(payload: any): void {
    const fileId = payload.fileId;
    this.filesCache.delete(fileId);
  }
}
```

---

### 2.4 拖拽处理器 (DragDropHandler)

#### 2.4.1 职责

- 统一处理所有拖拽操作
- 集成基础层的拖拽系统
- 判断拖拽场景和目标
- 执行拖拽操作（通过微内核）

#### 2.4.2 拖拽场景枚举

```typescript
export enum DragScenario {
  FROM_CARDBOX = 'from-cardbox',           // 从卡箱库拖动
  FROM_FILE_SYSTEM = 'from-file-system',   // 从文件系统拖入
  CARD_TO_CARD = 'card-to-card',           // 卡片间拖拽
  REORDER_ITEMS = 'reorder-items',         // 调整顺序
  MOVE_WINDOW = 'move-window',             // 移动窗口
  RESIZE_WINDOW = 'resize-window',         // 调整窗口大小
  PAN_DESKTOP = 'pan-desktop',             // 平移桌面
  ZOOM_SLIDER = 'zoom-slider',             // 拖动缩放滑块
}

export enum DragSourceType {
  CARDBOX_ITEM = 'cardbox-item',
  FILE_SYSTEM = 'file-system',
  CARD_WINDOW = 'card-window',
  BASE_CARD = 'base-card',
  WINDOW_TITLEBAR = 'window-titlebar',
  WINDOW_RESIZE = 'window-resize',
  DESKTOP = 'desktop',
}

export enum DropTargetType {
  DESKTOP_EMPTY = 'desktop-empty',
  CARD_WINDOW = 'card-window',
  BOX_WINDOW = 'box-window',
  EDIT_PANEL = 'edit-panel',
}
```

#### 2.4.3 拖拽处理器实现

```typescript
export class DragDropHandler {
  private core: Core;
  private windowManager: WindowManager;
  private fileManager: FileManager;
  
  constructor(
    core: Core,
    windowManager: WindowManager,
    fileManager: FileManager
  ) {
    this.core = core;
    this.windowManager = windowManager;
    this.fileManager = fileManager;
  }
  
  /**
   * 初始化拖拽系统（通过微内核调用基础层）
   */
  async initialize(): Promise<void> {
    // 1. 初始化基础层拖拽系统
    await this.core.request({
      service: "foundation.drag-drop.init",
      payload: {}
    });
    
    // 2. 注册所有拖拽源和目标
    await this.registerDragSources();
    await this.registerDropTargets();
    
    // 3. 订阅拖拽事件
    this.subscribeToEvents();
  }
  
  /**
   * 注册拖拽源（通过微内核）
   */
  private async registerDragSources(): Promise<void> {
    // 注册卡箱库拖拽源
    await this.core.request({
      service: "foundation.drag-drop.register-source",
      payload: {
        sourceId: "cardbox-items",
        type: DragSourceType.CARDBOX_ITEM,
        elements: document.querySelectorAll('.cardbox-item'),
        getData: (element: HTMLElement) => ({
          cardType: element.dataset.cardType
        }),
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd
      }
    });
    
    // 注册窗口标题栏拖拽源
    await this.core.request({
      service: "foundation.drag-drop.register-source",
      payload: {
        sourceId: "window-titlebars",
        type: DragSourceType.WINDOW_TITLEBAR,
        elements: document.querySelectorAll('.card-menubar'),
        getData: (element: HTMLElement) => ({
          windowId: element.dataset.windowId
        }),
        onDragStart: this.handleWindowDragStart,
        onDragEnd: this.handleWindowDragEnd
      }
    });
    
    // 注册基础卡片拖拽源（重排序）
    await this.core.request({
      service: "foundation.drag-drop.register-source",
      payload: {
        sourceId: "base-cards",
        type: DragSourceType.BASE_CARD,
        elements: document.querySelectorAll('.base-card-wrapper'),
        getData: (element: HTMLElement) => ({
          cardId: element.dataset.cardId,
          baseCardId: element.dataset.baseCardId
        }),
        onDragStart: this.handleBaseCardDragStart,
        onDragEnd: this.handleBaseCardDragEnd
      }
    });
  }
  
  /**
   * 注册放置目标（通过微内核）
   */
  private async registerDropTargets(): Promise<void> {
    // 注册桌面空白区域放置目标
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId: "desktop-canvas",
        type: DropTargetType.DESKTOP_EMPTY,
        element: document.getElementById('desktop-content'),
        accepts: [
          DragSourceType.CARDBOX_ITEM,
          DragSourceType.FILE_SYSTEM
        ],
        onDragOver: this.handleDesktopDragOver,
        onDrop: this.handleDesktopDrop
      }
    });
    
    // 注册卡片窗口放置目标
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId: "card-windows",
        type: DropTargetType.CARD_WINDOW,
        elements: document.querySelectorAll('.chips-card-window'),
        accepts: [
          DragSourceType.CARDBOX_ITEM,
          DragSourceType.FILE_SYSTEM,
          DragSourceType.CARD_WINDOW,
          DragSourceType.BASE_CARD
        ],
        onDragOver: this.handleCardWindowDragOver,
        onDrop: this.handleCardWindowDrop
      }
    });
    
    // 注册编辑面板放置目标
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId: "edit-panel",
        type: DropTargetType.EDIT_PANEL,
        element: document.getElementById('edit-panel'),
        accepts: [DragSourceType.FILE_SYSTEM],
        onDrop: this.handleEditPanelDrop
      }
    });
  }
  
  /**
   * 处理桌面放置事件
   */
  private handleDesktopDrop = async (event: DropEvent): Promise<void> => {
    const { sourceType, data, position } = event;
    
    if (sourceType === DragSourceType.CARDBOX_ITEM) {
      await this.createCardFromCardBox(data.cardType, position);
    } else if (sourceType === DragSourceType.FILE_SYSTEM) {
      await this.createCardFromFiles(data.files, position);
    }
  };
  
  /**
   * 从卡箱库创建卡片（通过微内核）
   */
  private async createCardFromCardBox(
    cardType: string,
    position: Position
  ): Promise<void> {
    // 1. 创建卡片
    const createResponse = await this.core.request({
      service: "card.create",
      payload: { name: t('card.untitled') }
    });
    
    const cardId = createResponse.cardId;
    
    // 2. 添加基础卡片
    await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId,
        baseCardType: cardType,
        config: {},
        position: 0
      }
    });
    
    // 3. 创建窗口
    await this.windowManager.createWindow(cardId, { position });
  }
  
  /**
   * 从文件创建卡片（通过微内核）
   */
  private async createCardFromFiles(
    files: FileList | File[],
    position: Position
  ): Promise<void> {
    const fileArray = Array.from(files);
    
    if (fileArray.length === 1) {
      // 单个文件
      await this.createSingleCardFromFile(fileArray[0], position);
    } else {
      // 多个文件 - 创建包含多个基础卡片的卡片
      await this.createCardFromMultipleFiles(fileArray, position);
    }
  }
  
  /**
   * 从单个文件创建卡片
   */
  private async createSingleCardFromFile(
    file: File,
    position: Position
  ): Promise<void> {
    // 1. 识别文件类型
    const identifyResponse = await this.core.request({
      service: "file.identify",
      payload: { filePath: file.path }
    });
    
    // 2. 创建卡片
    const createResponse = await this.core.request({
      service: "card.create-from-file",
      payload: {
        filePath: file.path,
        fileType: identifyResponse.fileType
      }
    });
    
    // 3. 创建窗口
    await this.windowManager.createWindow(createResponse.cardId, { position });
  }
  
  /**
   * 处理卡片窗口放置事件
   */
  private handleCardWindowDrop = async (event: DropEvent): Promise<void> => {
    const { sourceType, data, targetId, insertPosition } = event;
    
    if (sourceType === DragSourceType.CARDBOX_ITEM) {
      // 从卡箱库拖动到卡片窗口 - 添加基础卡片
      await this.core.request({
        service: "card.add_base_card",
        payload: {
          cardId: targetId,
          baseCardType: data.cardType,
          config: {},
          position: insertPosition
        }
      });
      
    } else if (sourceType === DragSourceType.FILE_SYSTEM) {
      // 从文件系统拖入卡片窗口 - 从文件添加基础卡片
      await this.core.request({
        service: "card.add-from-file",
        payload: {
          cardId: targetId,
          filePath: data.files[0].path,
          position: insertPosition
        }
      });
      
    } else if (sourceType === DragSourceType.CARD_WINDOW) {
      // 卡片拖到卡片 - 嵌套
      await this.core.request({
        service: "card.nest",
        payload: {
          sourceCardId: data.windowId,
          targetCardId: targetId,
          position: insertPosition,
          mode: event.modifierKeys.ctrl ? 'copy' : 'move'
        }
      });
    } else if (sourceType === DragSourceType.BASE_CARD) {
      // 基础卡片拖动 - 调整顺序
      await this.core.request({
        service: "card.reorder",
        payload: {
          cardId: data.cardId,
          baseCardId: data.baseCardId,
          newPosition: insertPosition
        }
      });
    }
  };
}
```

---

### 2.5 保存管理器 (SaveManager)

#### 2.5.1 职责

- 管理自动保存机制
- 实现防抖动保存
- 处理保存队列
- 检测和处理文件冲突

#### 2.5.2 实现

```typescript
export class SaveManager {
  private core: Core;
  private dirtyFiles: Map<string, DirtyData> = new Map();
  private savingFiles: Set<string> = new Set();
  
  // 防抖延迟配置
  private readonly DEBOUNCE_DELAYS = {
    TEXT_INPUT: 500,
    WINDOW_MOVE: 300,
    WINDOW_RESIZE: 300,
    CARD_EDIT: 1000,
    METADATA_EDIT: 500,
  };
  
  constructor(core: Core) {
    this.core = core;
    this.initAutoSave();
  }
  
  /**
   * 标记数据为脏
   */
  markDirty(
    fileId: string,
    dataType: DataType,
    data: any
  ): void {
    // 保存到脏数据Map
    this.dirtyFiles.set(fileId, {
      fileId,
      dataType,
      data,
      markedAt: Date.now()
    });
    
    // 触发防抖保存
    const delay = this.DEBOUNCE_DELAYS[dataType] || 1000;
    const saveFunction = debounce(
      () => this.saveNow(fileId),
      delay
    );
    
    saveFunction();
  }
  
  /**
   * 立即保存（通过微内核）
   */
  async saveNow(fileId: string): Promise<void> {
    // 检查是否正在保存
    if (this.savingFiles.has(fileId)) {
      console.log('Already saving, skip');
      return;
    }
    
    // 获取脏数据
    const dirtyData = this.dirtyFiles.get(fileId);
    if (!dirtyData) return;
    
    try {
      // 标记为正在保存
      this.savingFiles.add(fileId);
      
      // 检测冲突
      const hasConflict = await this.detectConflict(fileId);
      if (hasConflict) {
        await this.handleConflict(fileId, dirtyData.data);
        return;
      }
      
      // 通过微内核保存
      await this.core.request({
        service: "card.update",
        payload: {
          cardId: fileId,
          updates: dirtyData.data
        }
      });
      
      // 清除脏标记
      this.dirtyFiles.delete(fileId);
      
      // 发布保存成功事件
      await this.core.event.publish({
        eventType: "editor.file.saved",
        payload: { fileId }
      });
      
    } catch (error) {
      // 记录错误（通过微内核）
      await this.core.request({
        service: "foundation.log.write",
        payload: {
          level: "error",
          message: "Failed to save file",
          context: { fileId, error }
        }
      });
      
      // 显示错误提示
      Message.error(t('message.save_failed'));
      
    } finally {
      // 取消正在保存标记
      this.savingFiles.delete(fileId);
    }
  }
  
  /**
   * 保存所有脏数据
   */
  async saveAll(): Promise<void> {
    const fileIds = Array.from(this.dirtyFiles.keys());
    
    // 并发保存
    const promises = fileIds.map(fileId => this.saveNow(fileId));
    await Promise.all(promises);
  }
  
  /**
   * 检测文件冲突（通过微内核）
   */
  private async detectConflict(fileId: string): Promise<boolean> {
    const response = await this.core.request({
      service: "file.check-modified",
      payload: { fileId }
    });
    
    return response.modified;
  }
  
  /**
   * 处理文件冲突
   */
  private async handleConflict(fileId: string, data: any): Promise<void> {
    // 显示冲突对话框（使用Modal组件）
    Modal.confirm({
      title: t('conflict.title'),
      content: t('conflict.message'),
      okText: t('conflict.overwrite'),
      cancelText: t('conflict.reload'),
      onOk: async () => {
        // 覆盖外部修改
        await this.forceCardUpdate(fileId, data);
      },
      onCancel: async () => {
        // 重新加载文件
        await this.reloadFile(fileId);
      }
    });
  }
  
  /**
   * 强制保存（覆盖冲突）
   */
  private async forceCardUpdate(fileId: string, data: any): Promise<void> {
    await this.core.request({
      service: "card.update",
      payload: {
        cardId: fileId,
        updates: data,
        force: true
      }
    });
  }
  
  /**
   * 重新加载文件
   */
  private async reloadFile(fileId: string): Promise<void> {
    // 通过微内核重新读取
    const response = await this.core.request({
      service: "card.read",
      payload: { cardId: fileId }
    });
    
    // 发布文件重新加载事件
    await this.core.event.publish({
      eventType: "editor.file.reloaded",
      payload: { fileId, data: response.card }
    });
    
    // 清除脏标记
    this.dirtyFiles.delete(fileId);
  }
  
  /**
   * 初始化自动保存
   */
  private initAutoSave(): void {
    // 订阅数据修改事件
    this.core.event.subscribe("editor.data.modified", (event) => {
      const { fileId, dataType, data } = event.payload;
      this.markDirty(fileId, dataType, data);
    });
    
    // 应用退出前保存所有
    window.addEventListener('beforeunload', async (e) => {
      if (this.dirtyFiles.size > 0) {
        e.preventDefault();
        e.returnValue = '';
        
        // 保存所有
        await this.saveAll();
      }
    });
  }
}

interface DirtyData {
  fileId: string;
  dataType: DataType;
  data: any;
  markedAt: number;
}

enum DataType {
  TEXT_INPUT = 'text-input',
  WINDOW_MOVE = 'window-move',
  WINDOW_RESIZE = 'window-resize',
  CARD_EDIT = 'card-edit',
  METADATA_EDIT = 'metadata-edit',
}
```

---

### 2.6 命令管理器 (CommandManager)

#### 2.6.1 职责

- 实现撤销/重做功能
- 维护命令历史栈
- 提供命令执行接口

#### 2.6.2 命令接口

```typescript
export interface Command {
  /**
   * 执行命令
   */
  execute(): Promise<void>;
  
  /**
   * 撤销命令
   */
  undo(): Promise<void>;
  
  /**
   * 重做命令
   */
  redo(): Promise<void>;
  
  /**
   * 是否可撤销
   */
  canUndo(): boolean;
  
  /**
   * 是否可重做
   */
  canRedo(): boolean;
  
  /**
   * 命令描述
   */
  getDescription(): string;
}
```

#### 2.6.3 具体命令实现

```typescript
/**
 * 添加基础卡片命令
 */
export class AddBaseCardCommand implements Command {
  private core: Core;
  private cardId: string;
  private baseCardType: string;
  private position: number;
  private baseCardId?: string;
  
  constructor(
    core: Core,
    cardId: string,
    baseCardType: string,
    position: number
  ) {
    this.core = core;
    this.cardId = cardId;
    this.baseCardType = baseCardType;
    this.position = position;
  }
  
  async execute(): Promise<void> {
    const response = await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId: this.cardId,
        baseCardType: this.baseCardType,
        config: {},
        position: this.position
      }
    });
    
    this.baseCardId = response.baseCardId;
  }
  
  async undo(): Promise<void> {
    await this.core.request({
      service: "card.remove_base_card",
      payload: {
        cardId: this.cardId,
        baseCardId: this.baseCardId!
      }
    });
  }
  
  async redo(): Promise<void> {
    await this.execute();
  }
  
  canUndo(): boolean {
    return this.baseCardId !== undefined;
  }
  
  canRedo(): boolean {
    return true;
  }
  
  getDescription(): string {
    return t('command.add_base_card', { type: this.baseCardType });
  }
}

/**
 * 删除基础卡片命令
 */
export class RemoveBaseCardCommand implements Command {
  private core: Core;
  private cardId: string;
  private baseCardId: string;
  private baseCardData: any;
  private position: number;
  
  constructor(
    core: Core,
    cardId: string,
    baseCardId: string
  ) {
    this.core = core;
    this.cardId = cardId;
    this.baseCardId = baseCardId;
  }
  
  async execute(): Promise<void> {
    // 1. 保存基础卡片数据（用于撤销）
    const cardResponse = await this.core.request({
      service: "card.read",
      payload: { cardId: this.cardId }
    });
    
    const baseCard = cardResponse.card.structure.find(
      bc => bc.id === this.baseCardId
    );
    
    this.position = cardResponse.card.structure.indexOf(baseCard);
    this.baseCardData = cardResponse.card.content[this.baseCardId];
    
    // 2. 删除基础卡片
    await this.core.request({
      service: "card.remove_base_card",
      payload: {
        cardId: this.cardId,
        baseCardId: this.baseCardId
      }
    });
  }
  
  async undo(): Promise<void> {
    // 重新添加基础卡片
    await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId: this.cardId,
        baseCardId: this.baseCardId,  // 使用原ID
        baseCardType: this.baseCardData.card_type,
        config: this.baseCardData,
        position: this.position
      }
    });
  }
  
  async redo(): Promise<void> {
    await this.core.request({
      service: "card.remove_base_card",
      payload: {
        cardId: this.cardId,
        baseCardId: this.baseCardId
      }
    });
  }
  
  canUndo(): boolean { return true; }
  canRedo(): boolean { return true; }
  
  getDescription(): string {
    return t('command.remove_base_card');
  }
}

/**
 * 重排序基础卡片命令
 */
export class ReorderBaseCardsCommand implements Command {
  private core: Core;
  private cardId: string;
  private oldOrder: string[];
  private newOrder: string[];
  
  constructor(
    core: Core,
    cardId: string,
    oldOrder: string[],
    newOrder: string[]
  ) {
    this.core = core;
    this.cardId = cardId;
    this.oldOrder = oldOrder;
    this.newOrder = newOrder;
  }
  
  async execute(): Promise<void> {
    await this.core.request({
      service: "card.reorder",
      payload: {
        cardId: this.cardId,
        order: this.newOrder
      }
    });
  }
  
  async undo(): Promise<void> {
    await this.core.request({
      service: "card.reorder",
      payload: {
        cardId: this.cardId,
        order: this.oldOrder
      }
    });
  }
  
  async redo(): Promise<void> {
    await this.execute();
  }
  
  canUndo(): boolean { return true; }
  canRedo(): boolean { return true; }
  
  getDescription(): string {
    return t('command.reorder_base_cards');
  }
}
```

---

### 2.7 事件总线 (EventBus)

#### 2.7.1 职责

- 编辑引擎内部的事件通信
- 连接微内核事件总线
- 提供事件订阅和发布接口

#### 2.7.2 实现

```typescript
export class EventBus {
  private core: Core;
  private localHandlers: Map<string, Set<EventHandler>> = new Map();
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 订阅本地事件
   */
  on(eventType: string, handler: EventHandler): void {
    if (!this.localHandlers.has(eventType)) {
      this.localHandlers.set(eventType, new Set());
    }
    
    this.localHandlers.get(eventType)!.add(handler);
  }
  
  /**
   * 取消订阅本地事件
   */
  off(eventType: string, handler: EventHandler): void {
    const handlers = this.localHandlers.get(eventType);
    if (handlers) {
      handlers.delete(handler);
    }
  }
  
  /**
   * 发布本地事件
   */
  async emit(eventType: string, payload?: any): Promise<void> {
    const handlers = this.localHandlers.get(eventType);
    
    if (handlers) {
      for (const handler of handlers) {
        try {
          await handler(payload);
        } catch (error) {
          console.error('Event handler error:', error);
        }
      }
    }
  }
  
  /**
   * 订阅微内核事件
   */
  subscribeKernel(eventType: string, handler: EventHandler): void {
    this.core.event.subscribe(eventType, handler);
  }
  
  /**
   * 发布微内核事件
   */
  async publishKernel(eventType: string, payload: any): Promise<void> {
    await this.core.event.publish({
      eventType,
      payload
    });
  }
}

type EventHandler = (payload: any) => void | Promise<void>;
```

---

## 3. 服务模块详细设计

服务模块封装对微内核的调用，提供类型安全的API。

### 3.1 卡片服务 (CardService)

```typescript
export class CardService {
  private core: Core;
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 读取卡片
   */
  async read(
    cardId: string,
    options?: ReadOptions
  ): Promise<Card> {
    const response = await this.core.request({
      service: "card.read",
      payload: {
        cardId,
        includeContent: options?.includeContent ?? true,
        includeResources: options?.includeResources ?? false
      }
    });
    
    return this.parseCardData(response.card);
  }
  
  /**
   * 创建卡片
   */
  async create(name: string, options?: CreateOptions): Promise<string> {
    const response = await this.core.request({
      service: "card.create",
      payload: {
        name,
        theme: options?.theme,
        tags: options?.tags,
        saveTo: options?.saveTo
      }
    });
    
    return response.cardId;
  }
  
  /**
   * 更新卡片
   */
  async update(
    cardId: string,
    updates: Partial<Card>
  ): Promise<void> {
    await this.core.request({
      service: "card.update",
      payload: { cardId, updates }
    });
  }
  
  /**
   * 删除卡片
   */
  async delete(
    cardId: string,
    permanent = false
  ): Promise<void> {
    await this.core.request({
      service: "card.delete",
      payload: { cardId, permanent }
    });
  }
  
  /**
   * 添加基础卡片
   */
  async addBaseCard(
    cardId: string,
    baseCardType: string,
    config: any,
    position?: number
  ): Promise<string> {
    const response = await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId,
        baseCardType,
        config,
        position
      }
    });
    
    return response.baseCardId;
  }
  
  /**
   * 移除基础卡片
   */
  async removeBaseCard(
    cardId: string,
    baseCardId: string
  ): Promise<void> {
    await this.core.request({
      service: "card.remove_base_card",
      payload: { cardId, baseCardId }
    });
  }
  
  /**
   * 重排序基础卡片
   */
  async reorder(
    cardId: string,
    baseCardId: string,
    newPosition: number
  ): Promise<void> {
    await this.core.request({
      service: "card.reorder",
      payload: {
        cardId,
        baseCardId,
        newPosition
      }
    });
  }
  
  /**
   * 从文件创建卡片
   */
  async createFromFile(
    filePath: string,
    fileType: string
  ): Promise<string> {
    const response = await this.core.request({
      service: "card.create-from-file",
      payload: { filePath, fileType }
    });
    
    return response.cardId;
  }
  
  /**
   * 导出卡片
   */
  async export(
    cardId: string,
    exportPath: string,
    format: ExportFormat,
    options?: ExportOptions
  ): Promise<void> {
    await this.core.request({
      service: "card.export",
      payload: {
        cardId,
        exportPath,
        format,
        mode: options?.mode || 'full',
        includeNested: options?.includeNested ?? true
      }
    });
  }
  
  /**
   * 解析卡片数据
   */
  private parseCardData(rawData: any): Card {
    return {
      id: rawData.id,
      metadata: rawData.metadata,
      structure: rawData.structure,
      content: rawData.content,
      cover: rawData.cover
    };
  }
}
```

---

### 3.1.1 数据同步机制

编辑器中存在两套管理卡片数据的系统：
- **CardStore (Pinia)**: 管理打开的卡片状态，包括元数据、结构、修改状态等
- **WorkspaceService**: 管理工作区文件列表，包括文件名、路径、创建时间等

为确保两套系统的数据一致性，需要建立同步机制。

**同步策略**:

1. **创建时同步**: 创建新卡片时，使用相同的 ID 在两个系统中创建记录
   ```typescript
   // App.vue 中的创建流程
   const cardId = generateId(); // 生成统一 ID
   
   // 1. 在 CardStore 中创建
   cardStore.addCard({ id: cardId, ... });
   
   // 2. 在 WorkspaceService 中创建（使用相同 ID）
   await workspaceService.createCard(name, content, cardId);
   ```

2. **更新时同步**: 当卡片名称更新时，同时更新两个系统
   ```typescript
   // CardWindow.vue 中的更新流程
   function updateTitle(title: string): void {
     // 1. 更新 CardStore
     cardStore.updateCardMetadata(cardId, { name: title });
     
     // 2. 同步更新 WorkspaceService
     workspaceService.renameFile(cardId, `${title}.card`);
   }
   ```

3. **删除时同步**: 删除卡片时，同时从两个系统中移除
   ```typescript
   function closeAndDelete(cardId: string): void {
     cardStore.removeCard(cardId);
     workspaceService.deleteFile(cardId);
   }
   ```

**统一 ID 设计**:
- 卡片 ID = 窗口配置中的 cardId = 工作区文件 ID
- 这确保了通过任一入口都能找到对应的数据

---

### 3.2 资源服务 (ResourceService)

```typescript
export class ResourceService {
  private core: Core;
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 获取资源（通过微内核）
   */
  async fetch(uri: string, options?: FetchOptions): Promise<Resource> {
    const response = await this.core.request({
      service: "resource.fetch",
      payload: {
        uri,
        cache: options?.cache ?? true,
        timeout: options?.timeout || 10000,
        authProfile: options?.authProfile
      }
    });
    
    return {
      uri: response.uri,
      contentType: response.contentType,
      size: response.size,
      data: response.data,
      metadata: response.metadata
    };
  }
  
  /**
   * 写入资源（通过微内核）
   */
  async write(
    uri: string,
    data: any,
    options?: WriteOptions
  ): Promise<void> {
    await this.core.request({
      service: "resource.write",
      payload: {
        uri,
        data,
        overwrite: options?.overwrite ?? false,
        createDirectories: options?.createDirectories ?? true
      }
    });
  }
  
  /**
   * 检查资源是否存在（通过微内核）
   */
  async exists(uri: string): Promise<boolean> {
    const response = await this.core.request({
      service: "resource.exists",
      payload: { uri }
    });
    
    return response.exists;
  }
  
  /**
   * 获取资源元信息（通过微内核）
   */
  async getMeta(uri: string): Promise<ResourceMeta> {
    const response = await this.core.request({
      service: "resource.meta",
      payload: { uri }
    });
    
    return response;
  }
  
  /**
   * 删除资源（通过微内核）
   */
  async delete(uri: string, permanent = false): Promise<void> {
    await this.core.request({
      service: "resource.delete",
      payload: { uri, permanent }
    });
  }
}
```

---

### 3.3 插件服务 (PluginService)

```typescript
export class PluginService {
  private core: Core;
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 加载插件（通过微内核）
   */
  async load(pluginId: string, pluginType?: string): Promise<any> {
    const response = await this.core.request({
      service: "plugin.load",
      payload: { pluginId, pluginType }
    });
    
    return response.plugin;
  }
  
  /**
   * 卸载插件（通过微内核）
   */
  async unload(pluginId: string): Promise<void> {
    await this.core.request({
      service: "plugin.unload",
      payload: { pluginId }
    });
  }
  
  /**
   * 列出插件（通过微内核）
   */
  async list(filter?: PluginFilter): Promise<PluginInfo[]> {
    const response = await this.core.request({
      service: "plugin.list",
      payload: { filter }
    });
    
    return response.plugins;
  }
  
  /**
   * 获取插件信息（通过微内核）
   */
  async getInfo(pluginId: string): Promise<PluginInfo> {
    const response = await this.core.request({
      service: "plugin.info",
      payload: { pluginId }
    });
    
    return response;
  }
  
  /**
   * 安装插件（通过微内核）
   */
  async install(source: string): Promise<string> {
    const response = await this.core.request({
      service: "plugin.install",
      payload: {
        source,
        autoEnable: true
      }
    });
    
    return response.pluginId;
  }
  
  /**
   * 卸载插件（通过微内核）
   */
  async uninstall(pluginId: string): Promise<void> {
    await this.core.request({
      service: "plugin.uninstall",
      payload: { pluginId }
    });
  }
  
  /**
   * 启用插件（通过微内核）
   */
  async enable(pluginId: string): Promise<void> {
    await this.core.request({
      service: "plugin.enable",
      payload: { pluginId }
    });
  }
  
  /**
   * 禁用插件（通过微内核）
   */
  async disable(pluginId: string): Promise<void> {
    await this.core.request({
      service: "plugin.disable",
      payload: { pluginId }
    });
  }
}
```

---

### 3.4 配置服务 (ConfigService)

```typescript
export class ConfigService {
  private core: Core;
  private configCache: Map<string, any> = new Map();
  
  constructor(core: Core) {
    this.core = core;
    this.subscribeToConfigChanges();
  }
  
  /**
   * 获取配置（通过微内核）
   */
  async get<T = any>(key: string, defaultValue?: T): Promise<T> {
    // 检查缓存
    if (this.configCache.has(key)) {
      return this.configCache.get(key);
    }
    
    // 通过微内核读取
    const response = await this.core.request({
      service: "config.get",
      payload: { key, scope: "user" }
    });
    
    const value = response.value ?? defaultValue;
    
    // 更新缓存
    this.configCache.set(key, value);
    
    return value;
  }
  
  /**
   * 设置配置（通过微内核）
   */
  async set(key: string, value: any): Promise<void> {
    await this.core.request({
      service: "config.set",
      payload: {
        key,
        value,
        scope: "user"
      }
    });
    
    // 更新缓存
    this.configCache.set(key, value);
  }
  
  /**
   * 删除配置（通过微内核）
   */
  async delete(key: string): Promise<void> {
    await this.core.request({
      service: "config.delete",
      payload: { key, scope: "user" }
    });
    
    // 从缓存移除
    this.configCache.delete(key);
  }
  
  /**
   * 列出配置（通过微内核）
   */
  async list(prefix?: string): Promise<ConfigItem[]> {
    const response = await this.core.request({
      service: "config.list",
      payload: {
        prefix,
        scope: "user"
      }
    });
    
    return response.configs;
  }
  
  /**
   * 订阅配置变化事件
   */
  private subscribeToConfigChanges(): void {
    this.core.event.subscribe("config.changed", (event) => {
      const { key, value } = event.payload;
      
      // 更新缓存
      this.configCache.set(key, value);
    });
  }
}
```

---

## 4. 工具模块详细设计

### 4.1 坐标系统 (CoordinateSystem)

#### 4.1.1 职责

- 屏幕坐标与世界坐标转换
- 处理缩放和平移变换
- 提供坐标计算工具

#### 4.1.2 实现

```typescript
export class CoordinateSystem {
  /**
   * 屏幕坐标转世界坐标
   */
  static screenToWorld(
    screenX: number,
    screenY: number,
    transform: Transform
  ): Position {
    const { scale, translateX, translateY } = transform;
    
    return {
      x: (screenX - translateX) / scale,
      y: (screenY - translateY) / scale
    };
  }
  
  /**
   * 世界坐标转屏幕坐标
   */
  static worldToScreen(
    worldX: number,
    worldY: number,
    transform: Transform
  ): Position {
    const { scale, translateX, translateY } = transform;
    
    return {
      x: worldX * scale + translateX,
      y: worldY * scale + translateY
    };
  }
  
  /**
   * 计算缩放变换
   */
  static calculateZoomTransform(
    currentTransform: Transform,
    newScale: number,
    centerX: number,
    centerY: number
  ): Transform {
    const { scale, translateX, translateY } = currentTransform;
    
    // 计算缩放中心在世界坐标中的位置
    const worldX = (centerX - translateX) / scale;
    const worldY = (centerY - translateY) / scale;
    
    // 计算新的平移
    const newTranslateX = centerX - worldX * newScale;
    const newTranslateY = centerY - worldY * newScale;
    
    return {
      scale: newScale,
      translateX: newTranslateX,
      translateY: newTranslateY
    };
  }
  
  /**
   * 计算适应视图的变换
   */
  static calculateFitTransform(
    bounds: Bounds,
    viewportSize: Size,
    padding: number = 50
  ): Transform {
    const contentWidth = bounds.right - bounds.left;
    const contentHeight = bounds.bottom - bounds.top;
    
    const availableWidth = viewportSize.width - padding * 2;
    const availableHeight = viewportSize.height - padding * 2;
    
    // 计算缩放比例（取最小的，确保内容完全可见）
    const scaleX = availableWidth / contentWidth;
    const scaleY = availableHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY, 1);  // 不超过100%
    
    // 计算平移（居中显示）
    const translateX = (viewportSize.width - contentWidth * scale) / 2 - bounds.left * scale;
    const translateY = (viewportSize.height - contentHeight * scale) / 2 - bounds.top * scale;
    
    return { scale, translateX, translateY };
  }
}

export interface Transform {
  scale: number;
  translateX: number;
  translateY: number;
}

export interface Bounds {
  left: number;
  top: number;
  right: number;
  bottom: number;
}
```

---

### 4.2 验证工具 (ValidationUtils)

```typescript
export class ValidationUtils {
  /**
   * 验证卡片ID格式
   */
  static validateCardId(cardId: string): boolean {
    // 10位62进制
    return /^[0-9a-zA-Z]{10}$/.test(cardId);
  }
  
  /**
   * 验证文件名
   */
  static validateFileName(fileName: string): ValidationResult {
    if (!fileName || fileName.trim() === '') {
      return {
        valid: false,
        error: t('validation.name_required')
      };
    }
    
    // 检查非法字符
    const illegalChars = /[<>:"/\\|?*]/;
    if (illegalChars.test(fileName)) {
      return {
        valid: false,
        error: t('validation.illegal_chars')
      };
    }
    
    // 检查长度
    if (fileName.length > 255) {
      return {
        valid: false,
        error: t('validation.name_too_long')
      };
    }
    
    return { valid: true };
  }
  
  /**
   * 验证坐标值
   */
  static validateCoordinates(position: Position): boolean {
    return (
      typeof position.x === 'number' &&
      typeof position.y === 'number' &&
      !isNaN(position.x) &&
      !isNaN(position.y)
    );
  }
  
  /**
   * 验证缩放比例
   */
  static validateScale(scale: number, min = 0.1, max = 5): number {
    return clamp(scale, min, max);
  }
}

interface ValidationResult {
  valid: boolean;
  error?: string;
}
```

---

### 4.3 ID生成器 (IDGenerator)

```typescript
export class IDGenerator {
  private core: Core;
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 生成ID（通过微内核）
   */
  async generate(type: 'card' | 'box' | 'base_card'): Promise<string> {
    const response = await this.core.request({
      service: "id.generate",
      payload: { type, count: 1 }
    });
    
    return response.ids[0];
  }
  
  /**
   * 批量生成ID（通过微内核）
   */
  async generateBatch(
    type: 'card' | 'box' | 'base_card',
    count: number
  ): Promise<string[]> {
    const response = await this.core.request({
      service: "id.generate",
      payload: { type, count }
    });
    
    return response.ids;
  }
  
  /**
   * 验证ID（通过微内核）
   */
  async validate(id: string): Promise<boolean> {
    const response = await this.core.request({
      service: "id.validate",
      payload: { id }
    });
    
    return response.valid;
  }
  
  /**
   * 本地生成临时ID（不通过微内核）
   */
  generateLocal(): string {
    // 用于临时窗口ID等，不需要全局唯一
    return `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

---

## 5. 界面模块详细设计

界面模块完全使用薯片组件库构建，遵循功能与样式分离原则。

### 5.1 文件管理器组件 (FileManager.vue)

```vue
<!-- components/FileManager.vue -->
<template>
  <div class="file-manager">
    <!-- 头部工具栏 -->
    <div class="file-manager-header">
      <Input 
        v-model="searchQuery"
        :placeholder="t('file_manager.search')"
        @input="handleSearch"
      >
        <template #prefix>
          <SearchIcon />
        </template>
      </Input>
      
      <Button 
        type="primary"
        @click="handleCreate"
      >
        {{ t('file_manager.create') }}
      </Button>
    </div>
    
    <!-- 视图切换 -->
    <div class="view-switcher">
      <Radio.Group v-model="viewType">
        <Radio.Button value="tree">
          <TreeIcon />
        </Radio.Button>
        <Radio.Button value="list">
          <ListIcon />
        </Radio.Button>
        <Radio.Button value="grid">
          <GridIcon />
        </Radio.Button>
      </Radio.Group>
      
      <Select 
        v-model="sortBy"
        :options="sortOptions"
      />
    </div>
    
    <!-- 文件列表 -->
    <div class="file-list">
      <!-- 树状视图 -->
      <Tree 
        v-if="viewType === 'tree'"
        :data="fileTree"
        :expanded-keys="expandedKeys"
        :selected-keys="selectedKeys"
        draggable
        @select="handleFileSelect"
        @drop="handleFileDrop"
      >
        <template #title="{ node }">
          <div class="file-node">
            <Icon :type="node.icon" />
            <span>{{ node.name }}</span>
            <Badge v-if="node.unsaved" dot />
          </div>
        </template>
      </Tree>
      
      <!-- 列表视图 -->
      <List 
        v-else-if="viewType === 'list'"
        :data-source="filteredFiles"
        @click="handleFileSelect"
      >
        <template #renderItem="{ item }">
          <ListItem>
            <ListItemMeta 
              :title="item.name"
              :description="formatDate(item.modifiedAt)"
            >
              <template #avatar>
                <Avatar :icon="item.icon" />
              </template>
            </ListItemMeta>
            <template #actions>
              <Button 
                type="text"
                @click.stop="handleFileRename(item.id)"
              >
                <EditIcon />
              </Button>
              <Button 
                type="text"
                danger
                @click.stop="handleFileDelete(item.id)"
              >
                <DeleteIcon />
              </Button>
            </template>
          </ListItem>
        </template>
      </List>
      
      <!-- 网格视图 -->
      <Grid v-else-if="viewType === 'grid'" :gutter="[16, 16]">
        <GridItem 
          v-for="file in filteredFiles"
          :key="file.id"
          :span="6"
        >
          <Card 
            :hoverable="true"
            @click="handleFileSelect(file.id)"
          >
            <template #cover>
              <img :src="file.coverUrl || defaultCover" />
            </template>
            <CardMeta :title="file.name" />
          </Card>
        </GridItem>
      </Grid>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useFilesStore } from '@/stores/files';
import { useEditorStore } from '@/stores/editor';
import {
  Input,
  Button,
  Radio,
  Select,
  Tree,
  List,
  ListItem,
  ListItemMeta,
  Grid,
  GridItem,
  Card,
  CardMeta,
  Avatar,
  Badge,
  Icon
} from '@chips/components';

const filesStore = useFilesStore();
const editorStore = useEditorStore();

const searchQuery = ref('');
const viewType = ref('tree');
const sortBy = ref('modified-desc');

const filteredFiles = computed(() => {
  let files = filesStore.files;
  
  // 搜索过滤
  if (searchQuery.value) {
    files = files.filter(f =>
      f.name.toLowerCase().includes(searchQuery.value.toLowerCase())
    );
  }
  
  // 排序
  files = sortFiles(files, sortBy.value);
  
  return files;
});

const handleSearch = debounce(async (query: string) => {
  if (query) {
    // 通过微内核搜索
    const results = await editorStore.fileManager!.searchFiles(query);
    filesStore.setFiles(results);
  } else {
    // 重新加载所有文件
    await filesStore.loadFiles();
  }
}, 300);

const handleFileSelect = async (fileId: string) => {
  // 通过微内核读取并打开文件
  await editorStore.windowManager!.createWindow(fileId);
};

const handleFileDelete = async (fileId: string) => {
  // 显示确认对话框
  Modal.confirm({
    title: t('dialog.delete_confirm_title'),
    content: t('dialog.delete_confirm_content', { name: file.name }),
    onOk: async () => {
      await editorStore.fileManager!.deleteFile(fileId);
      await filesStore.loadFiles();
    }
  });
};
</script>
```

---

### 5.2 编辑面板组件 (EditPanel.vue)

```vue
<!-- components/EditPanel.vue -->
<template>
  <div class="edit-panel">
    <!-- 头部 -->
    <div class="edit-panel-header">
      <span class="panel-title">
        {{ currentBaseCardType ? t(`card_type.${currentBaseCardType}`) : t('edit_panel.title') }}
      </span>
      
      <Button 
        type="text"
        @click="handleClose"
      >
        <CloseIcon />
      </Button>
    </div>
    
    <!-- 插件容器 -->
    <div 
      id="edit-plugin-container"
      class="edit-panel-content"
    >
      <!-- 插件组件挂载到这里 -->
      <Empty v-if="!currentPlugin" :description="t('edit_panel.no_selection')" />
    </div>
    
    <!-- 底部工具栏（可选） -->
    <div v-if="showFooter" class="edit-panel-footer">
      <Button @click="handleReset">
        {{ t('common.reset') }}
      </Button>
      <Button 
        type="primary"
        @click="handleSave"
      >
        {{ t('common.save') }}
      </Button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { useEditorStore } from '@/stores/editor';
import { Button, Empty } from '@chips/components';

const editorStore = useEditorStore();

const currentPlugin = ref<any>(null);
const currentBaseCardType = ref<string>('');
const showFooter = ref(false);

// 监听编辑面板加载事件
editorStore.core!.event.subscribe(
  "editor.edit-panel.load",
  async (event) => {
    const { cardId, baseCardId } = event.payload;
    await loadEditorPlugin(cardId, baseCardId);
  }
);

/**
 * 加载编辑组件插件（通过微内核）
 */
async function loadEditorPlugin(
  cardId: string,
  baseCardId: string
): Promise<void> {
  // 1. 读取基础卡片数据
  const cardResponse = await editorStore.core!.request({
    service: "card.read",
    payload: { cardId }
  });
  
  const baseCard = cardResponse.card.structure.find(
    bc => bc.id === baseCardId
  );
  
  if (!baseCard) return;
  
  currentBaseCardType.value = baseCard.type;
  
  // 2. 通过微内核加载编辑组件插件
  const pluginResponse = await editorStore.core!.request({
    service: "plugin.load",
    payload: {
      pluginType: "editor",
      cardType: baseCard.type
    }
  });
  
  currentPlugin.value = pluginResponse.plugin;
  
  // 3. 挂载插件到容器
  const container = document.getElementById('edit-plugin-container');
  await currentPlugin.value.mount(container, {
    cardId,
    baseCardId,
    data: cardResponse.card.content[baseCardId],
    api: createEditorAPI(cardId, baseCardId)
  });
}

/**
 * 创建编辑器API（提供给插件）
 */
function createEditorAPI(cardId: string, baseCardId: string): EditorAPI {
  return {
    // 更新数据
    updateData: async (newData: any) => {
      await editorStore.core!.request({
        service: "card.update-base-card",
        payload: {
          cardId,
          baseCardId,
          data: newData
        }
      });
      
      // 标记为脏，触发自动保存
      editorStore.saveManager!.markDirty(cardId, 'card-edit', {
        content: { [baseCardId]: newData }
      });
    },
    
    // 获取资源
    getResource: async (path: string) => {
      return await editorStore.resourceService!.fetch(
        `card://${cardId}/${path}`
      );
    },
    
    // 上传资源
    uploadResource: async (file: File) => {
      const uri = `card://${cardId}/${file.name}`;
      await editorStore.resourceService!.write(uri, file);
      return uri;
    },
    
    // 显示通知
    notify: (message: string, type = 'info') => {
      Message[type](message);
    },
    
    // 调用微内核
    callKernel: async (service: string, payload: any) => {
      return await editorStore.core!.request({ service, payload });
    }
  };
}

const handleClose = async () => {
  if (currentPlugin.value) {
    await currentPlugin.value.unmount();
    currentPlugin.value = null;
    currentBaseCardType.value = '';
  }
};

const handleSave = async () => {
  // 手动触发保存
  await editorStore.saveManager!.saveNow(currentCardId.value);
  Message.success(t('message.save_success'));
};

const handleReset = async () => {
  // 重置到上次保存状态
  await editorStore.core!.request({
    service: "editor.edit-panel.reset",
    payload: { cardId: currentCardId.value, baseCardId: currentBaseCardId.value }
  });
};
</script>
```

---

### 5.3 卡箱库组件 (CardBox.vue)

```vue
<!-- components/CardBox.vue -->
<template>
  <div class="cardbox">
    <!-- 头部搜索 -->
    <div class="cardbox-header">
      <Input 
        v-model="searchQuery"
        :placeholder="t('cardbox.search')"
        @input="handleSearch"
      >
        <template #prefix>
          <SearchIcon />
        </template>
      </Input>
    </div>
    
    <!-- 分类标签 -->
    <Tabs v-model:activeKey="activeCategory">
      <TabPane 
        v-for="category in categories"
        :key="category.id"
        :tab="t(`cardbox.category.${category.id}`)"
      >
        <!-- 卡片类型网格 -->
        <Grid :gutter="[16, 16]">
          <GridItem 
            v-for="cardType in getCategoryItems(category.id)"
            :key="cardType.id"
            :span="8"
          >
            <Card 
              class="cardbox-item"
              :data-card-type="cardType.id"
              :hoverable="true"
              @dblclick="handleQuickCreate(cardType.id)"
            >
              <template #cover>
                <div class="cardbox-icon">
                  <Icon :type="cardType.icon" :size="48" />
                </div>
              </template>
              
              <CardMeta 
                :title="t(`card_type.${cardType.id}`)"
                :description="t(`card_type.${cardType.id}_desc`)"
              />
            </Card>
          </GridItem>
        </Grid>
      </TabPane>
    </Tabs>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useEditorStore } from '@/stores/editor';
import {
  Input,
  Tabs,
  TabPane,
  Grid,
  GridItem,
  Card,
  CardMeta,
  Icon
} from '@chips/components';

const editorStore = useEditorStore();

const searchQuery = ref('');
const activeCategory = ref('text');
const cardTypes = ref<CardType[]>([]);

// 分类定义
const categories = [
  { id: 'text', name: '文本类' },
  { id: 'media', name: '媒体类' },
  { id: 'data', name: '数据类' },
  { id: 'chart', name: '图表类' },
  { id: 'creative', name: '创意类' },
  { id: 'content', name: '内容类' },
  { id: 'info', name: '信息类' },
];

onMounted(async () => {
  // 通过微内核获取所有卡片类型
  const response = await editorStore.core!.request({
    service: "plugin.list",
    payload: { filter: { type: "base_card" } }
  });
  
  cardTypes.value = response.plugins.map(p => ({
    id: p.id,
    name: p.name,
    category: p.metadata.category,
    icon: p.metadata.icon
  }));
  
  // 初始化拖拽（通过基础层）
  await editorStore.dragDropHandler!.registerDragSources();
});

const getCategoryItems = (categoryId: string) => {
  return cardTypes.value.filter(ct => ct.category === categoryId);
};

const handleQuickCreate = async (cardType: string) => {
  // 双击快速创建（在屏幕中心）
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  
  // 转换为世界坐标
  const layoutStore = useLayoutStore();
  const worldPos = CoordinateSystem.screenToWorld(
    centerX,
    centerY,
    layoutStore.$state
  );
  
  // 通过微内核创建卡片
  const response = await editorStore.core!.request({
    service: "card.create",
    payload: { name: t('card.untitled') }
  });
  
  await editorStore.core!.request({
    service: "card.add_base_card",
    payload: {
      cardId: response.cardId,
      baseCardType: cardType,
      config: {}
    }
  });
  
  // 创建窗口
  await editorStore.windowManager!.createWindow(response.cardId, {
    position: worldPos
  });
};
</script>
```

---

## 6. 数据流设计

### 6.1 读取卡片完整流程

```typescript
/**
 * 用户打开卡片的完整数据流
 */
async function openCard(cardId: string): Promise<void> {
  // 1. 用户点击文件（Vue组件）
  // FileManager.vue: @click="handleFileSelect(fileId)"
  
  // 2. 组件调用Store的Action
  // 在Store Action中调用WindowManager
  await windowManager.createWindow(cardId);
  
  // 3. WindowManager通过微内核读取文件
  const response = await core.request({
    service: "card.read",
    payload: { cardId, includeContent: true }
  });
  
  // 4. 微内核路由到文件系统模块
  // 文件系统模块使用基础层的ZIPProcessor读取ZIP
  
  // 5. 返回卡片数据
  const cardData = response.card;
  
  // 6. WindowManager为每个基础卡片加载渲染器
  for (const baseCard of cardData.structure) {
    // 通过微内核加载渲染器插件
    await core.request({
      service: "plugin.load",
      payload: {
        pluginType: "renderer",
        cardType: baseCard.type
      }
    });
  }
  
  // 7. 创建窗口组件
  const window = createWindowComponent(cardData);
  
  // 8. 渲染基础卡片
  for (const baseCard of cardData.structure) {
    const CardComponent = getCardComponent(baseCard.type);
    // CardComponent内部通过微内核调用基础层组件渲染
    // 例如：VideoCard调用foundation.video-player
    renderBaseCard(CardComponent, baseCard);
  }
  
  // 9. 显示窗口
  addWindowToDOM(window);
  
  // 10. 更新Store状态
  windowsStore.addWindow(window);
  
  // 11. Vue响应式更新界面
  // 用户看到打开的卡片
}
```

---

### 6.2 编辑并保存流程

```typescript
/**
 * 用户编辑卡片并自动保存的完整数据流
 */
async function editAndSave(cardId: string, baseCardId: string): Promise<void> {
  // 1. 用户点击基础卡片（Vue组件）
  // CardWindow.vue: @click="handleBaseCardClick(baseCardId)"
  
  // 2. 组件通过微内核加载编辑组件
  const pluginResponse = await core.request({
    service: "plugin.load",
    payload: {
      pluginType: "editor",
      cardType: baseCardType
    }
  });
  
  // 3. 微内核返回编辑组件插件
  const editorPlugin = pluginResponse.plugin;
  
  // 4. 挂载编辑组件到编辑面板
  await editorPlugin.mount(container, {
    data: baseCardData,
    api: editorAPI
  });
  
  // 5. 用户在编辑组件中修改数据
  // 编辑组件内部使用基础层的TextEditor等
  
  // 6. 编辑组件调用API通知数据变化
  editorAPI.updateData(newData);
  
  // 7. API内部通过微内核更新数据
  await core.request({
    service: "card.update-base-card",
    payload: { cardId, baseCardId, data: newData }
  });
  
  // 8. 标记为脏数据，触发自动保存
  saveManager.markDirty(cardId, 'card-edit', {
    content: { [baseCardId]: newData }
  });
  
  // 9. 防抖延迟（1s）后执行保存
  // 防抖期满，调用saveNow()
  
  // 10. saveNow通过微内核保存文件
  await core.request({
    service: "card.update",
    payload: { cardId, updates: dirtyData.data }
  });
  
  // 11. 微内核路由到文件系统模块
  // 文件系统模块使用基础层的ZIPProcessor写入ZIP
  
  // 12. 保存成功，清除脏标记
  dirtyFiles.delete(cardId);
  
  // 13. 发布保存事件
  await core.event.publish({
    eventType: "editor.file.saved",
    payload: { cardId }
  });
  
  // 14. 渲染器订阅事件，更新显示
  // 基础卡片实时更新显示
  // 用户看到最新内容
}
```

---

## 7. 性能优化设计

### 7.1 渲染性能优化

**视口裁剪实现**:
```typescript
export class CanvasRenderer {
  private core: Core;
  private layoutStore = useLayoutStore();
  private throttledUpdate = throttle(() => this.updateVisibility(), 100);
  
  /**
   * 更新窗口可见性（视口裁剪）
   */
  updateVisibility(): void {
    const viewportBounds = this.calculateViewportBounds();
    
    for (const window of this.windows.values()) {
      const isVisible = this.isWindowInViewport(window, viewportBounds);
      
      // 更新DOM
      const element = document.getElementById(`window-${window.id}`);
      if (element) {
        element.style.display = isVisible ? '' : 'none';
      }
    }
  }
  
  /**
   * 计算视口边界
   */
  private calculateViewportBounds(): Bounds {
    const { scale, translateX, translateY } = this.layoutStore;
    
    const topLeft = CoordinateSystem.screenToWorld(
      0, 0,
      { scale, translateX, translateY }
    );
    
    const bottomRight = CoordinateSystem.screenToWorld(
      window.innerWidth,
      window.innerHeight,
      { scale, translateX, translateY }
    );
    
    // 添加缓冲区
    const buffer = 200;
    
    return {
      left: topLeft.x - buffer,
      top: topLeft.y - buffer,
      right: bottomRight.x + buffer,
      bottom: bottomRight.y + buffer
    };
  }
  
  /**
   * 判断窗口是否在视口内
   */
  private isWindowInViewport(window: Window, viewport: Bounds): boolean {
    const { position, size } = window;
    
    return !(
      position.x + size.width < viewport.left ||
      position.x > viewport.right ||
      position.y + size.height < viewport.top ||
      position.y > viewport.bottom
    );
  }
}
```

---

### 7.2 请求优化

**批量请求**:
```typescript
/**
 * 批量加载卡片（通过微内核批量请求）
 */
async function loadMultipleCards(cardIds: string[]): Promise<Card[]> {
  // 使用微内核的批量请求
  const response = await core.request({
    service: "batch.request",
    payload: {
      requests: cardIds.map(cardId => ({
        service: "card.read",
        payload: { cardId }
      })),
      strategy: "parallel"
    }
  });
  
  return response.responses.map(r => r.data.card);
}
```

**请求缓存**:
```typescript
/**
 * 带缓存的资源获取
 */
async function fetchResourceCached(uri: string): Promise<Resource> {
  // 通过微内核的缓存管理器
  const cacheResponse = await core.request({
    service: "foundation.cache-manager.get",
    payload: { key: uri }
  });
  
  if (cacheResponse.cached) {
    return cacheResponse.data;
  }
  
  // 获取资源
  const resource = await resourceService.fetch(uri);
  
  // 缓存资源
  await core.request({
    service: "foundation.cache-manager.set",
    payload: {
      key: uri,
      value: resource,
      ttl: 3600
    }
  });
  
  return resource;
}
```

---

## 7.5 引擎设置系统

### 7.5.1 系统概述

引擎设置系统提供编辑引擎级别的全局设置管理。采用「注册中心」架构，使得设置分类可以无限扩展，新增分类无需修改核心代码。

**设计原则**：
- **完全解耦**：Store 和 Dialog 不知道具体有哪些设置分类
- **自治模块**：每个设置分类包含自己的数据 schema、默认值、面板组件和副作用处理器
- **声明式注册**：所有面板定义集中在注册中心，一目了然
- **零硬编码**：所有文本使用 `t()` 函数，遵循多语言规范

### 7.5.2 核心类型

```typescript
/**
 * 面板定义 —— 注册中心的基本单元
 */
interface SettingsPanelDefinition<T = unknown> {
  /** 分类元数据（菜单显示用） */
  category: SettingsCategory;
  /** 面板 Vue 组件 */
  component: Component;
  /** 默认设置数据 */
  defaultData: T;
  /** 数据变更时的副作用处理器 */
  onChange?: (newData: T, oldData: T) => void | Promise<void>;
}

interface SettingsCategory {
  id: string;           // 分类唯一标识
  labelKey: string;     // 多语言 key
  icon?: string;        // 菜单图标
  order: number;        // 排序权重（越小越靠前）
  group?: string;       // 菜单分组（不同 group 之间显示分隔线）
}
```

### 7.5.3 注册中心（settings-registry.ts）

```typescript
// 所有内置面板定义集中声明
export const builtinPanelDefinitions: SettingsPanelDefinition[] = [
  languagePanel,   // 语言与文字（order: 100, group: 'appearance'）
  themePanel,      // 主题设置  （order: 200, group: 'appearance'）
  layoutPanel,     // 引擎模式  （order: 300, group: 'engine'）
  toolsPanel,      // 工具管理  （order: 400, group: 'engine'）
  fileModePanel,   // 文件管理  （order: 500, group: 'engine'）
  aboutPanel,      // 关于      （order: 900, group: 'system'）
];
```

**扩展步骤**：
1. 创建面板组件 `XxxPanel.vue`
2. 在 `settings-registry.ts` 中追加一条 `SettingsPanelDefinition`
3. 完成。菜单自动出现，数据自动管理。

### 7.5.4 Settings Store

通用的设置数据容器，不包含任何具体分类的业务逻辑：

```typescript
const useSettingsStore = defineStore('settings', {
  state: () => ({
    panelRegistry: {},    // categoryId -> SettingsPanelDefinition
    settingsData: {},     // categoryId -> 该分类的数据
    initialized: false,
  }),

  actions: {
    registerPanel(definition),    // 注册面板（自动初始化默认数据）
    registerPanels(definitions),  // 批量注册
    getData<T>(categoryId),       // 获取分类数据
    updateData<T>(categoryId, updates),  // 部分更新（自动触发 onChange）
    setData<T>(categoryId, data),        // 完整替换
    resetCategory(categoryId),    // 重置到默认值
    exportAll(),                  // 导出所有（持久化用）
    importAll(data),              // 导入恢复
  },
});
```

**关键机制**：`updateData` 内部自动调用对应面板定义的 `onChange` 处理器，实现副作用与数据变更的自动绑定。

### 7.5.5 Settings Service

各设置分类的 `onChange` 处理器定义在此模块，负责协调 SDK/Foundation 层交互：

| 处理器 | 职责 |
|--------|------|
| `handleLanguageChange` | 调用 `EditorStore.setLocale()`，更新 CSS 变量 `--chips-font-size-base` 和 `--chips-content-scale` |
| `handleThemeChange` | 调用 `SDK.ThemeManager.setTheme()`，同步 `UIStore.setTheme()`，管理系统主题监听器 |
| `handleLayoutChange` | 调用 `EditorStore.setLayout()` |
| `handleFileModeChange` | 通知文件管理系统切换模式（待接入） |

### 7.5.6 UI 组件

#### EngineSettingsDialog

全屏模态弹窗，`Teleport` 到 `body`，z-index 高于所有工具窗口和卡片窗口。

- 左侧菜单栏：从 `settingsStore.groupedCategories` 动态生成，支持分组分隔线
- 右侧面板：通过 `<component :is="settingsStore.getPanelComponent(activeCategoryId)" />` 动态渲染
- 底部：重置当前分类按钮 + 关闭按钮
- 支持 Escape 键和遮罩点击关闭

#### Dock 设置入口

程序坞（Dock）组件末尾增加固定的齿轮图标按钮（⚙️），与工具窗口图标通过分隔线分隔。点击后通过事件链传递到 `App.vue` 打开设置弹窗。

### 7.5.7 内置设置面板

| 面板 | 分类 ID | 功能 | 依赖 SDK 能力 |
|------|---------|------|--------------|
| LanguageSettingsPanel | `language` | 语言选择、字号调整（12-24px）、内容缩放比例（50%-200%） | `SDK.I18nManager` |
| ThemeSettingsPanel | `theme` | 主题包选择（网格预览，日间/夜间是独立主题包）、跟随系统自动切换亮暗主题包、安装入口 | `SDK.ThemeManager` |
| LayoutSettingsPanel | `layout` | 引擎模式切换（当前仅无限画布，预留工作台） | `EditorStore` |
| ToolsSettingsPanel | `tools` | 已安装工具列表、启用/禁用、安装入口 | `SDK.PluginManager` |
| FileModeSettingsPanel | `fileMode` | 链接模式 / 复制模式选择 | `ConfigManager` |
| AboutPanel | `about` | 版本号、协议版本、开源协议、技术栈 | 静态数据 |

### 7.5.8 数据流

```
用户点击 Dock ⚙️ 按钮
  ↓ emit('open-settings')
WindowLayer → InfiniteCanvas → App.vue
  ↓ showEngineSettings = true
EngineSettingsDialog 显示
  ↓ 用户修改设置
settingsStore.updateData(categoryId, updates)
  ↓ 自动触发 onChange
Settings Service 处理器
  ↓ 调用 SDK / EditorStore
SDK.ThemeManager / I18nManager / EditorStore
  ↓ 状态更新
Vue 响应式更新界面
```

---

## 8. 模块集成总结

### 8.1 模块依赖关系

```
LayoutManager ──┐
WindowManager ──┤
FileManager ────┼──> Core (薯片SDK) ──> 微内核 ──> 公共基础层
DragDropHandler─┤                               └─> 插件系统
SaveManager ────┤
CommandManager ─┘

Vue组件 ──> Pinia Store ──> 核心模块 ──> Core (薯片SDK)

所有界面 ──> 薯片组件库 ──> ThemeProvider ──> 主题包
```

### 8.2 核心设计原则

1. **所有模块通过微内核通信** - 绝对遵循中心路由原则
2. **服务层封装微内核调用** - 提供类型安全的API
3. **Vue组件使用薯片组件库** - 功能与样式分离
4. **基础功能调用基础层** - 通过微内核路由
5. **插件独立加载** - 通过微内核管理

### 8.3 数据流总结

```
用户操作
  ↓
Vue组件（@chips/components）
  ↓
Pinia Store
  ↓
核心模块（LayoutManager、WindowManager等）
  ↓
服务层（CardService、ResourceService等）
  ↓
薯片SDK（@chips/sdk）
  ↓
微内核路由
  ↓
公共基础层/插件系统
  ↓
执行操作（文件读写、媒体播放、渲染等）
  ↓
返回结果
  ↓
通过事件或响应返回
  ↓
更新Store状态
  ↓
Vue响应式更新界面
  ↓
用户看到结果
```

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-31  
**状态**: ✅ 生效
