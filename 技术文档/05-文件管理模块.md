# 卡片编辑引擎 - 文件管理模块

## 1. 文件管理模块概述

### 1.1 职责

- 文件系统操作(创建、读取、更新、删除)
- 文件索引和缓存
- 文件搜索和筛选
- 文件监听和同步
- 导入导出功能

### 1.2 文件类型

- `.card` 文件: 复合卡片
- `.box` 文件: 箱子
- 媒体文件: 图片、视频、音频等
- 其他文件: 由插件处理

## 2. 文件数据结构

```typescript
interface File {
  id: string;                    // 唯一标识符
  name: string;                  // 文件名
  type: FileType;                // 文件类型
  path: string;                  // 文件路径
  size: number;                  // 文件大小(字节)
  createdAt: number;             // 创建时间
  updatedAt: number;             // 修改时间
  tags?: string[];               // 标签
  metadata?: Record<string, any>; // 元数据
}

enum FileType {
  CARD = 'card',
  BOX = 'box',
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio',
  DOCUMENT = 'document',
  OTHER = 'other',
}
```

## 3. 文件管理器实现

```typescript
class FileManager {
  private files: Map<string, File> = new Map();
  private basePath: string;
  private eventBus: EventBus;
  private watcher: FSWatcher | null = null;
  
  constructor(basePath: string, eventBus: EventBus) {
    this.basePath = basePath;
    this.eventBus = eventBus;
  }
  
  async init(): Promise<void> {
    // 扫描文件
    await this.scanFiles();
    
    // 启动文件监听
    this.startWatching();
  }
  
  // ===== 文件操作 =====
  
  async createFile(type: FileType, name: string, data?: any): Promise<File> {
    const file: File = {
      id: generateId(),
      name: this.ensureUniqueName(name),
      type,
      path: path.join(this.basePath, this.ensureUniqueName(name)),
      size: 0,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    
    // 创建文件
    await this.writeFile(file, data || {});
    
    // 添加到索引
    this.files.set(file.id, file);
    
    // 触发事件
    this.eventBus.emit('file:created', file);
    
    return file;
  }
  
  async readFile(fileId: string): Promise<any> {
    const file = this.files.get(fileId);
    if (!file) throw new Error(`File not found: ${fileId}`);
    
    const content = await fs.readFile(file.path, 'utf-8');
    return JSON.parse(content);
  }
  
  async updateFile(fileId: string, data: any): Promise<void> {
    const file = this.files.get(fileId);
    if (!file) throw new Error(`File not found: ${fileId}`);
    
    await this.writeFile(file, data);
    
    file.updatedAt = Date.now();
    
    this.eventBus.emit('file:updated', file);
  }
  
  async deleteFile(fileId: string): Promise<void> {
    const file = this.files.get(fileId);
    if (!file) return;
    
    // 移动到回收站或直接删除
    await trash(file.path);
    
    // 从索引删除
    this.files.delete(fileId);
    
    this.eventBus.emit('file:deleted', file);
  }
  
  async renameFile(fileId: string, newName: string): Promise<void> {
    const file = this.files.get(fileId);
    if (!file) throw new Error(`File not found: ${fileId}`);
    
    const newPath = path.join(this.basePath, newName);
    await fs.rename(file.path, newPath);
    
    file.name = newName;
    file.path = newPath;
    file.updatedAt = Date.now();
    
    this.eventBus.emit('file:renamed', file);
  }
  
  // ===== 文件查询 =====
  
  getFile(fileId: string): File | undefined {
    return this.files.get(fileId);
  }
  
  getFiles(options?: FileListOptions): File[] {
    let files = Array.from(this.files.values());
    
    // 筛选
    if (options?.type) {
      files = files.filter(f => f.type === options.type);
    }
    if (options?.tags) {
      files = files.filter(f => 
        options.tags!.every(tag => f.tags?.includes(tag))
      );
    }
    
    // 排序
    if (options?.sortBy) {
      files.sort((a, b) => {
        const aValue = a[options.sortBy!];
        const bValue = b[options.sortBy!];
        const order = options.sortOrder === 'desc' ? -1 : 1;
        return aValue > bValue ? order : -order;
      });
    }
    
    return files;
  }
  
  searchFiles(query: string): File[] {
    const lowerQuery = query.toLowerCase();
    return Array.from(this.files.values()).filter(file => 
      file.name.toLowerCase().includes(lowerQuery)
    );
  }
  
  // ===== 导入导出 =====
  
  async importFile(sourcePath: string): Promise<File> {
    const fileName = path.basename(sourcePath);
    const targetPath = path.join(this.basePath, fileName);
    
    await fs.copyFile(sourcePath, targetPath);
    
    const file = await this.addFileToIndex(targetPath);
    this.eventBus.emit('file:imported', file);
    
    return file;
  }
  
  async exportFile(fileId: string, targetPath: string, format: ExportFormat): Promise<void> {
    const file = this.files.get(fileId);
    if (!file) throw new Error(`File not found: ${fileId}`);
    
    switch (format) {
      case 'card':
        await fs.copyFile(file.path, targetPath);
        break;
      case 'html':
        await this.exportAsHTML(file, targetPath);
        break;
      case 'pdf':
        await this.exportAsPDF(file, targetPath);
        break;
    }
  }
  
  // ===== 文件监听 =====
  
  private startWatching(): void {
    this.watcher = fs.watch(this.basePath, { recursive: true }, (eventType, filename) => {
      if (filename) {
        this.handleFileSystemChange(eventType, filename);
      }
    });
  }
  
  private async handleFileSystemChange(eventType: string, filename: string): Promise<void> {
    const filePath = path.join(this.basePath, filename);
    
    if (eventType === 'change') {
      // 文件修改
      const file = this.findFileByPath(filePath);
      if (file) {
        file.updatedAt = Date.now();
        this.eventBus.emit('file:changed', file);
      }
    } else if (eventType === 'rename') {
      // 文件创建或删除
      const exists = await fs.pathExists(filePath);
      if (exists) {
        // 新文件
        const file = await this.addFileToIndex(filePath);
        this.eventBus.emit('file:created', file);
      } else {
        // 文件删除
        const file = this.findFileByPath(filePath);
        if (file) {
          this.files.delete(file.id);
          this.eventBus.emit('file:deleted', file);
        }
      }
    }
  }
  
  // ===== 辅助方法 =====
  
  private async scanFiles(): Promise<void> {
    const entries = await fs.readdir(this.basePath, { withFileTypes: true });
    
    for (const entry of entries) {
      if (entry.isFile()) {
        const filePath = path.join(this.basePath, entry.name);
        await this.addFileToIndex(filePath);
      }
    }
  }
  
  private async addFileToIndex(filePath: string): Promise<File> {
    const stats = await fs.stat(filePath);
    const file: File = {
      id: generateId(),
      name: path.basename(filePath),
      type: this.detectFileType(filePath),
      path: filePath,
      size: stats.size,
      createdAt: stats.birthtimeMs,
      updatedAt: stats.mtimeMs,
    };
    
    this.files.set(file.id, file);
    return file;
  }
  
  private detectFileType(filePath: string): FileType {
    const ext = path.extname(filePath).toLowerCase();
    
    if (ext === '.card') return FileType.CARD;
    if (ext === '.box') return FileType.BOX;
    if (['.jpg', '.png', '.gif'].includes(ext)) return FileType.IMAGE;
    if (['.mp4', '.avi', '.mov'].includes(ext)) return FileType.VIDEO;
    if (['.mp3', '.wav', '.flac'].includes(ext)) return FileType.AUDIO;
    
    return FileType.OTHER;
  }
  
  private ensureUniqueName(name: string): string {
    let uniqueName = name;
    let counter = 1;
    
    while (this.nameExists(uniqueName)) {
      const ext = path.extname(name);
      const base = path.basename(name, ext);
      uniqueName = `${base} (${counter})${ext}`;
      counter++;
    }
    
    return uniqueName;
  }
  
  private nameExists(name: string): boolean {
    return Array.from(this.files.values()).some(f => f.name === name);
  }
  
  private findFileByPath(filePath: string): File | undefined {
    return Array.from(this.files.values()).find(f => f.path === filePath);
  }
  
  private async writeFile(file: File, data: any): Promise<void> {
    const content = JSON.stringify(data, null, 2);
    await fs.writeFile(file.path, content, 'utf-8');
    
    const stats = await fs.stat(file.path);
    file.size = stats.size;
  }
}
```

## 4. 文件缓存

```typescript
class FileCache {
  private cache: Map<string, { data: any; timestamp: number }> = new Map();
  private maxSize = 100; // 最多缓存100个文件
  
  get(fileId: string): any | null {
    const cached = this.cache.get(fileId);
    if (cached) {
      return cached.data;
    }
    return null;
  }
  
  set(fileId: string, data: any): void {
    // LRU 策略
    if (this.cache.size >= this.maxSize) {
      const oldestKey = Array.from(this.cache.keys())[0];
      this.cache.delete(oldestKey);
    }
    
    this.cache.set(fileId, {
      data,
      timestamp: Date.now(),
    });
  }
  
  invalidate(fileId: string): void {
    this.cache.delete(fileId);
  }
  
  clear(): void {
    this.cache.clear();
  }
}
```

## 5. 推荐的开源库

### 5.1 文件操作

- **fs-extra**: 增强的文件系统操作
- **trash**: 安全删除文件(移到回收站)
- **chokidar**: 强大的文件监听库

### 5.2 搜索

- **fuse.js**: 模糊搜索
- **lunr**: 全文搜索引擎

### 5.3 导出

- **puppeteer**: 导出为PDF
- **jszip**: 打包ZIP文件

## 6. 总结

文件管理模块提供了完整的文件操作功能,支持文件的创建、读取、更新、删除,以及搜索、导入导出等高级功能。通过文件监听实现实时同步,保证数据一致性。
