# 卡片编辑引擎 - 架构设计

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 架构概述

### 1.1 整体架构

卡片编辑引擎基于薯片生态的微内核架构，完全遵循中心路由原则。编辑引擎作为应用层，通过微内核路由调用公共基础层和插件系统，使用薯片组件库构建用户界面。

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)                │
│                 卡片编辑引擎 (Chips Editor)                   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │            界面层 (UI Layer)                          │   │
│  │   使用薯片组件库 (@chips/components)                  │   │
│  │   - Button, Input, Select, Menu, Modal...           │   │
│  │   - Grid, Flex, Container, Tree, List...            │   │
│  │   - ThemeProvider, ChipsProvider...                 │   │
│  └────────────────────┬─────────────────────────────────┘   │
│                       │                                      │
│  ┌────────────────────┴─────────────────────────────────┐   │
│  │          业务逻辑层 (Business Logic Layer)            │   │
│  │   - 布局管理器     - 窗口管理器     - 文件管理器      │   │
│  │   - 拖拽处理器     - 保存管理器     - 事件总线        │   │
│  └────────────────────┬─────────────────────────────────┘   │
└───────────────────────┼──────────────────────────────────────┘
                        │ 通过薯片SDK调用
                        │ 所有调用通过微内核路由
┌───────────────────────┴──────────────────────────────────────┐
│              薯片微内核 (Chips Core / Kernel)                 │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              中心路由系统 (Central Router)            │   │
│  │   - 请求路由       - 权限验证       - 服务注册        │   │
│  │   - 事件总线       - 模块加载       - 生命周期管理    │   │
│  └────────────────────┬─────────────────────────────────┘   │
└───────────────────────┼──────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────┴─────┐ ┌──────┴──────┐ ┌─────┴──────┐
│ 公共基础层   │ │  插件系统    │ │  其他模块  │
│ Foundation  │ │  Plugins    │ │  Modules   │
└─────────────┘ └─────────────┘ └────────────┘
```

### 1.2 核心原则

#### 1.2.1 中心路由原则 ⭐ 最重要

**所有通信通过微内核**:
- 编辑引擎 → 微内核 → 公共基础层
- 编辑引擎 → 微内核 → 插件系统
- 插件 → 微内核 → 编辑引擎
- 模块间 → 微内核 → 模块间

**禁止直接调用**:
```typescript
// ❌ 错误：直接调用
import { VideoPlayer } from '@chips/foundation';
VideoPlayer.play("video.mp4");

// ✅ 正确：通过微内核路由
import { Core } from '@chips/sdk';
await Core.request({
  service: "foundation.video-player.play",
  payload: { videoPath: "video.mp4" }
});
```

#### 1.2.2 分层解耦原则

**清晰的层次结构**:
1. **界面层**: 使用薯片组件库，只负责UI渲染和用户交互
2. **业务逻辑层**: 编辑引擎核心，处理业务逻辑
3. **通信层**: 薯片SDK，封装与微内核的通信
4. **路由层**: 薯片微内核，中心路由和调度
5. **功能层**: 公共基础层和插件，提供具体功能

**层间通信**:
- 上层只能调用下层（通过微内核）
- 下层通过事件通知上层（通过微内核事件总线）
- 同层不直接通信（通过微内核中转）

#### 1.2.3 依赖反转原则

**依赖关系**:
```
编辑引擎 ─依赖→ 薯片SDK
         └依赖→ 薯片组件库

薯片SDK ─封装→ 微内核通信

微内核 ─管理→ 公共基础层
       └管理→ 插件系统
```

编辑引擎不直接依赖基础层，而是通过SDK和微内核间接使用。

---

## 2. 技术栈

### 2.1 核心技术

**前端框架**: Vue 3 + TypeScript
- Vue 3 Composition API
- TypeScript 5.0+
- Vite 构建工具

**状态管理**: Pinia
- 轻量级状态管理
- TypeScript 友好
- 模块化设计

**UI组件**: @chips/components（薯片组件库）
- 功能与样式完全分离
- 支持原子级主题
- Vue 3 实现

**桌面框架**: Electron
- 跨平台支持
- 文件系统访问
- 集成 Chromium 内核

**通信层**: @chips/sdk（薯片SDK）
- 封装与微内核的通信
- 提供友好的API
- 处理请求/响应/事件

### 2.2 依赖清单

**必需依赖**:
```json
{
  "dependencies": {
    "@chips/sdk": "^1.0.0",
    "@chips/components": "^1.0.0",
    "vue": "^3.3.0",
    "pinia": "^2.1.0",
    "electron": "^28.0.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "electron-builder": "^24.0.0"
  }
}
```

**禁止的依赖**:
- ❌ 不允许直接依赖基础层模块
- ❌ 不允许直接依赖插件
- ❌ 不允许使用其他UI框架（只用薯片组件库）

---

## 3. 模块架构

### 3.1 编辑引擎核心模块

```
Chips-Editor/
├── src/
│   ├── core/                        # 核心模块
│   │   ├── LayoutManager.ts         # 布局管理器
│   │   ├── WindowManager.ts         # 窗口管理器
│   │   ├── FileManager.ts           # 文件管理器
│   │   ├── DragDropHandler.ts       # 拖拽处理器
│   │   ├── SaveManager.ts           # 保存管理器
│   │   ├── EventBus.ts              # 事件总线
│   │   └── CommandManager.ts        # 命令管理器（撤销/重做）
│   │
│   ├── layouts/                     # 内置布局插件
│   │   ├── InfiniteCanvasLayout/    # 无限画布布局
│   │   └── WorkbenchLayout/         # 工作台布局
│   │
│   ├── components/                  # Vue组件（使用薯片组件库）
│   │   ├── CardWindow.vue           # 卡片窗口组件
│   │   ├── CoverWindow.vue          # 封面窗口组件
│   │   ├── FileManager.vue          # 文件管理器组件
│   │   ├── EditPanel.vue            # 编辑面板组件
│   │   ├── CardBox.vue              # 卡箱库组件
│   │   ├── Dock.vue                 # 程序坞组件
│   │   └── ZoomControl.vue          # 缩放控制器组件
│   │
│   ├── stores/                      # Pinia状态管理
│   │   ├── editor.ts                # 编辑器主状态
│   │   ├── windows.ts               # 窗口状态
│   │   ├── files.ts                 # 文件状态
│   │   └── layout.ts                # 布局状态
│   │
│   ├── services/                    # 服务层（通过SDK调用微内核）
│   │   ├── KernelService.ts         # 微内核通信服务
│   │   ├── CardService.ts           # 卡片服务
│   │   ├── BoxService.ts            # 箱子服务
│   │   ├── ResourceService.ts       # 资源服务
│   │   ├── PluginService.ts         # 插件服务
│   │   └── ConfigService.ts         # 配置服务
│   │
│   ├── utils/                       # 工具函数
│   │   ├── coordinates.ts           # 坐标转换
│   │   ├── validation.ts            # 数据验证
│   │   ├── debounce.ts              # 防抖节流
│   │   └── idGenerator.ts           # ID生成
│   │
│   ├── types/                       # 类型定义
│   │   ├── window.ts                # 窗口类型
│   │   ├── file.ts                  # 文件类型
│   │   ├── card.ts                  # 卡片类型
│   │   └── plugin.ts                # 插件类型
│   │
│   ├── main.ts                      # 应用入口
│   └── App.vue                      # 根组件
│
├── electron/                        # Electron主进程
│   ├── main.ts                      # 主进程入口
│   ├── preload.ts                   # 预加载脚本
│   └── ipc.ts                       # IPC通信
│
└── package.json
```

---

### 3.2 核心模块设计

#### 3.2.1 布局管理器 (LayoutManager)

**职责**:
- 加载和卸载布局插件
- 管理布局切换
- 提供布局API
- 维护布局状态

**接口设计**:
```typescript
export class LayoutManager {
  private core: Core;  // 薯片SDK实例
  private currentLayout: LayoutPlugin | null = null;
  private currentLayoutId: string = '';
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 获取已安装的布局列表（通过微内核）
   */
  async getLayouts(): Promise<LayoutInfo[]> {
    const response = await this.core.request({
      service: "plugin.list",
      payload: { filter: { type: "layout" } }
    });
    
    return response.plugins.map(p => ({
      id: p.id,
      name: p.name,
      version: p.version,
      description: p.description
    }));
  }
  
  /**
   * 获取当前布局
   */
  getCurrentLayout(): LayoutPlugin | null {
    return this.currentLayout;
  }
  
  /**
   * 切换布局（通过微内核）
   */
  async switchLayout(layoutId: string): Promise<void> {
    // 1. 保存当前布局状态
    if (this.currentLayout) {
      const state = this.currentLayout.getState();
      await this.core.request({
        service: "config.set",
        payload: {
          key: `layout.${this.currentLayoutId}.state`,
          value: state
        }
      });
      
      // 卸载当前布局
      await this.currentLayout.unmount();
      
      // 通过微内核卸载插件
      await this.core.request({
        service: "plugin.unload",
        payload: { pluginId: this.currentLayoutId }
      });
    }
    
    // 2. 通过微内核加载新布局
    const response = await this.core.request({
      service: "plugin.load",
      payload: { pluginId: layoutId }
    });
    
    // 3. 初始化新布局
    const layout = response.plugin as LayoutPlugin;
    await layout.init(this.createEngineContext());
    
    // 4. 挂载新布局
    const container = document.getElementById('layout-container');
    await layout.mount(container);
    
    // 5. 恢复状态
    const savedState = await this.core.request({
      service: "config.get",
      payload: { key: `layout.${layoutId}.state` }
    });
    
    if (savedState.value) {
      await layout.restoreState(savedState.value);
    }
    
    // 6. 更新当前布局
    this.currentLayout = layout;
    this.currentLayoutId = layoutId;
    
    // 7. 发布事件
    await this.core.event.publish({
      eventType: "editor.layout.changed",
      payload: { from: this.currentLayoutId, to: layoutId }
    });
  }
  
  /**
   * 创建引擎上下文（提供给布局插件）
   */
  private createEngineContext(): EngineContext {
    return {
      // 提供通过微内核调用引擎功能的接口
      callEngine: async (service: string, payload: any) => {
        return await this.core.request({
          service: `editor.${service}`,
          payload
        });
      },
      
      // 提供事件订阅（通过微内核）
      on: (eventType: string, handler: Function) => {
        this.core.event.subscribe(eventType, handler);
      },
      
      off: (eventType: string, handler: Function) => {
        this.core.event.unsubscribe(eventType, handler);
      },
      
      // 提供配置访问（通过微内核）
      getConfig: async (key: string) => {
        const response = await this.core.request({
          service: "config.get",
          payload: { key }
        });
        return response.value;
      },
      
      setConfig: async (key: string, value: any) => {
        await this.core.request({
          service: "config.set",
          payload: { key, value }
        });
      }
    };
  }
}
```

**与微内核集成**:
- 所有插件加载通过 `plugin.load`
- 所有配置读写通过 `config.get/set`
- 所有事件通过事件总线

---

#### 3.2.2 窗口管理器 (WindowManager)

**职责**:
- 管理所有窗口的生命周期
- 维护窗口堆叠顺序
- 处理窗口事件
- 管理窗口状态

**接口设计**:
```typescript
export class WindowManager {
  private core: Core;
  private windows: Map<string, Window> = new Map();
  private zIndexOrder: string[] = [];
  private focusedWindowId: string | null = null;
  private baseZIndex = 1000;
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 创建窗口（通过微内核读取数据和加载插件）
   */
  async createWindow(
    fileId: string, 
    options?: WindowOptions
  ): Promise<Window> {
    // 1. 通过微内核读取文件数据
    const response = await this.core.request({
      service: "card.read",
      payload: { 
        cardId: fileId,
        includeContent: true 
      }
    });
    
    const cardData = response.card;
    
    // 2. 生成窗口ID
    const windowId = generateId();
    
    // 3. 创建窗口数据
    const window: Window = {
      id: windowId,
      type: 'card',
      fileId,
      position: options?.position || this.getDefaultPosition(),
      size: options?.size || { width: 600, height: 800 },
      state: options?.state || 'expanded',
      zIndex: this.getNextZIndex(),
      layer: 'desktop',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      data: cardData
    };
    
    // 4. 保存窗口
    this.windows.set(windowId, window);
    this.zIndexOrder.push(windowId);
    
    // 5. 注意：编辑模式下不需要渲染
    // 如果需要预览，应该调用 CardRenderer（见下文"卡片渲染和预览"章节）
    
    // 6. 发布事件
    await this.core.event.publish({
      eventType: "editor.window.created",
      payload: { window }
    });
    
    // 7. 聚焦窗口
    await this.focusWindow(windowId);
    
    return window;
  }
  
  /**
   * 关闭窗口（通过微内核保存状态）
   */
  async closeWindow(windowId: string): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 1. 发布关闭前事件（可取消）
    const event = { window, cancelled: false };
    await this.core.event.publish({
      eventType: "editor.window.before-close",
      payload: event
    });
    
    if (event.cancelled) return;
    
    // 2. 保存窗口状态
    await this.saveWindowState(windowId);
    
    // 3. 从存储中删除
    this.windows.delete(windowId);
    
    // 4. 更新z-index顺序
    const index = this.zIndexOrder.indexOf(windowId);
    if (index !== -1) {
      this.zIndexOrder.splice(index, 1);
    }
    
    // 5. 转移焦点
    if (this.focusedWindowId === windowId) {
      this.focusedWindowId = null;
      if (this.zIndexOrder.length > 0) {
        await this.focusWindow(
          this.zIndexOrder[this.zIndexOrder.length - 1]
        );
      }
    }
    
    // 6. 发布关闭事件
    await this.core.event.publish({
      eventType: "editor.window.closed",
      payload: { window }
    });
  }
  
  /**
   * 聚焦窗口
   */
  async focusWindow(windowId: string): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 更新焦点
    this.focusedWindowId = windowId;
    
    // 提升到最前
    this.bringToFront(windowId);
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.window.focused",
      payload: { window }
    });
  }
  
  /**
   * 提升窗口到最前
   */
  private bringToFront(windowId: string): void {
    // 从当前位置移除
    const index = this.zIndexOrder.indexOf(windowId);
    if (index !== -1) {
      this.zIndexOrder.splice(index, 1);
    }
    
    // 添加到末尾（最前）
    this.zIndexOrder.push(windowId);
    
    // 重新分配z-index
    this.reassignZIndexes();
  }
  
  /**
   * 重新分配z-index
   */
  private reassignZIndexes(): void {
    for (let i = 0; i < this.zIndexOrder.length; i++) {
      const windowId = this.zIndexOrder[i];
      const window = this.windows.get(windowId);
      if (window) {
        window.zIndex = this.baseZIndex + i;
      }
    }
  }
  
  /**
   * 保存窗口状态（通过微内核）
   */
  private async saveWindowState(windowId: string): Promise<void> {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    await this.core.request({
      service: "config.set",
      payload: {
        key: `window.${windowId}.state`,
        value: {
          position: window.position,
          size: window.size,
          state: window.state,
          zIndex: window.zIndex
        }
      }
    });
  }
  
  /**
   * 获取所有窗口
   */
  getWindows(): Window[] {
    return Array.from(this.windows.values());
  }
  
  /**
   * 获取焦点窗口
   */
  getFocusedWindow(): Window | null {
    if (!this.focusedWindowId) return null;
    return this.windows.get(this.focusedWindowId) || null;
  }
}
```

---

#### 3.2.3 文件管理器 (FileManager)

**职责**:
- 文件系统操作（通过微内核）
- 文件索引和缓存
- 文件搜索
- 监听文件变化

**接口设计**:
```typescript
export class FileManager {
  private core: Core;
  private filesCache: Map<string, File> = new Map();
  
  constructor(core: Core) {
    this.core = core;
    this.initFileWatcher();
  }
  
  /**
   * 获取文件列表（通过微内核）
   */
  async getFiles(options?: FileListOptions): Promise<File[]> {
    const response = await this.core.request({
      service: "file.list",
      payload: {
        path: options?.path || this.getWorkspacePath(),
        recursive: options?.recursive ?? false,
        filter: options?.filter
      }
    });
    
    // 更新缓存
    for (const file of response.files) {
      this.filesCache.set(file.id, file);
    }
    
    return response.files;
  }
  
  /**
   * 获取文件内容（通过微内核）
   */
  async getFile(fileId: string): Promise<File> {
    // 先检查缓存
    if (this.filesCache.has(fileId)) {
      return this.filesCache.get(fileId)!;
    }
    
    // 通过微内核读取
    const response = await this.core.request({
      service: "card.read",
      payload: { cardId: fileId }
    });
    
    const file: File = {
      id: fileId,
      name: response.card.metadata.name,
      type: 'card',
      data: response.card
    };
    
    // 更新缓存
    this.filesCache.set(fileId, file);
    
    return file;
  }
  
  /**
   * 创建文件（通过微内核）
   */
  async createFile(type: FileType, name: string): Promise<File> {
    const response = await this.core.request({
      service: "card.create",
      payload: { name, type }
    });
    
    const file: File = {
      id: response.cardId,
      name,
      type,
      path: response.filePath
    };
    
    // 更新缓存
    this.filesCache.set(file.id, file);
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.file.created",
      payload: { file }
    });
    
    return file;
  }
  
  /**
   * 删除文件（通过微内核）
   */
  async deleteFile(fileId: string, permanent = false): Promise<void> {
    await this.core.request({
      service: "card.delete",
      payload: { cardId: fileId, permanent }
    });
    
    // 从缓存移除
    this.filesCache.delete(fileId);
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.file.deleted",
      payload: { fileId }
    });
  }
  
  /**
   * 重命名文件（通过微内核）
   */
  async renameFile(fileId: string, newName: string): Promise<void> {
    await this.core.request({
      service: "card.update",
      payload: {
        cardId: fileId,
        updates: { metadata: { name: newName } }
      }
    });
    
    // 更新缓存
    const file = this.filesCache.get(fileId);
    if (file) {
      file.name = newName;
    }
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.file.renamed",
      payload: { fileId, newName }
    });
  }
  
  /**
   * 搜索文件（通过微内核）
   */
  async searchFiles(query: string): Promise<File[]> {
    const response = await this.core.request({
      service: "file.search",
      payload: { query }
    });
    
    return response.files;
  }
  
  /**
   * 导入文件（通过微内核）
   */
  async importFile(sourcePath: string): Promise<File> {
    // 1. 通过微内核识别文件类型
    const identifyResponse = await this.core.request({
      service: "file.identify",
      payload: { filePath: sourcePath }
    });
    
    const fileType = identifyResponse.fileType;
    
    // 2. 根据类型处理
    if (fileType === 'card') {
      // 直接导入卡片文件
      const response = await this.core.request({
        service: "card.import",
        payload: { sourcePath }
      });
      return { id: response.cardId, name: response.name, type: 'card' };
    } else {
      // 创建对应类型的卡片
      const response = await this.core.request({
        service: "card.create-from-file",
        payload: { filePath: sourcePath, fileType }
      });
      return { id: response.cardId, name: response.name, type: 'card' };
    }
  }
  
  /**
   * 导出文件（通过微内核）
   */
  async exportFile(
    fileId: string, 
    targetPath: string, 
    format: ExportFormat
  ): Promise<void> {
    await this.core.request({
      service: "card.export",
      payload: {
        cardId: fileId,
        exportPath: targetPath,
        format,
        includeResources: true
      }
    });
  }
  
  /**
   * 初始化文件监听（通过微内核）
   */
  private initFileWatcher(): void {
    this.core.event.subscribe("file.modified", (event) => {
      // 处理文件变化
      this.handleFileModified(event.payload);
    });
    
    this.core.event.subscribe("file.deleted", (event) => {
      // 处理文件删除
      this.handleFileDeleted(event.payload);
    });
  }
}
```

---

#### 3.2.3.5 卡片渲染和预览管理器 (CardRenderingManager) ⭐ 重要

**职责**:
- 通过微内核调用公共基础层的 CardRenderer
- 管理预览模式和查看模式
- 处理编辑模式和查看模式的切换
- **不自己实现渲染逻辑**

**核心原则** ⭐⭐⭐:
- **卡片渲染逻辑在公共基础层**（CardRenderer、BaseCardRenderers、BoxRenderer、ThemeEngine）
- **编辑引擎通过路由调用 CardRenderer**，不自己实现渲染
- **预览功能**和**查看模式**都使用 CardRenderer
- 编辑引擎负责编辑功能，渲染交给基础层

**接口设计**:
```typescript
export class CardRenderingManager {
  private core: Core;
  private currentMode: 'edit' | 'preview' | 'view' = 'edit';
  private renderCache: Map<string, HTMLIFrameElement> = new Map();
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 渲染卡片预览（通过 CardRenderer）
   */
  async renderPreview(cardId: string, containerId: string): Promise<void> {
    // 通过微内核调用 CardRenderer（公共基础层）
    const response = await this.core.request({
      service: "foundation.card.render",
      payload: {
        card_id: cardId,
        container_id: containerId,
        options: {
          theme_id: await this.getCurrentTheme(),
          interactive: true,
          readonly: true,  // 预览模式只读
          quality: 'high',
          lazy_load: true
        }
      }
    });
    
    if (response.success) {
      // 获取渲染结果（iframe 窗口）
      const cardFrame = response.data.frame;
      
      // 缓存渲染结果
      this.renderCache.set(cardId, cardFrame);
      
      // 发布预览事件
      await this.core.event.publish({
        eventType: "editor.card.previewed",
        payload: { cardId }
      });
    }
  }
  
  /**
   * 切换到查看模式（通过 CardRenderer）
   */
  async switchToViewMode(cardId: string, containerId: string): Promise<void> {
    this.currentMode = 'view';
    
    // 调用 CardRenderer 渲染完整卡片
    const response = await this.core.request({
      service: "foundation.card.render",
      payload: {
        card_id: cardId,
        container_id: containerId,
        options: {
          theme_id: await this.getCurrentTheme(),
          interactive: true,
          readonly: true
        }
      }
    });
    
    if (response.success) {
      // 隐藏编辑工具栏
      await this.hideEditingTools();
      
      // 显示查看工具栏
      await this.showViewingTools();
      
      // 发布模式切换事件
      await this.core.event.publish({
        eventType: "editor.mode.changed",
        payload: { mode: 'view', cardId }
      });
    }
  }
  
  /**
   * 切换到编辑模式
   */
  async switchToEditMode(cardId: string): Promise<void> {
    this.currentMode = 'edit';
    
    // 清除渲染的 iframe
    const cachedFrame = this.renderCache.get(cardId);
    if (cachedFrame) {
      cachedFrame.remove();
      this.renderCache.delete(cardId);
    }
    
    // 显示编辑工具栏
    await this.showEditingTools();
    
    // 隐藏查看工具栏
    await this.hideViewingTools();
    
    // 发布模式切换事件
    await this.core.event.publish({
      eventType: "editor.mode.changed",
      payload: { mode: 'edit', cardId }
    });
  }
  
  /**
   * 渲染箱子预览（通过 BoxRenderer）
   */
  async renderBoxPreview(boxId: string, containerId: string): Promise<void> {
    const response = await this.core.request({
      service: "foundation.box.render",
      payload: {
        box_id: boxId,
        container_id: containerId,
        options: {
          theme_id: await this.getCurrentTheme(),
          interactive: true
        }
      }
    });
    
    if (response.success) {
      // BoxRenderer 返回箱子展示界面（iframe）
      const boxFrame = response.data.frame;
      
      // 监听卡片项点击事件
      this.setupBoxInteraction(boxFrame, boxId);
    }
  }
  
  /**
   * 获取当前主题
   */
  private async getCurrentTheme(): Promise<string> {
    const response = await this.core.request({
      service: "config.get",
      payload: { key: "theme.current" }
    });
    
    return response.value || 'chipshub:light';
  }
  
  /**
   * 设置箱子交互
   */
  private setupBoxInteraction(boxFrame: HTMLIFrameElement, boxId: string): void {
    // 监听 iframe 内的卡片点击事件
    boxFrame.contentWindow?.addEventListener('cardClick', (event: CustomEvent) => {
      const cardId = event.detail.cardId;
      // 在编辑器中打开该卡片
      this.openCardInEditor(cardId);
    });
  }
  
  /**
   * 在编辑器中打开卡片
   */
  private async openCardInEditor(cardId: string): Promise<void> {
    await this.core.event.publish({
      eventType: "editor.card.open",
      payload: { cardId }
    });
  }
  
  // ... 其他辅助方法
}
```

**CardRenderer 的渲染流程**（由公共基础层自动处理）:
1. 解析卡片文件结构（metadata.yaml、structure.yaml、content/）
2. 遍历基础卡片列表，按顺序渲染
3. 对于每个基础卡片：
   - 根据类型调用对应的 BaseCardRenderer
   - BaseCardRenderer 调用基础卡片插件的前端代码
   - 将配置数据填充到前端模板
   - 生成 iframe 窗口
4. 垂直排列所有基础卡片的 iframe
5. 添加菜单栏和卡片级主题背景
6. 返回完整的大 iframe 窗口

**编辑引擎的职责**:
- ✅ 通过路由调用 CardRenderer/BoxRenderer
- ✅ 接收渲染结果（iframe 窗口）
- ✅ 管理编辑模式和查看/预览模式的切换
- ✅ 提供编辑功能和工具
- ❌ 不实现卡片渲染逻辑
- ❌ 不实现基础卡片的渲染器
- ❌ 不解析卡片文件结构（由 CardRenderer 处理）

---

#### 3.2.4 拖拽处理器 (DragDropHandler)

**职责**:
- 统一处理拖拽事件（通过基础层 DragDropSystem）
- 判断拖拽类型和目标
- 提供拖拽反馈
- 执行拖拽操作（通过微内核）

**接口设计**:
```typescript
export class DragDropHandler {
  private core: Core;
  
  constructor(core: Core) {
    this.core = core;
    this.initDragDropSystem();
  }
  
  /**
   * 初始化拖拽系统（通过基础层）
   */
  private async initDragDropSystem(): Promise<void> {
    // 通过微内核初始化基础层的拖拽系统
    await this.core.request({
      service: "foundation.drag-drop.init",
      payload: {}
    });
    
    // 订阅拖拽事件
    this.core.event.subscribe("drag.start", this.handleDragStart);
    this.core.event.subscribe("drag.move", this.handleDragMove);
    this.core.event.subscribe("drag.end", this.handleDragEnd);
  }
  
  /**
   * 注册拖拽源（通过基础层）
   */
  async registerDragSource(
    sourceId: string,
    type: DragSourceType,
    data: any
  ): Promise<void> {
    await this.core.request({
      service: "foundation.drag-drop.register-source",
      payload: {
        sourceId,
        type,
        data,
        onDragStart: (event) => this.handleDragStart(event),
        onDragEnd: (event) => this.handleDragEnd(event)
      }
    });
  }
  
  /**
   * 注册放置目标（通过基础层）
   */
  async registerDropTarget(
    targetId: string,
    accepts: DragSourceType[],
    onDrop: DropHandler
  ): Promise<void> {
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId,
        accepts,
        onDrop: (event) => {
          // 处理放置事件，执行相应的微内核调用
          this.handleDrop(event, onDrop);
        }
      }
    });
  }
  
  /**
   * 处理从卡箱库拖动
   */
  private async handleCardBoxDrag(
    cardType: string,
    targetType: string,
    targetId: string,
    position: Position
  ): Promise<void> {
    if (targetType === 'desktop-empty') {
      // 拖到桌面空白区域 - 创建新卡片
      const response = await this.core.request({
        service: "card.create",
        payload: { name: t('card.untitled') }
      });
      
      await this.core.request({
        service: "card.add_base_card",
        payload: {
          cardId: response.cardId,
          baseCardType: cardType,
          config: {}
        }
      });
      
      // 创建窗口
      await this.windowManager.createWindow(response.cardId, { position });
      
    } else if (targetType === 'card-window') {
      // 拖到已有卡片 - 添加基础卡片
      await this.core.request({
        service: "card.add_base_card",
        payload: {
          cardId: targetId,
          baseCardType: cardType,
          config: {},
          position: this.calculateInsertPosition(position)
        }
      });
    }
  }
  
  /**
   * 处理从文件系统拖入
   */
  private async handleFileDrop(
    filePath: string,
    targetType: string,
    targetId: string,
    position: Position
  ): Promise<void> {
    // 1. 通过微内核识别文件类型
    const identifyResponse = await this.core.request({
      service: "file.identify",
      payload: { filePath }
    });
    
    const fileType = identifyResponse.fileType;
    
    // 2. 根据文件类型和目标类型处理
    if (targetType === 'desktop-empty') {
      // 创建新卡片
      const response = await this.core.request({
        service: "card.create-from-file",
        payload: { filePath, fileType }
      });
      
      await this.windowManager.createWindow(response.cardId, { position });
      
    } else if (targetType === 'card-window') {
      // 添加到已有卡片
      const response = await this.core.request({
        service: "card.add-from-file",
        payload: {
          cardId: targetId,
          filePath,
          fileType,
          position: this.calculateInsertPosition(position)
        }
      });
    }
  }
}
```

---

#### 3.2.5 保存管理器 (SaveManager)

**职责**:
- 实时保存机制
- 防抖动保存
- 保存队列管理
- 冲突检测和处理

**接口设计**:
```typescript
export class SaveManager {
  private core: Core;
  private dirtyFiles: Set<string> = new Set();
  private debouncedSave: Map<string, Function> = new Map();
  
  constructor(core: Core) {
    this.core = core;
  }
  
  /**
   * 标记数据已修改
   */
  markDirty(fileId: string, data: any): void {
    this.dirtyFiles.add(fileId);
    
    // 创建或获取该文件的防抖保存函数
    if (!this.debouncedSave.has(fileId)) {
      const debouncedFn = debounce(
        () => this.saveNow(fileId, data),
        DEBOUNCE_DELAY.CARD_EDIT
      );
      this.debouncedSave.set(fileId, debouncedFn);
    }
    
    // 触发防抖保存
    const saveFunction = this.debouncedSave.get(fileId)!;
    saveFunction();
  }
  
  /**
   * 立即保存（通过微内核）
   */
  async saveNow(fileId: string, data?: any): Promise<void> {
    if (!this.dirtyFiles.has(fileId)) return;
    
    try {
      // 获取最新数据（如果没有传入）
      if (!data) {
        data = await this.getCurrentData(fileId);
      }
      
      // 通过微内核保存
      await this.core.request({
        service: "card.update",
        payload: {
          cardId: fileId,
          updates: data
        }
      });
      
      // 清除脏标记
      this.dirtyFiles.delete(fileId);
      
      // 发布事件
      await this.core.event.publish({
        eventType: "editor.file.saved",
        payload: { fileId }
      });
      
    } catch (error) {
      // 记录错误（通过微内核）
      await this.core.request({
        service: "foundation.log.write",
        payload: {
          level: "error",
          message: "Failed to save file",
          context: { fileId, error }
        }
      });
      
      // 显示错误提示
      Message.error(t('message.save_failed'));
    }
  }
  
  /**
   * 保存所有脏数据（应用退出时调用）
   */
  async saveAll(): Promise<void> {
    const promises = Array.from(this.dirtyFiles).map(fileId =>
      this.saveNow(fileId)
    );
    
    await Promise.all(promises);
  }
  
  /**
   * 检测文件冲突（通过微内核）
   */
  private async detectConflict(fileId: string): Promise<boolean> {
    const response = await this.core.request({
      service: "file.check-modified",
      payload: { fileId }
    });
    
    return response.modified;
  }
}
```

---

#### 3.2.6 命令管理器 (CommandManager)

**职责**:
- 实现撤销/重做功能
- 维护操作历史栈
- 执行命令模式

**接口设计**:
```typescript
export interface Command {
  execute(): Promise<void>;
  undo(): Promise<void>;
  redo(): Promise<void>;
  canUndo(): boolean;
  canRedo(): boolean;
}

export class CommandManager {
  private core: Core;
  private undoStack: Command[] = [];
  private redoStack: Command[] = [];
  private maxStackSize = 100;
  
  /**
   * 执行命令
   */
  async execute(command: Command): Promise<void> {
    await command.execute();
    
    // 添加到撤销栈
    this.undoStack.push(command);
    if (this.undoStack.length > this.maxStackSize) {
      this.undoStack.shift();
    }
    
    // 清空重做栈
    this.redoStack = [];
    
    // 发布事件
    await this.core.event.publish({
      eventType: "editor.command.executed",
      payload: { command }
    });
  }
  
  /**
   * 撤销
   */
  async undo(): Promise<void> {
    if (this.undoStack.length === 0) return;
    
    const command = this.undoStack.pop()!;
    await command.undo();
    
    this.redoStack.push(command);
    
    await this.core.event.publish({
      eventType: "editor.command.undone",
      payload: { command }
    });
  }
  
  /**
   * 重做
   */
  async redo(): Promise<void> {
    if (this.redoStack.length === 0) return;
    
    const command = this.redoStack.pop()!;
    await command.redo();
    
    this.undoStack.push(command);
    
    await this.core.event.publish({
      eventType: "editor.command.redone",
      payload: { command }
    });
  }
}

/**
 * 添加基础卡片命令示例
 */
export class AddBaseCardCommand implements Command {
  constructor(
    private core: Core,
    private cardId: string,
    private baseCardType: string,
    private position: number
  ) {}
  
  async execute(): Promise<void> {
    const response = await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId: this.cardId,
        baseCardType: this.baseCardType,
        config: {},
        position: this.position
      }
    });
    
    this.baseCardId = response.baseCardId;
  }
  
  async undo(): Promise<void> {
    await this.core.request({
      service: "card.remove_base_card",
      payload: {
        cardId: this.cardId,
        baseCardId: this.baseCardId
      }
    });
  }
  
  async redo(): Promise<void> {
    await this.execute();
  }
  
  canUndo(): boolean { return true; }
  canRedo(): boolean { return true; }
}
```

---

## 4. 服务层设计

### 4.1 服务层架构

服务层封装对微内核的调用，提供类型安全的API。

```typescript
// services/KernelService.ts
export class KernelService {
  private core: Core;
  
  constructor() {
    // 初始化薯片SDK
    this.core = Core.getInstance();
  }
  
  /**
   * 通用请求方法
   */
  async request<T = any>(
    service: string, 
    payload: any
  ): Promise<T> {
    const response = await this.core.request({
      service,
      payload
    });
    
    if (response.status === 'error') {
      throw new ChipsError(
        response.error.code,
        response.error.message,
        response.error.details
      );
    }
    
    return response.data;
  }
}

// services/CardService.ts
export class CardService extends KernelService {
  /**
   * 读取卡片
   */
  async readCard(
    cardId: string,
    options?: ReadOptions
  ): Promise<Card> {
    return await this.request<Card>("card.read", {
      cardId,
      includeContent: options?.includeContent ?? true,
      includeResources: options?.includeResources ?? false
    });
  }
  
  /**
   * 创建卡片
   */
  async createCard(name: string): Promise<{ cardId: string }> {
    return await this.request("card.create", { name });
  }
  
  /**
   * 更新卡片
   */
  async updateCard(
    cardId: string,
    updates: Partial<Card>
  ): Promise<void> {
    await this.request("card.update", { cardId, updates });
  }
  
  /**
   * 删除卡片
   */
  async deleteCard(
    cardId: string,
    permanent = false
  ): Promise<void> {
    await this.request("card.delete", { cardId, permanent });
  }
  
  /**
   * 添加基础卡片
   */
  async addBaseCard(
    cardId: string,
    baseCardType: string,
    config: any,
    position?: number
  ): Promise<{ baseCardId: string }> {
    return await this.request("card.add_base_card", {
      cardId,
      baseCardType,
      config,
      position
    });
  }
  
  /**
   * 移除基础卡片
   */
  async removeBaseCard(
    cardId: string,
    baseCardId: string
  ): Promise<void> {
    await this.request("card.remove_base_card", {
      cardId,
      baseCardId
    });
  }
  
  /**
   * 导出卡片
   */
  async exportCard(
    cardId: string,
    exportPath: string,
    format: ExportFormat,
    options?: ExportOptions
  ): Promise<void> {
    await this.request("card.export", {
      cardId,
      exportPath,
      format,
      mode: options?.mode || 'full',
      includeNested: options?.includeNested ?? true
    });
  }
}

// services/ResourceService.ts
export class ResourceService extends KernelService {
  /**
   * 获取资源
   */
  async fetchResource(uri: string): Promise<Resource> {
    return await this.request("resource.fetch", { uri });
  }
  
  /**
   * 写入资源
   */
  async writeResource(
    uri: string,
    data: any
  ): Promise<void> {
    await this.request("resource.write", { uri, data });
  }
}

// services/PluginService.ts
export class PluginService extends KernelService {
  /**
   * 加载插件
   */
  async loadPlugin(
    pluginId: string
  ): Promise<{ plugin: any }> {
    return await this.request("plugin.load", { pluginId });
  }
  
  /**
   * 列出插件
   */
  async listPlugins(
    filter?: PluginFilter
  ): Promise<{ plugins: PluginInfo[] }> {
    return await this.request("plugin.list", { filter });
  }
  
  /**
   * 安装插件
   */
  async installPlugin(
    source: string
  ): Promise<{ pluginId: string }> {
    return await this.request("plugin.install", { source });
  }
}

// services/ConfigService.ts
export class ConfigService extends KernelService {
  /**
   * 获取配置
   */
  async getConfig(key: string): Promise<any> {
    const response = await this.request("config.get", { key });
    return response.value;
  }
  
  /**
   * 设置配置
   */
  async setConfig(key: string, value: any): Promise<void> {
    await this.request("config.set", { key, value });
  }
}
```

---

## 5. 状态管理

### 5.1 Pinia Store 设计

```typescript
// stores/editor.ts
import { defineStore } from 'pinia';
import { Core } from '@chips/sdk';

export const useEditorStore = defineStore('editor', {
  state: () => ({
    // 应用状态
    initialized: false,
    currentLayoutId: 'infinite-canvas',
    theme: 'default',
    locale: 'zh-CN',
    
    // 核心服务
    core: null as Core | null,
    cardService: null as CardService | null,
    pluginService: null as PluginService | null,
    configService: null as ConfigService | null
  }),
  
  actions: {
    /**
     * 初始化编辑器（连接微内核）
     */
    async initialize() {
      // 1. 初始化薯片SDK
      this.core = await Core.initialize({
        appId: "chips.editor",
        version: "2.0.0"
      });
      
      // 2. 初始化服务
      this.cardService = new CardService();
      this.pluginService = new PluginService();
      this.configService = new ConfigService();
      
      // 3. 订阅核心事件
      this.core.event.subscribe("*", this.handleCoreEvent);
      
      // 4. 读取配置
      const config = await this.configService.getConfig("editor");
      this.currentLayoutId = config.defaultLayout || 'infinite-canvas';
      this.theme = config.theme || 'default';
      this.locale = config.locale || 'zh-CN';
      
      this.initialized = true;
    },
    
    /**
     * 处理微内核事件
     */
    handleCoreEvent(event: any) {
      // 处理各种事件
      console.log('Core event:', event);
    }
  }
});

// stores/windows.ts
export const useWindowsStore = defineStore('windows', {
  state: () => ({
    windows: new Map<string, Window>(),
    focusedWindowId: null as string | null,
    zIndexOrder: [] as string[]
  }),
  
  getters: {
    getWindow: (state) => (windowId: string) => {
      return state.windows.get(windowId);
    },
    
    focusedWindow: (state) => {
      if (!state.focusedWindowId) return null;
      return state.windows.get(state.focusedWindowId);
    },
    
    visibleWindows: (state) => (viewportBounds: Bounds) => {
      return Array.from(state.windows.values()).filter(w => {
        // 判断窗口是否在视口内
        return isInViewport(w, viewportBounds);
      });
    }
  },
  
  actions: {
    /**
     * 添加窗口
     */
    addWindow(window: Window) {
      this.windows.set(window.id, window);
      this.zIndexOrder.push(window.id);
    },
    
    /**
     * 移除窗口
     */
    removeWindow(windowId: string) {
      this.windows.delete(windowId);
      const index = this.zIndexOrder.indexOf(windowId);
      if (index !== -1) {
        this.zIndexOrder.splice(index, 1);
      }
      if (this.focusedWindowId === windowId) {
        this.focusedWindowId = null;
      }
    },
    
    /**
     * 聚焦窗口
     */
    focusWindow(windowId: string) {
      this.focusedWindowId = windowId;
      this.bringToFront(windowId);
    },
    
    /**
     * 提升到最前
     */
    bringToFront(windowId: string) {
      const index = this.zIndexOrder.indexOf(windowId);
      if (index !== -1) {
        this.zIndexOrder.splice(index, 1);
      }
      this.zIndexOrder.push(windowId);
      this.reassignZIndexes();
    },
    
    /**
     * 重新分配z-index
     */
    reassignZIndexes() {
      const baseZIndex = 1000;
      for (let i = 0; i < this.zIndexOrder.length; i++) {
        const windowId = this.zIndexOrder[i];
        const window = this.windows.get(windowId);
        if (window) {
          window.zIndex = baseZIndex + i;
        }
      }
    }
  }
});

// stores/files.ts
export const useFilesStore = defineStore('files', {
  state: () => ({
    files: [] as File[],
    openedFiles: new Set<string>(),
    currentFileId: null as string | null,
    searchQuery: ''
  }),
  
  getters: {
    filteredFiles: (state) => {
      if (!state.searchQuery) return state.files;
      
      return state.files.filter(f =>
        f.name.toLowerCase().includes(state.searchQuery.toLowerCase())
      );
    }
  },
  
  actions: {
    /**
     * 加载文件列表（通过微内核）
     */
    async loadFiles() {
      const editorStore = useEditorStore();
      const response = await editorStore.core!.request({
        service: "file.list",
        payload: {}
      });
      
      this.files = response.files;
    }
  }
});

// stores/layout.ts
export const useLayoutStore = defineStore('layout', {
  state: () => ({
    // 无限画布状态
    scale: 1,
    translateX: 0,
    translateY: 0,
    
    // 工作台布局状态
    leftWidth: 250,
    rightWidth: 350,
    bottomHeight: 200,
    
    // 工具窗口状态
    fileManagerVisible: true,
    editPanelVisible: false,
    cardBoxVisible: true
  }),
  
  actions: {
    /**
     * 设置变换（无限画布）
     */
    setTransform(scale: number, translateX: number, translateY: number) {
      this.scale = scale;
      this.translateX = translateX;
      this.translateY = translateY;
    },
    
    /**
     * 缩放到指定级别
     */
    zoomTo(newScale: number, centerX: number, centerY: number) {
      newScale = clamp(newScale, 0.1, 5);
      
      // 计算新的平移，保持缩放中心位置
      const worldX = (centerX - this.translateX) / this.scale;
      const worldY = (centerY - this.translateY) / this.scale;
      
      this.scale = newScale;
      this.translateX = centerX - worldX * newScale;
      this.translateY = centerY - worldY * newScale;
    }
  }
});
```

---

## 6. Vue 组件架构

### 6.1 根组件

```vue
<!-- App.vue -->
<template>
  <ThemeProvider :theme="theme">
    <ChipsProvider :core="core">
      <!-- 连接微内核 -->
      <div v-if="!initialized" class="loading-screen">
        <Loading :tip="t('app.initializing')" />
      </div>
      
      <div v-else class="editor-app">
        <!-- 布局容器 -->
        <div id="layout-container"></div>
        
        <!-- 全局组件 -->
        <GlobalNotification />
        <GlobalModal />
      </div>
    </ChipsProvider>
  </ThemeProvider>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useEditorStore } from './stores/editor';
import { 
  ThemeProvider, 
  ChipsProvider,
  Loading 
} from '@chips/components';

const editorStore = useEditorStore();
const initialized = ref(false);
const core = ref(null);
const theme = ref('default');

onMounted(async () => {
  try {
    // 初始化编辑器（连接微内核）
    await editorStore.initialize();
    
    core.value = editorStore.core;
    theme.value = editorStore.theme;
    
    // 加载默认布局
    const layoutManager = new LayoutManager(editorStore.core!);
    await layoutManager.loadLayout(editorStore.currentLayoutId);
    
    initialized.value = true;
  } catch (error) {
    console.error('Failed to initialize editor:', error);
    Message.error(t('error.init_failed'));
  }
});
</script>
```

### 6.2 卡片窗口组件

```vue
<!-- components/CardWindow.vue -->
<template>
  <div 
    :class="cardWindowClass"
    :style="windowStyle"
    @click="handleClick"
  >
    <!-- 菜单栏 -->
    <div class="card-menubar">
      <Input 
        v-model="cardName"
        class="card-name-input"
        :bordered="false"
        @blur="handleNameBlur"
        @dblclick="handleNameEdit"
      />
      
      <div class="card-actions">
        <Button 
          @click="handleMinimize"
          size="small"
          type="text"
          :title="t('window.minimize')"
        >
          <MinimizeIcon />
        </Button>
        
        <Button 
          @click="handleToggleCover"
          size="small"
          type="text"
          :title="t('window.toggle_cover')"
        >
          <CoverIcon />
        </Button>
        
        <Button 
          @click="handleSettings"
          size="small"
          type="text"
          :title="t('window.settings')"
        >
          <SettingsIcon />
        </Button>
        
        <Button 
          @click="handleToggleLock"
          size="small"
          type="text"
          :title="t('window.toggle_lock')"
        >
          <LockIcon v-if="locked" />
          <UnlockIcon v-else />
        </Button>
        
        <Button 
          @click="handleToggleCollapse"
          size="small"
          type="text"
          :title="t('window.toggle_collapse')"
        >
          <CollapseIcon v-if="collapsed" />
          <ExpandIcon v-else />
        </Button>
        
        <Button 
          @click="handleClose"
          size="small"
          type="text"
          :title="t('window.close')"
        >
          <CloseIcon />
        </Button>
      </div>
    </div>
    
    <!-- 卡片内容 -->
    <div class="card-content">
      <BaseCardRenderer 
        v-for="baseCard in cardData.structure"
        :key="baseCard.id"
        :base-card-id="baseCard.id"
        :card-type="baseCard.type"
        :data="cardData.content[baseCard.id]"
        :editable="!locked"
        @click="handleBaseCardClick(baseCard.id)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useEditorStore } from '@/stores/editor';
import { Button, Input } from '@chips/components';

interface CardWindowProps {
  window: Window;
}

const props = defineProps<CardWindowProps>();
const editorStore = useEditorStore();

const cardName = ref(props.window.data?.metadata.name || '');
const locked = ref(false);
const collapsed = ref(false);

const cardWindowClass = computed(() => [
  'chips-card-window',
  {
    'card-window--collapsed': collapsed.value,
    'card-window--locked': locked.value,
    'card-window--focused': props.window.id === windowsStore.focusedWindowId
  }
]);

const windowStyle = computed(() => ({
  left: `${props.window.position.x}px`,
  top: `${props.window.position.y}px`,
  width: `${props.window.size.width}px`,
  zIndex: props.window.zIndex
}));

const handleClick = async () => {
  await editorStore.core!.request({
    service: "editor.window.focus",
    payload: { windowId: props.window.id }
  });
};

const handleNameBlur = async () => {
  if (cardName.value !== props.window.data?.metadata.name) {
    // 通过微内核保存名称
    await editorStore.cardService!.updateCard(props.window.fileId!, {
      metadata: { name: cardName.value }
    });
  }
};

const handleBaseCardClick = async (baseCardId: string) => {
  if (!locked.value) {
    // 通过微内核加载编辑组件
    await editorStore.core!.request({
      service: "editor.edit-panel.load",
      payload: {
        cardId: props.window.fileId,
        baseCardId
      }
    });
  }
};

const handleClose = async () => {
  await editorStore.core!.request({
    service: "editor.window.close",
    payload: { windowId: props.window.id }
  });
};
</script>
```

---

### 6.3 基础卡片渲染器组件

```vue
<!-- components/BaseCardRenderer.vue -->
<template>
  <div class="base-card-wrapper">
    <!-- 根据卡片类型渲染 -->
    <component 
      :is="cardComponent"
      :data="data"
      :editable="editable"
      v-bind="cardProps"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import {
  MarkdownCard,
  ImageCard,
  VideoCard,
  AudioCard,
  // ... 其他26种卡片组件
} from '@chips/components';

interface BaseCardRendererProps {
  baseCardId: string;
  cardType: string;
  data: any;
  editable: boolean;
}

const props = defineProps<BaseCardRendererProps>();

// 卡片类型映射（从薯片组件库导入）
const cardComponentMap = {
  'MarkdownCard': MarkdownCard,
  'ImageCard': ImageCard,
  'VideoCard': VideoCard,
  'AudioCard': AudioCard,
  // ... 其他类型
};

const cardComponent = computed(() => {
  return cardComponentMap[props.cardType] || UnknownCard;
});

const cardProps = computed(() => ({
  // 传递给卡片组件的属性
  cardId: props.baseCardId,
  metadata: props.data.metadata,
  theme: props.data.theme,
  // ... 其他属性
}));
</script>
```

**说明**:
- 所有卡片渲染组件来自 `@chips/components`
- 组件内部通过薯片SDK调用基础层功能
- 例如 VideoCard 内部调用 `foundation.video-player`
- 例如 ImageCard 内部调用 `foundation.image-viewer`

---

## 7. 通信架构

### 7.1 三层通信机制

```
┌─────────────────────────────────────┐
│         编辑引擎 (Vue组件)           │
│    使用薯片组件库 + Pinia状态         │
└──────────────┬──────────────────────┘
               │ 调用
┌──────────────┴──────────────────────┐
│         服务层 (Services)            │
│    封装微内核调用，提供类型安全API     │
└──────────────┬──────────────────────┘
               │ 通过
┌──────────────┴──────────────────────┐
│        薯片SDK (@chips/sdk)          │
│    封装与微内核的通信协议              │
└──────────────┬──────────────────────┘
               │ 请求/响应/事件
┌──────────────┴──────────────────────┐
│       薯片微内核 (Chips Core)        │
│    中心路由、权限验证、服务调度        │
└─────────────────────────────────────┘
```

### 7.2 请求流程

**完整的请求流程**:
```
1. 用户点击按钮（Vue组件）
   ↓
2. 组件调用服务方法
   cardService.updateCard(cardId, updates)
   ↓
3. 服务层调用SDK
   Core.request({ service: "card.update", payload: {...} })
   ↓
4. SDK封装请求消息
   {
     protocol_version: "1.0.0",
     message_id: "uuid",
     service: "card.update",
     payload: {...}
   }
   ↓
5. SDK发送到微内核（IPC或其他传输层）
   ↓
6. 微内核验证请求
   - 检查格式
   - 验证权限
   - 查找路由
   ↓
7. 微内核路由到目标模块
   - 可能是公共基础层模块
   - 可能是插件模块
   ↓
8. 目标模块执行操作
   - 修改数据
   - 保存文件
   ↓
9. 目标模块返回结果给微内核
   ↓
10. 微内核封装响应消息
    {
      status: "success",
      data: {...},
      metadata: { execution_time: 150 }
    }
    ↓
11. SDK接收响应
    ↓
12. 服务层返回数据给组件
    ↓
13. 组件更新界面（Vue响应式）
```

### 7.3 事件流程

**事件订阅和发布**:
```typescript
// 订阅事件（编辑引擎 → 微内核）
await Core.event.subscribe("card.updated", (event) => {
  // 处理卡片更新事件
  console.log('Card updated:', event.payload);
});

// 发布事件（编辑引擎 → 微内核 → 其他模块）
await Core.event.publish({
  eventType: "editor.window.created",
  payload: { window }
});

// 事件流向
编辑引擎发布事件
  ↓
薯片SDK封装事件消息
  ↓
发送到微内核
  ↓
微内核分发到所有订阅者
  ↓
订阅者接收事件
  ↓
处理事件
```

---

## 8. 与公共基础层的集成

### 8.1 媒体组件调用

**视频播放示例**:
```typescript
// VideoCard 组件内部实现（在薯片组件库中）
export const VideoCard = defineComponent({
  setup(props) {
    const playerRef = ref<HTMLElement>();
    
    onMounted(async () => {
      // 通过微内核调用基础层视频播放器
      const core = inject('core');
      const player = await core.request({
        service: "foundation.video-player.create",
        payload: {
          container: playerRef.value,
          videoPath: props.data.videoFile,
          options: {
            controls: props.data.controls,
            autoplay: props.data.autoplay,
            loop: props.data.loop,
            muted: props.data.muted
          }
        }
      });
      
      // 如果有字幕，添加字幕
      if (props.data.subtitles) {
        for (const subtitle of props.data.subtitles) {
          await core.request({
            service: "foundation.video-player.add-subtitle",
            payload: {
              playerId: player.id,
              subtitlePath: subtitle.file,
              language: subtitle.language,
              label: subtitle.label
            }
          });
        }
      }
    });
    
    return { playerRef };
  }
});
```

**图片显示示例**:
```typescript
// ImageCard 组件内部实现（在薯片组件库中）
export const ImageCard = defineComponent({
  setup(props) {
    const imageRef = ref<HTMLElement>();
    
    onMounted(async () => {
      const core = inject('core');
      
      // 通过微内核调用基础层图片查看器
      await core.request({
        service: "foundation.image-viewer.display",
        payload: {
          container: imageRef.value,
          imagePath: props.data.imageFile,
          fitMode: props.data.fitMode,
          clickable: props.data.clickable
        }
      });
    });
    
    return { imageRef };
  }
});
```

---

### 8.2 文本组件调用

**Markdown渲染示例**:
```typescript
// MarkdownCard 组件内部实现（在薯片组件库中）
export const MarkdownCard = defineComponent({
  setup(props) {
    const contentRef = ref<HTMLElement>();
    
    onMounted(async () => {
      const core = inject('core');
      
      // 1. 通过微内核解析Markdown
      const parseResponse = await core.request({
        service: "foundation.markdown.parse",
        payload: {
          markdown: props.data.contentText,
          options: {
            syntaxHighlight: props.data.syntaxHighlight,
            showToc: props.data.showToc,
            highlightTheme: props.data.highlightTheme
          }
        }
      });
      
      const htmlContent = parseResponse.html;
      
      // 2. 渲染HTML内容
      contentRef.value!.innerHTML = htmlContent;
      
      // 3. 如果有代码块，应用高亮（基础层已处理）
      // 代码高亮在解析时已由基础层的 CodeHighlighter 处理
    });
    
    return { contentRef };
  }
});
```

---

### 8.3 文件处理调用

**卡片文件保存示例**:
```typescript
// SaveManager 保存卡片
async saveCard(cardId: string, cardData: Card): Promise<void> {
  // 1. 准备文件数据
  const files = {
    '.card/metadata.yaml': serializeMetadata(cardData.metadata),
    '.card/structure.yaml': serializeStructure(cardData.structure),
    '.card/cover.html': cardData.cover
  };
  
  // 添加基础卡片配置文件
  for (const baseCard of cardData.structure) {
    const config = cardData.content[baseCard.id];
    files[`content/${baseCard.id}.yaml`] = serializeConfig(config);
  }
  
  // 2. 通过微内核调用ZIPProcessor创建ZIP文件
  await this.core.request({
    service: "foundation.zip-processor.create",
    payload: {
      files,
      outputPath: cardData.filePath,
      compressionLevel: 0  // 零压缩
    }
  });
}

// 卡片文件读取示例
async loadCard(cardPath: string): Promise<Card> {
  // 1. 通过微内核解压ZIP文件
  const extractResponse = await this.core.request({
    service: "foundation.zip-processor.extract",
    payload: {
      zipPath: cardPath,
      extractPath: tempDir
    }
  });
  
  // 2. 通过微内核解析YAML文件
  const metadataResponse = await this.core.request({
    service: "foundation.data-serializer.parse",
    payload: {
      content: extractResponse.files['.card/metadata.yaml'],
      format: "yaml"
    }
  });
  
  const structureResponse = await this.core.request({
    service: "foundation.data-serializer.parse",
    payload: {
      content: extractResponse.files['.card/structure.yaml'],
      format: "yaml"
    }
  });
  
  // 3. 构建卡片对象
  const card: Card = {
    id: metadataResponse.data.card_id,
    metadata: metadataResponse.data,
    structure: structureResponse.data.structure,
    content: {},
    filePath: cardPath
  };
  
  // 4. 加载基础卡片配置
  for (const baseCard of card.structure) {
    const configResponse = await this.core.request({
      service: "foundation.data-serializer.parse",
      payload: {
        content: extractResponse.files[`content/${baseCard.id}.yaml`],
        format: "yaml"
      }
    });
    
    card.content[baseCard.id] = configResponse.data;
  }
  
  return card;
}
```

---

### 8.4 界面组件调用

**拖拽系统集成**:
```typescript
// DragDropHandler 使用基础层拖拽系统
export class DragDropHandler {
  private core: Core;
  
  async initDragDrop(): Promise<void> {
    // 1. 初始化基础层拖拽系统
    await this.core.request({
      service: "foundation.drag-drop.init",
      payload: {}
    });
    
    // 2. 注册拖拽源 - 卡箱库项
    await this.core.request({
      service: "foundation.drag-drop.register-source",
      payload: {
        sourceId: "cardbox-items",
        type: "cardbox-item",
        getData: () => ({ cardType: this.selectedCardType }),
        onDragStart: this.handleCardBoxDragStart,
        onDragEnd: this.handleCardBoxDragEnd
      }
    });
    
    // 3. 注册放置目标 - 桌面空白区域
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId: "desktop-canvas",
        accepts: ["cardbox-item", "file-system"],
        onDragOver: this.handleDesktopDragOver,
        onDrop: this.handleDesktopDrop
      }
    });
    
    // 4. 注册放置目标 - 卡片窗口
    await this.core.request({
      service: "foundation.drag-drop.register-target",
      payload: {
        targetId: "card-windows",
        accepts: ["cardbox-item", "file-system", "card-window"],
        onDragOver: this.handleCardWindowDragOver,
        onDrop: this.handleCardWindowDrop
      }
    });
  }
  
  private handleDesktopDrop = async (event: DropEvent) => {
    const { sourceType, data, position } = event;
    
    if (sourceType === 'cardbox-item') {
      // 从卡箱库拖动到桌面
      await this.createCardFromCardBox(data.cardType, position);
    } else if (sourceType === 'file-system') {
      // 从文件系统拖入桌面
      await this.createCardFromFile(data.filePath, position);
    }
  };
  
  private async createCardFromCardBox(
    cardType: string, 
    position: Position
  ): Promise<void> {
    // 通过微内核创建卡片
    const response = await this.core.request({
      service: "card.create",
      payload: { name: t('card.untitled') }
    });
    
    // 添加基础卡片
    await this.core.request({
      service: "card.add_base_card",
      payload: {
        cardId: response.cardId,
        baseCardType: cardType,
        config: {}
      }
    });
    
    // 创建窗口
    await this.windowManager.createWindow(response.cardId, { position });
  }
  
  private async createCardFromFile(
    filePath: string,
    position: Position
  ): Promise<void> {
    // 通过微内核识别文件并创建卡片
    const response = await this.core.request({
      service: "card.create-from-file",
      payload: { filePath }
    });
    
    // 创建窗口
    await this.windowManager.createWindow(response.cardId, { position });
  }
}
```

---

## 9. 数据流架构

### 9.1 用户操作数据流

```
用户操作（拖拽、点击、输入）
  ↓
Vue组件捕获事件
  ↓
组件调用Store的Action
  ↓
Store的Action调用Service
  ↓
Service通过SDK调用微内核
  Core.request({ service, payload })
  ↓
微内核路由到目标模块
  ↓
目标模块执行操作
  - 公共基础层：处理文件、渲染内容等
  - 插件系统：编辑、渲染卡片
  ↓
目标模块返回结果
  ↓
微内核返回响应
  ↓
SDK解析响应
  ↓
Service返回数据
  ↓
Store更新状态
  ↓
Vue响应式更新界面
  ↓
用户看到结果
```

### 9.2 事件数据流

```
模块A发生事件
  ↓
模块A通过微内核发布事件
  Core.event.publish({ eventType, payload })
  ↓
微内核事件总线分发
  ↓
所有订阅者接收事件
  ↓
编辑引擎处理事件
  - 更新Store状态
  - 刷新界面
  - 执行相应操作
```

---

## 10. 性能优化架构

### 10.1 渲染优化

**视口裁剪**:
```typescript
// 只渲染可见窗口
export class CanvasRenderer {
  private layoutStore = useLayoutStore();
  
  updateVisibility(): void {
    const viewportBounds = this.getViewportBounds();
    
    for (const window of this.windows.values()) {
      const isVisible = this.isWindowInViewport(window, viewportBounds);
      
      // 更新窗口可见性
      window.visible = isVisible;
    }
  }
  
  getViewportBounds(): Bounds {
    const { scale, translateX, translateY } = this.layoutStore;
    
    // 屏幕坐标转世界坐标
    const topLeft = this.screenToWorld(0, 0, scale, translateX, translateY);
    const bottomRight = this.screenToWorld(
      window.innerWidth, 
      window.innerHeight,
      scale,
      translateX,
      translateY
    );
    
    // 添加缓冲区
    const buffer = 200;
    
    return {
      left: topLeft.x - buffer,
      top: topLeft.y - buffer,
      right: bottomRight.x + buffer,
      bottom: bottomRight.y + buffer
    };
  }
  
  screenToWorld(
    screenX: number, 
    screenY: number,
    scale: number,
    translateX: number,
    translateY: number
  ): Position {
    return {
      x: (screenX - translateX) / scale,
      y: (screenY - translateY) / scale
    };
  }
}
```

**LOD（细节层次）**:
```typescript
export class LODManager {
  updateLOD(scale: number): void {
    for (const window of this.windows.values()) {
      const element = document.getElementById(`window-${window.id}`);
      if (!element) continue;
      
      // 移除旧LOD类
      element.classList.remove('lod-minimal', 'lod-simple', 'lod-full');
      
      // 根据缩放级别添加LOD类
      if (scale < 0.3) {
        element.classList.add('lod-minimal');
      } else if (scale < 0.7) {
        element.classList.add('lod-simple');
      } else {
        element.classList.add('lod-full');
      }
    }
  }
}
```

---

### 10.2 按需加载

**组件懒加载**:
```typescript
// 懒加载大型组件
const EditPanel = defineAsyncComponent(() => 
  import('./components/EditPanel.vue')
);

const Settings = defineAsyncComponent(() =>
  import('./components/Settings.vue')
);
```

**插件按需加载**（通过微内核）:
```typescript
// 只在需要时加载插件
async loadEditorPlugin(cardType: string): Promise<void> {
  const response = await this.core.request({
    service: "plugin.load",
    payload: {
      pluginType: "editor",
      cardType
    }
  });
  
  // 插件加载后可用
  this.currentEditorPlugin = response.plugin;
}
```

---

### 10.3 缓存策略

```typescript
export class CacheManager {
  private core: Core;
  private cache = new WeakMap<object, CachedData>();
  
  /**
   * 缓存渲染结果
   */
  cacheRenderResult(window: Window, result: any): void {
    this.cache.set(window, result);
  }
  
  /**
   * 获取缓存
   */
  getCachedResult(window: Window): any | null {
    return this.cache.get(window) || null;
  }
  
  /**
   * 使用微内核的缓存功能
   */
  async getCachedResource(resourceId: string): Promise<Resource> {
    const response = await this.core.request({
      service: "foundation.cache-manager.get",
      payload: { key: resourceId }
    });
    
    if (response.cached) {
      return response.data;
    }
    
    // 如果没有缓存，获取并缓存
    const resource = await this.fetchResource(resourceId);
    
    await this.core.request({
      service: "foundation.cache-manager.set",
      payload: {
        key: resourceId,
        value: resource,
        ttl: 3600
      }
    });
    
    return resource;
  }
}
```

---

## 11. 错误处理架构

### 11.1 错误类型定义

```typescript
export enum EditorErrorCode {
  // 窗口错误
  WINDOW_NOT_FOUND = 'E_EDITOR_001',
  WINDOW_CREATE_FAILED = 'E_EDITOR_002',
  
  // 坐标错误
  INVALID_COORDINATES = 'E_EDITOR_010',
  
  // 插件错误
  PLUGIN_LOAD_FAILED = 'E_EDITOR_020',
  PLUGIN_NOT_FOUND = 'E_EDITOR_021',
  
  // 文件错误
  FILE_SAVE_FAILED = 'E_EDITOR_030',
  FILE_READ_FAILED = 'E_EDITOR_031',
  
  // 拖拽错误
  DRAG_INVALID_TARGET = 'E_EDITOR_040',
}

export class EditorError extends Error {
  constructor(
    public code: EditorErrorCode,
    message: string,
    public context?: any
  ) {
    super(message);
    this.name = 'EditorError';
  }
}
```

---

### 11.2 错误处理机制

**全局错误边界**:
```vue
<!-- components/ErrorBoundary.vue -->
<template>
  <ErrorBoundary @error="handleError">
    <slot />
  </ErrorBoundary>
</template>

<script setup lang="ts">
import { ErrorBoundary } from '@chips/components';

const handleError = async (error: Error) => {
  // 通过微内核记录错误
  await Core.request({
    service: "foundation.log.write",
    payload: {
      level: "error",
      message: error.message,
      context: {
        stack: error.stack,
        component: 'CardWindow'
      }
    }
  });
  
  // 显示错误提示（使用组件库）
  Message.error(t('error.render_failed'));
};
</script>
```

**异步错误处理**:
```typescript
export class AsyncErrorHandler {
  private core: Core;
  
  async handleAsyncError<T>(
    operation: () => Promise<T>,
    errorMessage: string
  ): Promise<T | null> {
    try {
      return await operation();
    } catch (error) {
      // 记录错误（通过微内核）
      await this.core.request({
        service: "foundation.log.write",
        payload: {
          level: "error",
          message: errorMessage,
          context: { error }
        }
      });
      
      // 显示错误（使用组件库）
      Message.error(errorMessage);
      
      return null;
    }
  }
}
```

---

## 12. 测试架构

### 12.1 测试策略

**单元测试**:
- 测试核心模块（LayoutManager、WindowManager等）
- Mock 微内核调用
- 测试覆盖率 ≥ 90%

**集成测试**:
- 测试模块间协作
- 测试与微内核的集成
- 测试与组件库的集成

**E2E测试**:
- 测试完整用户流程
- 使用 Playwright 或 Spectron

**性能测试**:
- 测试性能指标
- 负载测试（100个窗口）
- 内存泄漏检测

### 12.2 测试示例

```typescript
// tests/WindowManager.test.ts
describe('WindowManager', () => {
  let windowManager: WindowManager;
  let mockCore: MockCore;
  
  beforeEach(() => {
    // Mock 微内核
    mockCore = new MockCore();
    windowManager = new WindowManager(mockCore);
  });
  
  it('should create window through kernel', async () => {
    // Mock 微内核响应
    mockCore.mockResponse('card.read', {
      card: {
        id: 'a1B2c3D4e5',
        metadata: { name: '测试卡片' },
        structure: []
      }
    });
    
    // 创建窗口
    const window = await windowManager.createWindow('a1B2c3D4e5');
    
    // 验证通过微内核调用
    expect(mockCore.requests).toContainEqual({
      service: 'card.read',
      payload: { cardId: 'a1B2c3D4e5', includeContent: true }
    });
    
    // 验证窗口创建
    expect(window).toBeDefined();
    expect(window.fileId).toBe('a1B2c3D4e5');
  });
  
  it('should bring window to front when focused', async () => {
    const win1 = await windowManager.createWindow('card1');
    const win2 = await windowManager.createWindow('card2');
    
    await windowManager.focusWindow(win1.id);
    
    expect(win1.zIndex).toBeGreaterThan(win2.zIndex);
  });
});
```

---

## 13. 构建和部署

### 13.1 构建配置

**Vite配置**:
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import electron from 'vite-plugin-electron';

export default defineConfig({
  plugins: [
    vue(),
    electron({
      main: {
        entry: 'electron/main.ts'
      },
      preload: {
        input: 'electron/preload.ts'
      }
    })
  ],
  
  resolve: {
    alias: {
      '@': '/src',
      '@chips/sdk': '@chips/sdk',
      '@chips/components': '@chips/components'
    }
  },
  
  build: {
    rollupOptions: {
      external: [
        // 外部化薯片模块（由运行时提供）
        '@chips/sdk',
        '@chips/components'
      ]
    }
  }
});
```

---

### 13.2 Electron主进程

```typescript
// electron/main.ts
import { app, BrowserWindow } from 'electron';
import { Core } from '@chips/sdk';

let mainWindow: BrowserWindow | null = null;
let core: Core | null = null;

async function createWindow() {
  // 1. 初始化微内核连接
  core = await Core.initialize({
    appId: "chips.editor",
    version: "2.0.0",
    mode: "desktop"
  });
  
  // 2. 创建浏览器窗口
  mainWindow = new BrowserWindow({
    width: 1440,
    height: 900,
    minWidth: 1280,
    minHeight: 720,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  });
  
  // 3. 加载应用
  if (process.env.NODE_ENV === 'development') {
    mainWindow.loadURL('http://localhost:5173');
  } else {
    mainWindow.loadFile('dist/index.html');
  }
  
  // 4. 处理窗口关闭
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

app.on('ready', createWindow);

app.on('window-all-closed', async () => {
  // 断开微内核连接
  if (core) {
    await core.disconnect();
  }
  
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
```

---

### 13.3 IPC通信

```typescript
// electron/ipc.ts
import { ipcMain } from 'electron';
import { Core } from '@chips/sdk';

export function setupIPC(core: Core) {
  // 转发渲染进程的微内核请求
  ipcMain.handle('kernel-request', async (event, request) => {
    try {
      const response = await core.request(request);
      return response;
    } catch (error) {
      return {
        status: 'error',
        error: {
          code: 'IPC_ERROR',
          message: error.message
        }
      };
    }
  });
  
  // 转发事件订阅
  ipcMain.handle('kernel-subscribe', (event, eventType) => {
    core.event.subscribe(eventType, (eventData) => {
      event.sender.send('kernel-event', { eventType, data: eventData });
    });
  });
}
```

```typescript
// electron/preload.ts
import { contextBridge, ipcRenderer } from 'electron';

// 暴露安全的API给渲染进程
contextBridge.exposeInMainWorld('electronAPI', {
  // 调用微内核
  kernelRequest: (request: any) => {
    return ipcRenderer.invoke('kernel-request', request);
  },
  
  // 订阅事件
  kernelSubscribe: (eventType: string, callback: Function) => {
    ipcRenderer.on('kernel-event', (event, data) => {
      if (data.eventType === eventType) {
        callback(data.data);
      }
    });
  }
});
```

---

## 14. 架构总结

### 14.1 核心架构原则

1. **中心路由原则**: 所有通信通过薯片微内核路由
2. **模块解耦**: 编辑引擎、基础层、插件完全解耦
3. **依赖反转**: 编辑引擎依赖SDK，不直接依赖基础层和插件
4. **功能复用**: 完全使用公共基础层的通用组件
5. **界面统一**: 完全使用薯片组件库构建界面
6. **样式分离**: 界面样式由主题包提供

### 14.2 技术栈集成

```
Vue 3 + TypeScript
  ↓ 使用
@chips/components（薯片组件库）
  ↓ 通过
@chips/sdk（薯片SDK）
  ↓ 调用
Chips Core（薯片微内核）
  ↓ 路由到
Chips Foundation（公共基础层）
Plugin System（插件系统）
```

### 14.3 数据流向

```
用户 → Vue组件 → Pinia Store → Service层 → SDK → 微内核 → 基础层/插件
                                                           ↓
用户 ← Vue响应式 ← Pinia State ← Service ← SDK ← 微内核 ← 执行结果
```

### 14.4 架构优势

- **高度模块化**: 每个模块独立开发和测试
- **易于维护**: 清晰的职责分离
- **可扩展性**: 通过插件系统扩展功能
- **可替换性**: 模块可以独立替换
- **高性能**: 优化策略完善
- **类型安全**: TypeScript 全栈类型检查

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-31  
**状态**: ✅ 生效
