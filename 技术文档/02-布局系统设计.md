# 卡片编辑引擎 - 布局系统设计

## 1. 布局系统概述

### 1.1 系统目标

布局系统是编辑引擎的核心子系统,负责管理多种布局模式的加载、切换和运行。系统设计目标:

- **插件化**: 布局作为插件动态加载
- **可扩展**: 第三方可开发新布局
- **无缝切换**: 布局间平滑切换,数据保持一致
- **隔离性**: 布局插件相互独立,互不干扰
- **高性能**: 布局切换快速,运行流畅

### 1.2 核心概念

**布局插件 (Layout Plugin)**:
- 独立的代码模块
- 实现标准接口
- 定义窗口组织方式
- 提供特定交互模式

**布局容器 (Layout Container)**:
- 布局插件的挂载点
- 提供渲染区域
- 隔离插件样式和脚本

**布局上下文 (Layout Context)**:
- 引擎提供给布局的 API
- 布局与引擎通信的桥梁
- 访问核心功能的接口

## 2. 布局插件接口

### 2.1 插件元数据

```typescript
interface LayoutPluginManifest {
  // 基本信息
  id: string;              // 唯一标识符
  name: string;            // 显示名称
  version: string;         // 版本号 (semantic versioning)
  description: string;     // 描述
  author: string;          // 作者
  
  // 依赖信息
  engineVersion: string;   // 要求的引擎版本
  dependencies?: {         // 依赖的其他插件
    [pluginId: string]: string;  // 插件ID: 版本要求
  };
  
  // 功能声明
  features: LayoutFeatures;
  
  // 资源
  icon?: string;           // 图标路径
  thumbnail?: string;      // 缩略图路径
  
  // 入口文件
  main: string;            // 主文件路径
}
```

### 2.2 功能声明

```typescript
interface LayoutFeatures {
  // 基础功能
  supportsMultipleWindows: boolean;     // 支持多窗口
  supportsWindowResize: boolean;        // 支持调整窗口大小
  supportsWindowMove: boolean;          // 支持移动窗口
  
  // 视图功能
  supportsZoom: boolean;                // 支持缩放
  supportsPan: boolean;                 // 支持平移
  supportsFullscreen: boolean;          // 支持全屏
  
  // 组织功能
  supportsTabs: boolean;                // 支持标签页
  supportsDocking: boolean;             // 支持窗口停靠
  supportsSplit: boolean;               // 支持分屏
  
  // 自定义功能
  customFeatures?: string[];            // 自定义功能列表
}
```

### 2.3 插件生命周期接口

```typescript
interface LayoutPlugin {
  // 元数据
  manifest: LayoutPluginManifest;
  
  // 生命周期方法
  
  /**
   * 初始化插件
   * @param context 布局上下文,提供引擎API
   */
  init(context: LayoutContext): void | Promise<void>;
  
  /**
   * 挂载到容器
   * @param container 挂载容器元素
   */
  mount(container: HTMLElement): void | Promise<void>;
  
  /**
   * 从容器卸载
   */
  unmount(): void | Promise<void>;
  
  /**
   * 销毁插件,释放资源
   */
  destroy(): void | Promise<void>;
  
  // 窗口管理
  
  /**
   * 创建窗口
   * @param file 要显示的文件
   * @param options 窗口选项
   */
  createWindow(file: File, options?: WindowOptions): Window;
  
  /**
   * 关闭窗口
   * @param windowId 窗口ID
   */
  closeWindow(windowId: string): void;
  
  /**
   * 聚焦窗口
   * @param windowId 窗口ID
   */
  focusWindow(windowId: string): void;
  
  /**
   * 获取所有窗口
   */
  getWindows(): Window[];
  
  /**
   * 获取焦点窗口
   */
  getFocusedWindow(): Window | null;
  
  // 状态管理
  
  /**
   * 获取布局状态 (用于切换时保存)
   */
  getState(): LayoutState;
  
  /**
   * 恢复布局状态 (用于切换后恢复)
   * @param state 之前保存的状态
   */
  setState(state: LayoutState): void;
  
  // 命令执行
  
  /**
   * 执行布局特定命令
   * @param command 命令名称
   * @param args 命令参数
   */
  executeCommand(command: string, ...args: any[]): any;
}
```

### 2.4 布局上下文接口

```typescript
interface LayoutContext {
  // 引擎API
  engine: {
    // 文件操作
    getFile(fileId: string): Promise<File>;
    getFiles(): File[];
    createFile(type: FileType, name: string): Promise<File>;
    deleteFile(fileId: string): Promise<void>;
    renameFile(fileId: string, newName: string): Promise<void>;
    
    // 渲染
    renderCard(cardId: string, container: HTMLElement): void;
    renderBox(boxId: string, container: HTMLElement): void;
    
    // 编辑面板
    openEditPanel(cardId: string, baseCardId: string): void;
    closeEditPanel(): void;
    
    // 保存
    saveFile(fileId: string, data: any): Promise<void>;
    markDirty(fileId: string): void;
  };
  
  // 事件API
  events: {
    on(event: string, handler: Function): void;
    off(event: string, handler: Function): void;
    emit(event: string, data?: any): void;
  };
  
  // UI API
  ui: {
    showNotification(message: string, type?: NotificationType): void;
    showDialog(options: DialogOptions): Promise<DialogResult>;
    showContextMenu(options: ContextMenuOptions): void;
  };
  
  // 配置API
  config: {
    get(key: string): any;
    set(key: string, value: any): void;
  };
}
```

## 3. 布局管理器实现

### 3.1 类设计

```typescript
class LayoutManager {
  private layouts: Map<string, LayoutPluginInfo>;      // 已加载的布局信息
  private currentLayout: LayoutPlugin | null;          // 当前布局实例
  private layoutContainer: HTMLElement;                // 布局容器元素
  private context: LayoutContext;                      // 布局上下文
  private savedStates: Map<string, LayoutState>;       // 保存的布局状态
  
  constructor(container: HTMLElement, context: LayoutContext) {
    this.layoutContainer = container;
    this.context = context;
    this.layouts = new Map();
    this.savedStates = new Map();
  }
  
  /**
   * 扫描并加载所有布局插件
   */
  async scanLayouts(): Promise<void> {
    // 扫描布局插件目录
    const layoutDirs = await this.getLayoutDirectories();
    
    for (const dir of layoutDirs) {
      try {
        // 读取 manifest.json
        const manifest = await this.loadManifest(dir);
        
        // 验证插件
        this.validateManifest(manifest);
        
        // 保存插件信息
        this.layouts.set(manifest.id, {
          manifest,
          path: dir,
          loaded: false,
        });
      } catch (error) {
        console.error(`Failed to load layout from ${dir}:`, error);
      }
    }
  }
  
  /**
   * 获取所有已安装的布局
   */
  getLayouts(): LayoutInfo[] {
    return Array.from(this.layouts.values()).map(info => ({
      id: info.manifest.id,
      name: info.manifest.name,
      description: info.manifest.description,
      icon: info.manifest.icon,
      features: info.manifest.features,
    }));
  }
  
  /**
   * 获取当前布局
   */
  getCurrentLayout(): LayoutPlugin | null {
    return this.currentLayout;
  }
  
  /**
   * 切换布局
   */
  async switchLayout(layoutId: string): Promise<void> {
    // 1. 保存当前布局状态
    if (this.currentLayout) {
      const state = this.currentLayout.getState();
      this.savedStates.set(this.currentLayout.manifest.id, state);
    }
    
    // 2. 卸载当前布局
    if (this.currentLayout) {
      await this.unloadCurrentLayout();
    }
    
    // 3. 加载新布局
    const newLayout = await this.loadLayout(layoutId);
    
    // 4. 挂载新布局
    await newLayout.mount(this.layoutContainer);
    
    // 5. 恢复状态(如果有)
    const savedState = this.savedStates.get(layoutId);
    if (savedState) {
      newLayout.setState(savedState);
    }
    
    // 6. 设置为当前布局
    this.currentLayout = newLayout;
    
    // 7. 触发事件
    this.context.events.emit('layout:changed', { layoutId });
  }
  
  /**
   * 加载布局插件
   */
  private async loadLayout(layoutId: string): Promise<LayoutPlugin> {
    const info = this.layouts.get(layoutId);
    if (!info) {
      throw new Error(`Layout ${layoutId} not found`);
    }
    
    // 如果已加载,返回缓存实例(或重新创建)
    // 这里简化处理,每次都创建新实例
    
    // 1. 加载插件代码
    const PluginClass = await this.loadPluginCode(info.path, info.manifest.main);
    
    // 2. 创建插件实例
    const plugin = new PluginClass();
    
    // 3. 验证插件实现了必要接口
    this.validatePlugin(plugin);
    
    // 4. 初始化插件
    await plugin.init(this.context);
    
    info.loaded = true;
    
    return plugin;
  }
  
  /**
   * 卸载当前布局
   */
  private async unloadCurrentLayout(): Promise<void> {
    if (!this.currentLayout) return;
    
    // 1. 卸载
    await this.currentLayout.unmount();
    
    // 2. 销毁
    await this.currentLayout.destroy();
    
    // 3. 清空容器
    this.layoutContainer.innerHTML = '';
    
    // 4. 清除引用
    this.currentLayout = null;
  }
  
  /**
   * 加载插件代码
   */
  private async loadPluginCode(pluginPath: string, mainFile: string): Promise<any> {
    // 在 Electron 中可以使用 require 或动态 import
    // 这里使用动态 import
    const modulePath = path.join(pluginPath, mainFile);
    const module = await import(modulePath);
    return module.default || module;
  }
  
  /**
   * 验证 manifest
   */
  private validateManifest(manifest: LayoutPluginManifest): void {
    if (!manifest.id || !manifest.name || !manifest.version) {
      throw new Error('Invalid manifest: missing required fields');
    }
    
    // 验证版本兼容性
    if (!this.isVersionCompatible(manifest.engineVersion)) {
      throw new Error(`Engine version mismatch: required ${manifest.engineVersion}`);
    }
    
    // 验证依赖
    if (manifest.dependencies) {
      for (const [depId, depVersion] of Object.entries(manifest.dependencies)) {
        if (!this.isDependencyMet(depId, depVersion)) {
          throw new Error(`Dependency not met: ${depId} ${depVersion}`);
        }
      }
    }
  }
  
  /**
   * 验证插件实现
   */
  private validatePlugin(plugin: any): void {
    const requiredMethods = [
      'init', 'mount', 'unmount', 'destroy',
      'createWindow', 'closeWindow', 'focusWindow',
      'getWindows', 'getState', 'setState',
    ];
    
    for (const method of requiredMethods) {
      if (typeof plugin[method] !== 'function') {
        throw new Error(`Plugin missing required method: ${method}`);
      }
    }
  }
  
  /**
   * 检查版本兼容性
   */
  private isVersionCompatible(requiredVersion: string): boolean {
    // 使用 semver 库进行版本比较
    const currentVersion = this.context.config.get('engineVersion');
    return semver.satisfies(currentVersion, requiredVersion);
  }
  
  /**
   * 检查依赖是否满足
   */
  private isDependencyMet(pluginId: string, requiredVersion: string): boolean {
    const plugin = this.layouts.get(pluginId);
    if (!plugin) return false;
    return semver.satisfies(plugin.manifest.version, requiredVersion);
  }
}
```

### 3.2 布局切换流程

```
┌─────────────────────────────────────┐
│  用户触发布局切换                    │
└────────────┬────────────────────────┘
             ↓
┌────────────────────────────────────┐
│  1. 保存当前布局状态                │
│     - 窗口位置和大小                │
│     - 打开的文件                    │
│     - 视图状态                      │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  2. 卸载当前布局                    │
│     - 调用 unmount()                │
│     - 调用 destroy()                │
│     - 清空布局容器                  │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  3. 加载新布局插件                  │
│     - 读取插件代码                  │
│     - 创建插件实例                  │
│     - 验证插件接口                  │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  4. 初始化新布局                    │
│     - 调用 init(context)            │
│     - 传递引擎API                   │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  5. 挂载新布局                      │
│     - 调用 mount(container)         │
│     - 渲染布局界面                  │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  6. 恢复状态                        │
│     - 重新打开文件                  │
│     - 恢复窗口(如适用)              │
│     - 调用 setState()               │
└────────────┬───────────────────────┘
             ↓
┌────────────────────────────────────┐
│  7. 完成切换                        │
│     - 触发 layout:changed 事件      │
│     - 更新UI                        │
└─────────────────────────────────────┘
```

### 3.3 状态保存和恢复

```typescript
interface LayoutState {
  // 打开的文件列表
  openedFiles: string[];
  
  // 当前文件
  currentFileId: string | null;
  
  // 布局特定状态
  layoutSpecific: any;
}

// 无限画布布局的状态
interface CanvasLayoutState extends LayoutState {
  layoutSpecific: {
    // 桌面变换
    transform: {
      scale: number;
      translateX: number;
      translateY: number;
    };
    
    // 窗口列表
    windows: Array<{
      id: string;
      fileId: string;
      position: { x: number; y: number };
      size: { width: number; height: number };
      state: 'expanded' | 'collapsed' | 'cover';
      zIndex: number;
    }>;
    
    // 工具窗口状态
    toolWindows: {
      [toolId: string]: {
        visible: boolean;
        position?: { x: number; y: number };
        size?: { width: number; height: number };
      };
    };
  };
}

// 工作台布局的状态
interface WorkbenchLayoutState extends LayoutState {
  layoutSpecific: {
    // 侧栏状态
    sidebar: {
      left: { visible: boolean; width: number };
      right: { visible: boolean; width: number };
      bottom: { visible: boolean; height: number };
    };
    
    // 标签页
    tabs: Array<{
      fileId: string;
      active: boolean;
    }>;
    
    // 分屏状态
    splits: Array<{
      orientation: 'horizontal' | 'vertical';
      sizes: number[];
      files: string[];
    }>;
  };
}
```

## 4. 布局插件开发

### 4.1 插件项目结构

```
my-layout-plugin/
├── manifest.json           # 插件元数据
├── index.ts               # 插件入口
├── components/            # 组件目录
│   ├── LayoutContainer.tsx
│   ├── WindowComponent.tsx
│   └── ...
├── styles/                # 样式目录
│   └── layout.css
├── assets/                # 资源目录
│   └── icon.png
├── package.json           # 依赖声明
└── README.md              # 文档
```

### 4.2 插件开发示例

```typescript
// manifest.json
{
  "id": "my-custom-layout",
  "name": "My Custom Layout",
  "version": "1.0.0",
  "description": "A custom layout plugin",
  "author": "Your Name",
  "engineVersion": "^1.0.0",
  "main": "index.js",
  "features": {
    "supportsMultipleWindows": true,
    "supportsWindowResize": true,
    "supportsWindowMove": true,
    "supportsZoom": false,
    "supportsPan": false,
    "supportsFullscreen": true,
    "supportsTabs": true,
    "supportsDocking": false,
    "supportsSplit": false
  }
}

// index.ts
import { LayoutPlugin, LayoutContext, Window } from '@chips/engine';

class MyCustomLayout implements LayoutPlugin {
  manifest = require('./manifest.json');
  
  private context: LayoutContext;
  private container: HTMLElement;
  private windows: Map<string, Window> = new Map();
  
  async init(context: LayoutContext): Promise<void> {
    this.context = context;
    
    // 订阅事件
    context.events.on('file:opened', this.onFileOpened);
  }
  
  async mount(container: HTMLElement): Promise<void> {
    this.container = container;
    
    // 渲染布局界面
    this.render();
  }
  
  async unmount(): Promise<void> {
    // 清理事件监听
    this.context.events.off('file:opened', this.onFileOpened);
    
    // 关闭所有窗口
    for (const windowId of this.windows.keys()) {
      this.closeWindow(windowId);
    }
  }
  
  async destroy(): Promise<void> {
    // 释放资源
    this.windows.clear();
  }
  
  createWindow(file: File, options?: WindowOptions): Window {
    const window: Window = {
      id: generateId(),
      type: 'card',
      fileId: file.id,
      // ... 其他属性
    };
    
    this.windows.set(window.id, window);
    
    // 渲染窗口
    this.renderWindow(window);
    
    return window;
  }
  
  closeWindow(windowId: string): void {
    const window = this.windows.get(windowId);
    if (!window) return;
    
    // 从 DOM 中移除
    this.removeWindowElement(windowId);
    
    // 从map中删除
    this.windows.delete(windowId);
  }
  
  focusWindow(windowId: string): void {
    // 实现窗口聚焦逻辑
  }
  
  getWindows(): Window[] {
    return Array.from(this.windows.values());
  }
  
  getFocusedWindow(): Window | null {
    // 返回当前焦点窗口
    return null;
  }
  
  getState(): LayoutState {
    return {
      openedFiles: Array.from(this.windows.values()).map(w => w.fileId),
      currentFileId: this.getFocusedWindow()?.fileId || null,
      layoutSpecific: {
        // 保存布局特定状态
      },
    };
  }
  
  setState(state: LayoutState): void {
    // 恢复状态
    for (const fileId of state.openedFiles) {
      this.context.engine.getFile(fileId).then(file => {
        this.createWindow(file);
      });
    }
  }
  
  executeCommand(command: string, ...args: any[]): any {
    // 执行命令
    switch (command) {
      case 'toggleFullscreen':
        return this.toggleFullscreen();
      // ... 其他命令
    }
  }
  
  private render(): void {
    // 使用 React/Vue 等框架渲染界面
    // 或原生 DOM 操作
  }
  
  private renderWindow(window: Window): void {
    // 渲染窗口内容
  }
  
  private onFileOpened = (file: File) => {
    this.createWindow(file);
  };
  
  private toggleFullscreen(): void {
    // 实现全屏切换
  }
}

export default MyCustomLayout;
```

### 4.3 使用 React 开发布局

```typescript
import React from 'react';
import ReactDOM from 'react-dom';
import { LayoutPlugin, LayoutContext } from '@chips/engine';

// 布局组件
const MyLayoutComponent: React.FC<{
  context: LayoutContext;
  windows: Window[];
  onCreateWindow: (file: File) => void;
  onCloseWindow: (windowId: string) => void;
}> = ({ context, windows, onCreateWindow, onCloseWindow }) => {
  return (
    <div className="my-layout">
      <Sidebar files={context.engine.getFiles()} onOpenFile={onCreateWindow} />
      <MainArea windows={windows} onCloseWindow={onCloseWindow} />
    </div>
  );
};

// 布局插件类
class MyReactLayout implements LayoutPlugin {
  // ... manifest 和属性
  
  private reactRoot: any;
  
  async mount(container: HTMLElement): Promise<void> {
    this.container = container;
    
    // 使用 React 18 的 createRoot
    this.reactRoot = ReactDOM.createRoot(container);
    this.render();
  }
  
  async unmount(): Promise<void> {
    this.reactRoot.unmount();
  }
  
  private render(): void {
    this.reactRoot.render(
      <MyLayoutComponent
        context={this.context}
        windows={Array.from(this.windows.values())}
        onCreateWindow={this.createWindow}
        onCloseWindow={this.closeWindow}
      />
    );
  }
  
  // 当状态改变时重新渲染
  private updateUI(): void {
    this.render();
  }
  
  createWindow(file: File, options?: WindowOptions): Window {
    const window = super.createWindow(file, options);
    this.updateUI();  // 触发重新渲染
    return window;
  }
  
  closeWindow(windowId: string): void {
    super.closeWindow(windowId);
    this.updateUI();  // 触发重新渲染
  }
}
```

## 5. 布局隔离

### 5.1 样式隔离

**问题**: 不同布局的样式可能冲突

**解决方案**:

**1. CSS Modules**:
```typescript
import styles from './layout.module.css';

<div className={styles.container}>
  ...
</div>
```

**2. CSS-in-JS**:
```typescript
import styled from 'styled-components';

const Container = styled.div`
  /* styles */
`;
```

**3. 命名空间**:
```css
.my-layout-container {
  /* 所有样式都在此命名空间下 */
}
```

### 5.2 脚本隔离

**问题**: 布局插件可能污染全局作用域

**解决方案**:

**1. 模块化**: 使用 ES6 模块,避免全局变量

**2. 沙箱**: 在独立的上下文中运行插件(如 iframe, Web Workers)

**3. 命名空间**: 全局变量使用插件ID作为前缀

## 6. 性能优化

### 6.1 懒加载

```typescript
class LayoutManager {
  // 只在需要时加载布局插件代码
  private async loadLayout(layoutId: string): Promise<LayoutPlugin> {
    // 使用动态 import
    const module = await import(`./layouts/${layoutId}`);
    return new module.default();
  }
}
```

### 6.2 缓存

```typescript
class LayoutManager {
  private pluginCache: Map<string, LayoutPlugin> = new Map();
  
  private async loadLayout(layoutId: string): Promise<LayoutPlugin> {
    // 检查缓存
    if (this.pluginCache.has(layoutId)) {
      return this.pluginCache.get(layoutId)!;
    }
    
    // 加载并缓存
    const plugin = await this.doLoadLayout(layoutId);
    this.pluginCache.set(layoutId, plugin);
    return plugin;
  }
}
```

### 6.3 平滑切换

```typescript
async switchLayout(layoutId: string): Promise<void> {
  // 显示加载指示器
  this.showLoadingIndicator();
  
  // 淡出当前布局
  await this.fadeOut(this.layoutContainer);
  
  // 执行切换
  await this.doSwitchLayout(layoutId);
  
  // 淡入新布局
  await this.fadeIn(this.layoutContainer);
  
  // 隐藏加载指示器
  this.hideLoadingIndicator();
}
```

## 7. 错误处理

### 7.1 插件加载失败

```typescript
async loadLayout(layoutId: string): Promise<LayoutPlugin> {
  try {
    return await this.doLoadLayout(layoutId);
  } catch (error) {
    console.error(`Failed to load layout ${layoutId}:`, error);
    
    // 尝试回退到默认布局
    if (layoutId !== DEFAULT_LAYOUT_ID) {
      this.context.ui.showNotification(
        `Failed to load layout "${layoutId}", falling back to default`,
        'error'
      );
      return await this.loadLayout(DEFAULT_LAYOUT_ID);
    }
    
    throw error;
  }
}
```

### 7.2 插件运行时错误

```typescript
class LayoutManager {
  private wrapPluginMethod<T>(method: () => T): T | undefined {
    try {
      return method();
    } catch (error) {
      console.error('Layout plugin error:', error);
      this.context.ui.showNotification(
        'Layout error occurred',
        'error'
      );
      return undefined;
    }
  }
  
  createWindow(file: File, options?: WindowOptions): Window | undefined {
    return this.wrapPluginMethod(() => {
      return this.currentLayout?.createWindow(file, options);
    });
  }
}
```

## 8. 测试

### 8.1 单元测试

```typescript
describe('LayoutManager', () => {
  let manager: LayoutManager;
  let mockContext: LayoutContext;
  
  beforeEach(() => {
    mockContext = createMockContext();
    manager = new LayoutManager(document.createElement('div'), mockContext);
  });
  
  test('should load layout', async () => {
    await manager.scanLayouts();
    const layouts = manager.getLayouts();
    expect(layouts.length).toBeGreaterThan(0);
  });
  
  test('should switch layout', async () => {
    await manager.scanLayouts();
    const layouts = manager.getLayouts();
    await manager.switchLayout(layouts[0].id);
    expect(manager.getCurrentLayout()).toBeDefined();
  });
});
```

### 8.2 集成测试

```typescript
describe('Layout Plugin Integration', () => {
  test('should create and close window', async () => {
    const layout = new MyCustomLayout();
    const context = createRealContext();
    
    await layout.init(context);
    await layout.mount(document.createElement('div'));
    
    const file = await context.engine.getFile('test-file');
    const window = layout.createWindow(file);
    
    expect(window).toBeDefined();
    expect(layout.getWindows()).toContain(window);
    
    layout.closeWindow(window.id);
    expect(layout.getWindows()).not.toContain(window);
  });
});
```

## 9. 总结

布局系统的设计要点:

1. **标准化接口**: 统一的插件接口,保证兼容性
2. **插件化**: 布局作为插件,灵活扩展
3. **状态管理**: 切换时保存和恢复状态
4. **隔离性**: 样式和脚本隔离,避免冲突
5. **性能优化**: 懒加载、缓存、平滑过渡
6. **错误处理**: 完善的错误处理和回退机制
7. **开发友好**: 提供清晰的开发文档和示例

通过良好的布局系统设计,为编辑引擎提供了强大的扩展能力,让不同的使用场景都能找到合适的布局模式。
