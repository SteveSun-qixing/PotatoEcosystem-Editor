# 卡片编辑引擎 - 拖拽系统设计

## 1. 拖拽系统概述

### 1.1 拖拽场景

1. 从卡箱库拖动创建卡片
2. 从文件系统拖入文件
3. 卡片间拖拽嵌套
4. 调整基础卡片顺序
5. 移动窗口
6. 调整窗口大小
7. 平移桌面

### 1.2 技术挑战

- 区分不同的拖拽场景
- 提供实时视觉反馈
- 判断有效的放置目标
- 支持多种输入设备
- 保持高性能

## 2. 拖拽数据结构

```typescript
interface DragSource {
  type: DragSourceType;
  data: any;
  element: HTMLElement;
}

enum DragSourceType {
  CARDBOX_ITEM = 'cardbox-item',     // 卡箱库项目
  FILE_SYSTEM = 'file-system',       // 文件系统文件
  CARD_WINDOW = 'card-window',       // 卡片窗口
  BASE_CARD = 'base-card',          // 基础卡片
  WINDOW_TITLEBAR = 'window-titlebar', // 窗口标题栏
  WINDOW_RESIZE = 'window-resize',   // 调整窗口大小
  DESKTOP = 'desktop',               // 桌面平移
}

interface DropTarget {
  type: DropTargetType;
  element: HTMLElement;
  accepts: DragSourceType[];
  onDrop: (source: DragSource) => void;
  onDragOver?: (source: DragSource) => void;
  onDragLeave?: () => void;
}

enum DropTargetType {
  DESKTOP_BLANK = 'desktop-blank',   // 桌面空白区域
  CARD_WINDOW = 'card-window',       // 卡片窗口
  BOX_WINDOW = 'box-window',        // 箱子窗口
  EDIT_PANEL = 'edit-panel',        // 编辑面板
}
```

## 3. 拖拽处理器实现

```typescript
class DragDropHandler {
  private currentDrag: DragState | null = null;
  private dropTargets: Map<string, DropTarget> = new Map();
  private dragPreview: HTMLElement | null = null;
  
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
    this.setupGlobalListeners();
  }
  
  // ===== 注册拖拽源和目标 =====
  
  registerDropTarget(id: string, target: DropTarget): void {
    this.dropTargets.set(id, target);
  }
  
  unregisterDropTarget(id: string): void {
    this.dropTargets.delete(id);
  }
  
  // ===== 拖拽生命周期 =====
  
  startDrag(source: DragSource, event: MouseEvent | TouchEvent): void {
    this.currentDrag = {
      source,
      startX: this.getClientX(event),
      startY: this.getClientY(event),
      currentX: this.getClientX(event),
      currentY: this.getClientY(event),
      currentTarget: null,
    };
    
    // 创建拖拽预览
    this.createDragPreview(source);
    
    // 触发事件
    this.eventBus.emit('drag:start', this.currentDrag);
  }
  
  private onDragMove = (event: MouseEvent | TouchEvent) => {
    if (!this.currentDrag) return;
    
    event.preventDefault();
    
    const clientX = this.getClientX(event);
    const clientY = this.getClientY(event);
    
    this.currentDrag.currentX = clientX;
    this.currentDrag.currentY = clientY;
    
    // 更新拖拽预览位置
    this.updateDragPreview(clientX, clientY);
    
    // 检测放置目标
    const target = this.detectDropTarget(clientX, clientY);
    
    if (target !== this.currentDrag.currentTarget) {
      // 离开旧目标
      if (this.currentDrag.currentTarget) {
        this.currentDrag.currentTarget.onDragLeave?.();
        this.removeTargetHighlight(this.currentDrag.currentTarget);
      }
      
      // 进入新目标
      if (target) {
        target.onDragOver?.(this.currentDrag.source);
        this.highlightTarget(target);
      }
      
      this.currentDrag.currentTarget = target;
    }
    
    this.eventBus.emit('drag:move', this.currentDrag);
  };
  
  private onDragEnd = (event: MouseEvent | TouchEvent) => {
    if (!this.currentDrag) return;
    
    const target = this.currentDrag.currentTarget;
    
    if (target && this.canDrop(this.currentDrag.source, target)) {
      // 执行放置
      target.onDrop(this.currentDrag.source);
      this.eventBus.emit('drag:drop', { source: this.currentDrag.source, target });
    }
    
    // 清理
    this.removeDragPreview();
    if (target) {
      this.removeTargetHighlight(target);
    }
    
    this.eventBus.emit('drag:end', this.currentDrag);
    this.currentDrag = null;
  };
  
  // ===== 拖拽预览 =====
  
  private createDragPreview(source: DragSource): void {
    this.dragPreview = document.createElement('div');
    this.dragPreview.className = 'drag-preview';
    this.dragPreview.style.position = 'fixed';
    this.dragPreview.style.pointerEvents = 'none';
    this.dragPreview.style.zIndex = '10000';
    this.dragPreview.style.opacity = '0.8';
    
    // 根据拖拽源类型创建预览内容
    switch (source.type) {
      case DragSourceType.CARDBOX_ITEM:
        this.dragPreview.innerHTML = `
          <div class="drag-preview-cardbox">
            <img src="${source.data.icon}" />
            <span>${source.data.name}</span>
          </div>
        `;
        break;
      case DragSourceType.FILE_SYSTEM:
        this.dragPreview.innerHTML = `
          <div class="drag-preview-file">
            <span>${source.data.name}</span>
          </div>
        `;
        break;
      case DragSourceType.CARD_WINDOW:
        // 使用窗口的缩略图或简化版本
        this.dragPreview.innerHTML = `
          <div class="drag-preview-window">
            ${source.data.title}
          </div>
        `;
        break;
    }
    
    document.body.appendChild(this.dragPreview);
  }
  
  private updateDragPreview(x: number, y: number): void {
    if (!this.dragPreview) return;
    
    this.dragPreview.style.left = `${x + 10}px`;
    this.dragPreview.style.top = `${y + 10}px`;
  }
  
  private removeDragPreview(): void {
    if (this.dragPreview) {
      document.body.removeChild(this.dragPreview);
      this.dragPreview = null;
    }
  }
  
  // ===== 目标检测和高亮 =====
  
  private detectDropTarget(x: number, y: number): DropTarget | null {
    // 从最上层开始检测
    const element = document.elementFromPoint(x, y);
    if (!element) return null;
    
    // 查找匹配的放置目标
    for (const [id, target] of this.dropTargets) {
      if (target.element.contains(element)) {
        // 检查是否接受当前拖拽源
        if (this.currentDrag && this.canDrop(this.currentDrag.source, target)) {
          return target;
        }
      }
    }
    
    return null;
  }
  
  private canDrop(source: DragSource, target: DropTarget): boolean {
    return target.accepts.includes(source.type);
  }
  
  private highlightTarget(target: DropTarget): void {
    target.element.classList.add('drop-target-highlight');
  }
  
  private removeTargetHighlight(target: DropTarget): void {
    target.element.classList.remove('drop-target-highlight');
  }
  
  // ===== 事件监听 =====
  
  private setupGlobalListeners(): void {
    document.addEventListener('mousemove', this.onDragMove);
    document.addEventListener('mouseup', this.onDragEnd);
    document.addEventListener('touchmove', this.onDragMove, { passive: false });
    document.addEventListener('touchend', this.onDragEnd);
  }
  
  // ===== 辅助方法 =====
  
  private getClientX(event: MouseEvent | TouchEvent): number {
    return 'touches' in event ? event.touches[0].clientX : event.clientX;
  }
  
  private getClientY(event: MouseEvent | TouchEvent): number {
    return 'touches' in event ? event.touches[0].clientY : event.clientY;
  }
}

interface DragState {
  source: DragSource;
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  currentTarget: DropTarget | null;
}
```

## 4. 具体场景实现

### 4.1 从卡箱库拖动

```typescript
class CardboxLibrary {
  private dragDropHandler: DragDropHandler;
  
  private setupDragHandlers(): void {
    const items = this.container.querySelectorAll('.cardbox-item');
    
    items.forEach(item => {
      item.addEventListener('mousedown', (e) => {
        const cardType = item.dataset.cardType;
        const cardName = item.dataset.cardName;
        const cardIcon = item.dataset.cardIcon;
        
        this.dragDropHandler.startDrag({
          type: DragSourceType.CARDBOX_ITEM,
          data: { cardType, name: cardName, icon: cardIcon },
          element: item as HTMLElement,
        }, e);
      });
    });
  }
}

// 注册桌面作为放置目标
class InfiniteCanvasLayout {
  private setupDropTargets(): void {
    this.dragDropHandler.registerDropTarget('desktop-blank', {
      type: DropTargetType.DESKTOP_BLANK,
      element: this.desktopElement,
      accepts: [DragSourceType.CARDBOX_ITEM, DragSourceType.FILE_SYSTEM],
      onDrop: (source) => {
        if (source.type === DragSourceType.CARDBOX_ITEM) {
          // 在鼠标位置创建新卡片
          this.createCardFromCardboxItem(source.data);
        }
      },
    });
  }
}
```

### 4.2 从文件系统拖入

```typescript
class InfiniteCanvasLayout {
  private setupFileDropHandlers(): void {
    this.container.addEventListener('drop', async (e) => {
      e.preventDefault();
      
      const files = Array.from(e.dataTransfer?.files || []);
      
      for (const file of files) {
        // 识别文件类型
        const fileType = await this.recognizeFileType(file);
        
        // 创建对应的卡片
        await this.createCardFromFile(file, fileType, {
          x: e.clientX,
          y: e.clientY,
        });
      }
    });
    
    this.container.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer!.dropEffect = 'copy';
    });
  }
}
```

### 4.3 调整基础卡片顺序

```typescript
class CardWindow {
  private setupCardReorder(): void {
    const baseCards = this.container.querySelectorAll('.base-card');
    
    baseCards.forEach((card, index) => {
      card.addEventListener('mousedown', (e) => {
        if (!this.isEditMode) return;
        
        this.dragDropHandler.startDrag({
          type: DragSourceType.BASE_CARD,
          data: { cardId: card.dataset.cardId, index },
          element: card as HTMLElement,
        }, e);
      });
    });
    
    // 注册插入位置目标
    baseCards.forEach((card, index) => {
      this.dragDropHandler.registerDropTarget(`base-card-${index}`, {
        type: DropTargetType.CARD_WINDOW,
        element: card as HTMLElement,
        accepts: [DragSourceType.BASE_CARD, DragSourceType.CARDBOX_ITEM],
        onDragOver: (source) => {
          // 显示插入指示线
          this.showInsertIndicator(index);
        },
        onDragLeave: () => {
          this.hideInsertIndicator();
        },
        onDrop: (source) => {
          if (source.type === DragSourceType.BASE_CARD) {
            // 移动基础卡片
            this.reorderBaseCard(source.data.index, index);
          } else if (source.type === DragSourceType.CARDBOX_ITEM) {
            // 插入新基础卡片
            this.insertBaseCard(source.data.cardType, index);
          }
        },
      });
    });
  }
  
  private showInsertIndicator(index: number): void {
    // 显示蓝色插入线
    const indicator = document.createElement('div');
    indicator.className = 'insert-indicator';
    // 插入到对应位置
  }
}
```

## 5. 推荐的开源拖拽库

### 5.1 React DnD

```bash
npm install react-dnd react-dnd-html5-backend
```

```typescript
import { useDrag, useDrop } from 'react-dnd';

const CardboxItem: React.FC = ({ cardType, name, icon }) => {
  const [{ isDragging }, drag] = useDrag({
    type: 'CARDBOX_ITEM',
    item: { cardType, name, icon },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });
  
  return (
    <div ref={drag} style={{ opacity: isDragging ? 0.5 : 1 }}>
      <img src={icon} />
      <span>{name}</span>
    </div>
  );
};

const DesktopBlank: React.FC = () => {
  const [, drop] = useDrop({
    accept: ['CARDBOX_ITEM', 'FILE_SYSTEM'],
    drop: (item, monitor) => {
      const offset = monitor.getClientOffset();
      createCard(item, offset);
    },
  });
  
  return <div ref={drop} className="desktop-blank" />;
};
```

### 5.2 dnd-kit

```bash
npm install @dnd-kit/core @dnd-kit/sortable
```

### 5.3 interact.js

```bash
npm install interactjs
```

特点: 支持拖拽、调整大小、手势,跨平台

## 6. 性能优化

### 6.1 节流

```typescript
class DragDropHandler {
  private throttledOnDragMove = throttle(this.onDragMove, 16); // 60fps
}
```

### 6.2 虚拟化拖拽

```typescript
// 对于大量可拖拽项目,使用虚拟化
class CardboxLibrary {
  render() {
    return (
      <VirtualList
        items={this.items}
        renderItem={(item) => (
          <DraggableCardboxItem key={item.id} {...item} />
        )}
      />
    );
  }
}
```

## 7. 跨平台适配

### 7.1 触摸支持

```typescript
class DragDropHandler {
  private setupTouchSupport(): void {
    document.addEventListener('touchstart', (e) => {
      // 长按开始拖拽
      const touch = e.touches[0];
      this.touchTimeout = setTimeout(() => {
        this.startDrag(/* ... */, e);
      }, 500);
    });
    
    document.addEventListener('touchend', () => {
      clearTimeout(this.touchTimeout);
    });
  }
}
```

### 7.2 触摸板手势

```typescript
// 区分触摸板的滚动和拖拽
window.addEventListener('wheel', (e) => {
  if (e.ctrlKey) {
    // 缩放手势
  } else {
    // 滚动/平移
  }
});
```

## 8. 视觉反馈设计

### 8.1 CSS 样式

```css
/* 拖拽预览 */
.drag-preview {
  position: fixed;
  pointer-events: none;
  z-index: 10000;
  opacity: 0.8;
  transform: rotate(-3deg);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* 放置目标高亮 */
.drop-target-highlight {
  outline: 2px solid #4A90E2;
  outline-offset: 2px;
  background: rgba(74, 144, 226, 0.1);
}

/* 插入指示线 */
.insert-indicator {
  position: absolute;
  left: 0;
  right: 0;
  height: 3px;
  background: #4A90E2;
  box-shadow: 0 0 4px rgba(74, 144, 226, 0.6);
  z-index: 1000;
}

/* 无效放置区域 */
.drop-invalid {
  cursor: not-allowed !important;
}

.drop-invalid .drag-preview {
  opacity: 0.4;
  filter: grayscale(1);
}
```

## 9. 总结

拖拽系统的设计要点:

1. **场景识别**: 准确判断拖拽场景和意图
2. **视觉反馈**: 实时、清晰的视觉反馈
3. **目标检测**: 准确识别有效的放置目标
4. **跨平台支持**: 鼠标、触摸板、触摸屏
5. **性能优化**: 节流、虚拟化
6. **使用成熟库**: React DnD, dnd-kit等

通过完善的拖拽系统,为用户提供直观、流畅的交互体验。
