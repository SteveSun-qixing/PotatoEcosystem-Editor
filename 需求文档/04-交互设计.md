# 卡片编辑引擎 - 交互设计

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 交互设计原则

### 1.1 架构一致性

**微内核路由原则**:
- 所有交互最终通过微内核路由执行
- 用户操作 → 界面事件 → 引擎处理 → 微内核调用 → 模块执行
- 保证架构的一致性和可维护性

**模块解耦原则**:
- 交互逻辑与具体实现分离
- 界面组件与数据处理分离
- 通过标准接口通信

### 1.2 直观性

- 操作方式符合用户直觉
- 拖拽即可完成大多数操作
- 界面元素含义清晰
- 减少学习成本
- 使用薯片组件库提供一致的交互体验

### 1.3 即时反馈

- 所有操作提供视觉反馈
- 拖动时显示预览和指示
- 操作结果立即可见
- 错误及时提示
- 使用组件库的反馈组件（Message、Notification等）

### 1.4 一致性

- 相同操作在不同场景下行为一致
- 视觉风格统一（由主题包提供）
- 交互模式可预测
- 术语使用一致
- 遵循薯片生态的设计规范

### 1.5 容错性

- 重要操作需要确认
- 支持撤销/重做
- 自动保存防止丢失
- 友好的错误提示
- 使用组件库的 Modal 和 Alert 组件

### 1.6 效率优先

- 减少操作步骤
- 提供快捷键
- 批量操作支持
- 智能默认值
- 通过微内核的批量请求优化性能

---

## 2. 鼠标交互

### 2.1 点击操作

#### 2.1.1 单击

**在卡片窗口上**:
- **标题栏**: 聚焦窗口，通过微内核更新焦点状态，窗口置于最前
- **基础卡片（编辑模式）**: 选中卡片，通过微内核加载编辑组件插件，打开编辑面板
- **基础卡片（查看模式）**: 与卡片内容交互（如播放视频，通过基础层组件）
- **按钮**: 执行对应功能，通过微内核路由调用

**在文件管理器中**（使用组件库的 List/Tree 组件）:
- **文件项**: 选中文件（已打开则通过引擎聚焦窗口）
- **空白区域**: 取消选择

**在卡箱库中**（使用组件库的 Grid 组件）:
- **卡片类型**: 选中（准备拖动或双击创建）

**技术实现**:
```typescript
// 点击卡片窗口标题栏
onClick = async () => {
  await Core.request({
    service: "editor.window.focus",
    payload: { windowId: this.windowId }
  });
};
```

---

#### 2.1.2 双击

**在卡片窗口上**:
- **卡片名称**: 进入编辑模式（Input 组件），失去焦点后通过微内核保存（`card.update`）
- **基础卡片**: 快速打开编辑面板（通过微内核加载编辑组件）

**在文件管理器中**:
- **文件项**: 通过微内核打开文件（`card.read`）
- **文件夹**: 展开/折叠（Tree 组件功能）

**在桌面上**:
- **封面窗口**: 展开为完整卡片，关闭封面窗口，创建完整卡片窗口

**在卡箱库中**:
- **卡片类型**: 在鼠标位置快速创建（通过微内核 `card.create`）

---

#### 2.1.3 右键点击

**在卡片窗口上**:
- **标题栏**: 显示窗口操作菜单（使用 Menu 组件）
- **基础卡片**: 显示卡片操作菜单（复制、删除、移动等，通过微内核执行）

**在文件管理器中**:
- **文件项**: 显示文件操作菜单（打开、重命名、删除、导出等）
- **空白区域**: 显示创建菜单

**在桌面上**:
- **空白区域**: 显示桌面菜单（新建、粘贴、布局设置等）

**技术实现**:
```typescript
// 右键菜单
onContextMenu = (e) => {
  e.preventDefault();
  showContextMenu({
    items: [
      { label: t('common.delete'), onClick: () => this.delete() },
      { label: t('common.rename'), onClick: () => this.rename() }
    ],
    position: { x: e.clientX, y: e.clientY }
  });
};
```

---

### 2.2 拖动操作

#### 2.2.1 标准拖动流程

**操作流程**:
1. 鼠标移到可拖动元素上
2. 鼠标指针变为可拖动图标（手型）
3. 按下鼠标左键，通过基础层的 DragDropSystem 开始拖拽
4. 移动鼠标，元素跟随
5. DragDropSystem 计算有效目标区域
6. 到达目标位置，目标高亮
7. 松开鼠标，DragDropSystem 触发 drop 事件
8. 引擎通过微内核执行相应操作

**视觉反馈**（使用组件库样式）:
- 被拖动元素半透明跟随鼠标
- 有效目标区域高亮显示
- 插入位置显示指示线
- 无效区域鼠标显示禁止符号

**技术实现**:
```typescript
// 注册拖拽源
await Core.request({
  service: "foundation.drag-drop.register-source",
  payload: {
    sourceId: "card-type-markdown",
    type: "cardbox-item",
    data: { cardType: "MarkdownCard" },
    onDragStart: this.handleDragStart,
    onDragEnd: this.handleDragEnd
  }
});

// 注册放置目标
await Core.request({
  service: "foundation.drag-drop.register-target",
  payload: {
    targetId: "desktop-canvas",
    accepts: ["cardbox-item", "file-system"],
    onDrop: this.handleDrop
  }
});
```

---

#### 2.2.2 从卡箱库拖动

**拖动基础卡片类型到桌面空白区域**:
1. 鼠标移到卡片类型图标上
2. 按下左键并拖动
3. DragDropSystem 处理拖拽事件
4. 图标跟随鼠标移动
5. 桌面空白区域高亮，显示"在此创建新卡片"提示（Tooltip 组件）
6. 松开鼠标
7. 引擎通过微内核创建卡片（`card.create`）
8. 通过微内核添加基础卡片（`card.add_base_card`）
9. 在释放位置创建窗口

**拖动到已有卡片窗口**:
1. 拖动过程同上
2. 移动到卡片窗口上方
3. 卡片窗口高亮边框
4. 鼠标在基础卡片上方/下方区域，显示插入指示线
5. 松开鼠标
6. 引擎通过微内核添加基础卡片到指定位置（`card.add_base_card`）
7. 渲染器实时更新显示

---

#### 2.2.3 从文件系统拖入

**拖动文件到桌面**:
1. 从操作系统文件管理器拖动文件
2. 编辑引擎接收 dragenter 事件
3. 引擎通过微内核识别文件类型（`file.identify`）
4. 根据文件类型显示预期创建的卡片类型
5. 桌面空白区域高亮
6. 松开鼠标
7. 引擎通过微内核创建相应卡片
8. 通过微内核保存资源文件（`resource.write`）
9. 创建窗口并显示内容（通过基础层组件）

**拖动到已有卡片**:
1. 拖动过程中通过微内核识别文件
2. 目标卡片高亮
3. 显示插入位置指示线
4. 松开鼠标
5. 引擎通过微内核添加基础卡片
6. 文件保存到卡片资源中

**拖动到编辑面板**:
1. 编辑面板高亮
2. 显示"添加到当前卡片"提示
3. 松开鼠标
4. 文件数据传递给编辑组件插件
5. 插件决定如何处理
6. 通过引擎API保存（引擎通过微内核）

---

#### 2.2.4 卡片间拖拽

**拖动整个卡片窗口到另一个卡片**:
1. 按住卡片标题栏或使用特殊拖动手柄
2. 拖动到目标卡片窗口
3. 目标卡片高亮，显示"嵌套到此卡片"提示
4. 松开鼠标
5. 引擎通过微内核读取被拖动卡片数据
6. 通过微内核将卡片嵌套到目标卡片（`card.add_base_card`，类型为嵌套卡片）
7. 被拖动卡片窗口关闭
8. 目标卡片中显示嵌套卡片
9. 嵌套卡片通过特殊渲染组件显示
10. 所有操作通过微内核保存

**修饰键**:
- 无修饰键：移动（嵌套后原卡片删除）
- Ctrl/Cmd：复制（嵌套后原卡片保留）

---

#### 2.2.5 调整基础卡片顺序

**前提**: 卡片处于编辑模式

**操作流程**:
1. 鼠标移到基础卡片上，显示拖动手柄
2. 按下并拖动
3. 通过基础层的 DragDropSystem 处理
4. 其他基础卡片自动调整位置让出空间（CSS过渡动画）
5. 蓝色插入线显示插入位置
6. 松开鼠标，卡片移动到新位置
7. 引擎通过微内核更新结构（`card.update`）
8. 自动保存新顺序

**视觉反馈**:
- 被拖动卡片显示阴影，略微放大
- 其他卡片平滑移动（使用 CSS transition）
- 插入线清晰显示

---

#### 2.2.6 移动窗口

**拖动标题栏**:
1. 鼠标移到窗口标题栏
2. 按下并拖动
3. 通过基础层的 DragDropSystem 处理
4. 窗口跟随鼠标移动
5. 松开鼠标，窗口停在新位置
6. 引擎通过微内核保存窗口位置

**行为差异**:
- **卡片/箱子窗口**: 在桌面层移动，坐标相对于桌面（世界坐标）
- **工具窗口**: 在窗口层移动，坐标相对于屏幕（屏幕坐标）

**坐标转换**:
- 引擎正确转换屏幕坐标和世界坐标
- 考虑桌面的缩放和平移

---

#### 2.2.7 调整窗口大小

**拖动窗口边缘**:
1. 鼠标移到窗口边缘（5-10px 范围）
2. 鼠标指针变为调整大小图标（↔ 或 ↕）
3. 按下并拖动
4. 窗口大小实时改变
5. 松开鼠标，确定新大小
6. 通过微内核保存窗口大小

**拖动窗口角落**:
- 鼠标指针变为斜向调整图标（↖ ↗ ↙ ↘）
- 同时调整宽度和高度

**约束**:
- 不能小于最小尺寸
- 实时显示新尺寸（可选，使用 Tooltip 组件）

---

#### 2.2.8 平移桌面

**在无限画布布局中**:
1. 鼠标在桌面空白区域
2. 按下并拖动
3. 通过基础层的 DragDropSystem 识别为桌面拖拽
4. 整个桌面跟随鼠标移动（CSS transform）
5. 所有桌面层窗口随之移动
6. 窗口层固定不动
7. 松开鼠标，通过微内核保存桌面位置（可选）

**注意**:
- 区分"拖动桌面"和"框选窗口"
- 可能需要按住 Space 键拖动桌面

---

### 2.3 滚轮操作

#### 2.3.1 滚动内容

**在卡片窗口内**:
- 滚动卡片内容
- 展开状态：可能滚动整个桌面（如果卡片不可滚动）
- 收起状态：滚动卡片内部内容

**在工具窗口内**:
- 滚动窗口内容（使用薯片组件库的滚动容器）

**在文件管理器中**:
- 滚动文件列表（虚拟滚动，组件库实现）

---

#### 2.3.2 缩放桌面

**在无限画布布局中**:

**在桌面空白区域滚动**:
- 滚轮向上：放大桌面
- 滚轮向下：缩小桌面
- 以鼠标位置为中心缩放
- 引擎计算新的缩放和平移
- 通过 CSS transform 应用变换

**按住 Ctrl/Command + 滚轮**:
- 在任何位置缩放桌面
- 覆盖默认的滚动行为

**技术实现**:
```typescript
onWheel = (e: WheelEvent) => {
  if (e.ctrlKey || this.isDesktopArea(e.target)) {
    e.preventDefault();
    const delta = e.deltaY;
    const factor = delta > 0 ? 0.9 : 1.1;
    const newScale = this.scale * factor;
    this.zoomTo(newScale, e.clientX, e.clientY);
  }
};
```

---

### 2.4 悬停反馈

**鼠标悬停在元素上**:

**可点击元素**（Button、Link组件）:
- 鼠标指针变为手型
- 元素高亮或改变颜色（由主题包定义）
- 显示工具提示（Tooltip 组件，悬停0.5-1秒后）

**可拖动元素**:
- 鼠标指针变为手型
- 显示拖动手柄（如果有）

**按钮**（Button 组件）:
- 高亮显示（主题包定义样式）
- 可能有微动画效果

**链接**:
- 下划线显示
- 颜色改变（主题包定义）

---

## 3. 键盘交互

### 3.1 全局快捷键

所有快捷键通过引擎的快捷键管理器注册，最终通过微内核路由执行相应功能。

**文件操作**:
- `Ctrl/Cmd + N`: 新建卡片 → `card.create`
- `Ctrl/Cmd + O`: 打开文件 → 显示文件选择
- `Ctrl/Cmd + S`: 手动保存 → `card.update`
- `Ctrl/Cmd + W`: 关闭当前窗口
- `Ctrl/Cmd + Q`: 退出应用

**编辑操作**:
- `Ctrl/Cmd + Z`: 撤销 → 命令历史栈
- `Ctrl/Cmd + Shift + Z` 或 `Ctrl/Cmd + Y`: 重做
- `Ctrl/Cmd + C`: 复制
- `Ctrl/Cmd + X`: 剪切
- `Ctrl/Cmd + V`: 粘贴
- `Ctrl/Cmd + A`: 全选

**视图操作**:
- `Ctrl/Cmd + L`: 切换布局 → `layout.switch`
- `Ctrl/Cmd + =`: 放大桌面
- `Ctrl/Cmd + -`: 缩小桌面
- `Ctrl/Cmd + 0`: 重置桌面缩放
- `F11` 或 `Ctrl/Cmd + F`: 全屏

**搜索和导航**:
- `Ctrl/Cmd + F`: 搜索 → `file.search`
- `Ctrl/Cmd + P`: 快速打开文件
- `Ctrl/Cmd + K`: 命令面板
- `Ctrl/Cmd + Tab`: 切换窗口

**系统**:
- `Ctrl/Cmd + ,`: 打开设置 → `config.get` 读取配置
- `F1` 或 `Ctrl/Cmd + ?`: 打开帮助

---

### 3.2 编辑模式快捷键

**卡片操作**（通过微内核路由）:
- `Delete` 或 `Backspace`: 删除选中的基础卡片 → `card.remove_base_card`
- `Ctrl/Cmd + D`: 复制选中的基础卡片
- `↑` `↓`: 在基础卡片间导航
- `Ctrl/Cmd + ↑`: 将选中卡片上移 → `card.update`
- `Ctrl/Cmd + ↓`: 将选中卡片下移 → `card.update`

**窗口操作**:
- `Ctrl/Cmd + M`: 最小化窗口
- `Ctrl/Cmd + Shift + F`: 切换到封面
- `Ctrl/Cmd + E`: 切换编辑/查看模式
- `Ctrl/Cmd + R`: 收起/展开窗口

---

### 3.3 焦点和导航

**Tab 键导航**:
- 在可交互元素间移动焦点
- 焦点元素高亮显示（由主题包定义样式）
- `Shift + Tab`: 反向导航

**Enter 键**:
- 激活焦点元素（如 Button 组件）
- 确认输入（如文件名，Input 组件）

**Esc 键**:
- 关闭对话框或面板（Modal、Drawer 组件）
- 取消当前操作
- 退出编辑模式

---

### 3.4 文本编辑

**在可编辑文本区域**（基础层的 TextEditor）:
- 标准的文本编辑快捷键
- `Ctrl/Cmd + B`: 加粗（如果编辑器支持）
- `Ctrl/Cmd + I`: 斜体
- `Ctrl/Cmd + U`: 下划线
- 等等（取决于编辑组件插件）

---

### 3.5 多选操作

**选择多个文件**:
- `Ctrl/Cmd + Click`: 多选
- `Shift + Click`: 范围选择
- `Ctrl/Cmd + A`: 全选

**批量操作**:
- 选中多个文件后，通过微内核批量删除、移动等
- 使用微内核的批量请求优化性能

---

## 4. 触摸板交互

### 4.1 单指操作

**单指点击**: 等同于鼠标左键单击  
**单指拖动**: 等同于鼠标拖动，通过基础层的 DragDropSystem

### 4.2 双指操作

**双指滑动**:
- 滚动内容
- 平移桌面（在桌面空白区域）

**双指捏合**:
- 缩放桌面
- 张开：放大
- 捏合：缩小
- 引擎计算缩放中心和新的变换

**双指旋转**（可选）:
- 旋转视图（如果布局插件支持）

### 4.3 三指操作（可选）

**三指滑动**:
- 切换窗口或工作区
- 或其他自定义操作

### 4.4 手势识别

**轻扫**: 快速滑动触发特定操作  
**长按**: 等同于右键点击，显示上下文菜单（Menu 组件）

---

## 5. 触摸屏交互

### 5.1 触摸操作

**单指点击**: 等同于鼠标点击  
**单指长按**: 显示上下文菜单（Menu 组件），或进入拖动模式  
**单指拖动**: 长按后拖动元素，通过基础层的 DragDropSystem

### 5.2 多点触控

**双指捏合**: 缩放桌面  
**双指拖动**: 平移桌面  
**双指旋转**: 旋转视图（如果支持）

### 5.3 触摸优化

**更大的触摸目标**:
- 按钮至少 44x44 像素（组件库默认尺寸）
- 增加可点击区域

**触摸反馈**:
- 触摸时高亮显示（主题包定义样式）
- 触觉反馈（如果设备支持）

**避免小元素**:
- 不使用过小的可交互元素
- 或提供放大查看模式

---

## 6. 视觉反馈设计

### 6.1 拖拽反馈

所有拖拽反馈通过基础层的 DragDropSystem 和薯片组件库实现。

#### 6.1.1 拖动时的视觉元素

**跟随鼠标的预览**:
- 被拖动对象的半透明副本
- 或简化的图标
- 显示拖动数量（如"3 个文件"，使用 Badge 组件）

**鼠标指针变化**:
- 默认：箭头
- 可拖动：手型 🖐
- 拖动中：抓手 ✊
- 可放置：箭头或手型
- 禁止放置：禁止符号 🚫

---

#### 6.1.2 目标区域反馈

**有效目标区域**:
- 高亮边框（如蓝色发光边框，主题包定义）
- 背景颜色略微改变
- 显示文字提示（如"添加到此卡片"，Tooltip 组件）

**插入位置指示**:
- 蓝色横线（2-3px 粗）
- 插入线两端可能有圆点或箭头
- 位置随鼠标移动实时更新

**无效目标区域**:
- 鼠标显示禁止符号
- 目标区域无高亮
- 可能显示灰色覆盖（50%透明度）

---

#### 6.1.3 其他卡片的反应

**在复合卡片中调整顺序时**:
- 其他基础卡片自动移动让出空间
- 平滑的过渡动画（CSS transition 300ms）
- 明确显示新的布局

---

### 6.2 悬停反馈

**按钮悬停**（Button 组件）:
- 背景颜色变化（主题包定义）
- 可能有阴影效果
- 可能有微小的缩放或平移动画

**链接悬停**:
- 颜色改变（主题包定义）
- 下划线显示

**可拖动元素悬停**:
- 鼠标指针变化
- 可能显示拖动手柄

**工具提示**（Tooltip 组件）:
- 悬停 0.5-1 秒后显示
- 简短说明功能
- 不遮挡重要内容

---

### 6.3 点击反馈

**按钮点击**（Button 组件）:
- 轻微的按下效果（主题包定义）
- 颜色变化
- 可能有涟漪动画（Material Design 风格）

**选中状态**:
- 高亮边框（主题包定义）
- 背景颜色改变
- 可能有选中图标（✓）

---

### 6.4 加载和进度反馈

**加载指示器**（Loading 组件）:
- 旋转的圆圈或进度条
- 显示在正在加载的区域
- 不阻塞其他操作

**进度条**（Progress 组件）:
- 显示操作进度百分比
- 用于文件上传、导出等
- 通过微内核获取进度信息

**骨架屏**（Skeleton 组件）:
- 在内容加载时显示占位符
- 保持布局稳定
- 提升感知性能

---

### 6.5 状态变化反馈

**保存状态**:
- 可选：显示"已保存"提示（Message 组件，短暂显示）
- 或无需提示（因为实时保存）
- 可在状态栏显示最后保存时间

**错误状态**（Alert 组件）:
- 红色边框或背景（主题包定义）
- 错误图标
- 错误信息文字

**成功状态**（Alert 组件）:
- 绿色边框或背景（主题包定义）
- 成功图标（✓）
- 成功消息

---

## 7. 动画和过渡

### 7.1 动画原则

**有目的**:
- 动画应该传达信息，而非纯装饰
- 帮助用户理解变化

**快速流畅**:
- 动画时长通常在 200-300ms
- 使用缓动函数（ease-out, ease-in-out）
- 避免过长或过慢的动画
- 保持 60fps（使用 CSS transform 和 opacity）

**可预测**:
- 遵循物理规律
- 方向和速度合理
- 不突兀，不意外

**可配置**:
- 尊重系统的"减少动画"设置
- 提供禁用动画的选项

---

### 7.2 具体动画

#### 7.2.1 窗口动画

**打开窗口**:
- 从小到大缩放（scale 0.9 → 1.0）
- 同时淡入（opacity 0 → 1）
- 时长：200-250ms
- 使用 CSS transition

**关闭窗口**:
- 从大到小缩放（scale 1.0 → 0.9）
- 同时淡出（opacity 1 → 0）
- 时长：150-200ms

**最小化窗口**:
- 缩小并移动到程序坞图标位置
- 或简单的淡出
- 时长：250ms

**展开/收起**:
- 高度平滑过渡（CSS transition height）
- 时长：300ms
- 内容淡入/淡出

---

#### 7.2.2 拖拽动画

**拖起元素**:
- 轻微放大（scale 1.05）
- 添加阴影（box-shadow）
- 时长：100ms

**放下元素**:
- 恢复原大小（scale 1.0）
- 阴影消失
- 可能有轻微的弹簧效果（spring animation）

**插入动画**:
- 其他元素平滑移动让出空间
- 时长：250ms
- 使用 ease-out 缓动

---

#### 7.2.3 内容变化动画

**添加基础卡片**:
- 淡入并从上方滑入（translateY: -20px → 0）
- 其他卡片平滑下移
- 时长：300ms

**删除基础卡片**:
- 淡出并向上滑出（translateY: 0 → -20px）
- 其他卡片平滑上移补位
- 时长：250ms

**顺序改变**:
- 卡片平滑移动到新位置
- 时长：300ms
- 使用 CSS transition transform

---

#### 7.2.4 页面过渡

**切换布局**:
- 旧布局淡出（opacity 1 → 0，200ms）
- 新布局淡入（opacity 0 → 1，200ms，延迟100ms）
- 可能有轻微的位移效果（translateY: 10px → 0）
- 总时长：400ms

**打开/关闭面板**:
- 从侧边滑入/滑出（translateX）
- 同时淡入/淡出（opacity）
- 时长：250ms

---

### 7.3 性能优化

**使用 GPU 加速**:
- 使用 transform 和 opacity 属性
- 避免触发重排的属性（如 width, height, top, left）
- 使用 will-change 提示浏览器优化

**限制动画数量**:
- 同时运行的动画不宜过多
- 可能需要禁用动画（在低端设备上）

**用户偏好**:
- 尊重系统的"减少动画"设置（prefers-reduced-motion）
- 提供禁用动画的选项

---

## 8. 错误和异常处理

### 8.1 错误类型

**用户错误**:
- 输入无效数据
- 尝试删除重要文件
- 操作冲突

**系统错误**:
- 文件无法保存
- 插件加载失败
- 网络连接问题

**资源错误**:
- 文件不存在
- 权限不足
- 磁盘空间不足

### 8.2 错误提示方式

所有错误提示使用薯片组件库的反馈组件。

#### 8.2.1 内联提示

**用于**: 表单验证错误

**显示**（使用 FormItem 组件的错误状态）:
- 在输入框下方显示红色错误文字
- 输入框红色边框（主题包定义）
- 错误图标

---

#### 8.2.2 Toast 消息

**用于**: 一般性提示和轻量级错误

**显示**（使用 Message 组件）:
- 在右上角显示小卡片
- 自动在 3-5 秒后消失
- 可手动关闭

**类型**:
- 信息（蓝色图标）
- 成功（绿色图标）
- 警告（黄色图标）
- 错误（红色图标）

**技术实现**:
```typescript
// 通过组件库显示消息
Message.success(t('message.save_success'));
Message.error(t('message.save_failed'));
```

---

#### 8.2.3 对话框

**用于**: 需要用户确认或选择的错误

**显示**（使用 Modal 组件）:
- 模态对话框覆盖整个界面
- 清晰的标题和说明
- 提供明确的操作按钮（Button 组件）

**示例**:
- 删除文件确认
- 文件冲突解决
- 权限请求

```typescript
// 使用组件库显示对话框
Modal.confirm({
  title: t('dialog.delete_confirm_title'),
  content: t('dialog.delete_confirm_content', { name: fileName }),
  onOk: async () => {
    await Core.request({
      service: "card.delete",
      payload: { cardId }
    });
  }
});
```

---

#### 8.2.4 状态指示

**用于**: 持续的错误状态

**显示**（使用 Alert 组件）:
- 在相关区域显示错误状态
- 提供"重试"或"修复"按钮（Button 组件）
- 说明错误原因

---

### 8.3 错误消息设计

**清晰明确**:
- 说明发生了什么
- 为什么发生
- 如何解决

**友好语气**:
- 避免责怪用户
- 避免技术术语（使用多语言系统，`i18n.error.*` 编码）
- 提供帮助而非仅提示错误

**可操作**:
- 提供解决方案
- 提供相关操作按钮
- 提供帮助文档链接

**示例**:

❌ 差: "Error: ENOENT"

✅ 好: "无法找到文件。该文件可能已被移动或删除。"

✅ 更好: 
```typescript
Modal.error({
  title: t('error.file_not_found_title'),
  content: t('error.file_not_found_content', { fileName }),
  footer: [
    <Button onClick={browseFiles}>{t('action.browse_files')}</Button>,
    <Button onClick={cancel}>{t('common.cancel')}</Button>
  ]
});
```

---

## 9. 无障碍设计

### 9.1 键盘访问

- 所有功能都可通过键盘访问
- 明确的焦点指示（主题包定义样式）
- 合理的 Tab 顺序
- 快捷键支持
- 使用薯片组件库确保键盘可访问性

### 9.2 屏幕阅读器支持

- 语义化的 HTML
- ARIA 属性标注（组件库内置）
- 图片的 alt 文字
- 动态内容的通知（aria-live）
- 组件库确保屏幕阅读器兼容性

### 9.3 视觉辅助

- 足够的颜色对比度（主题包遵循 WCAG 标准）
- 不仅依赖颜色传达信息
- 可调整的字体大小（通过配置）
- 高对比度模式（主题包提供）

### 9.4 动画控制

- 尊重系统的减少动画设置（prefers-reduced-motion）
- 提供禁用动画的选项
- 避免闪烁内容

---

## 10. 响应式设计

### 10.1 自适应布局

**大屏幕（>1920px）**:
- 充分利用空间
- 多栏布局，可能并排显示更多工具
- 更大的预览

**中等屏幕（1280-1920px）**:
- 标准布局
- 平衡的空间分配

**小屏幕（<1280px）**:
- 紧凑布局
- 可能隐藏次要元素
- 可能需要横向滚动（无限画布）

**实现方式**:
- 使用薯片组件库的响应式布局组件
- 媒体查询适配

---

### 10.2 缩放适配

**UI 元素**:
- 保持清晰可读
- 按钮和交互区域保持合适大小
- 使用相对单位（rem、em）

**内容**:
- 根据缩放级别调整显示
- 可能隐藏细节（在缩小时，LOD策略）

---

### 10.3 设备适配

**桌面**:
- 完整功能
- 鼠标优化
- 使用 Electron 桌面框架

**笔记本**:
- 适配触摸板手势
- 考虑较小屏幕
- 响应式布局

**平板（未来）**:
- 触摸优化
- 可能简化某些功能
- 使用触摸友好的组件

---

## 11. 性能和流畅度

### 11.1 性能目标

- 操作响应时间 < 100ms
- 动画保持 60fps
- 滚动流畅无卡顿
- 拖拽跟手，无延迟
- 微内核路由延迟 < 10ms

### 11.2 优化策略

**虚拟化**:
- 长列表虚拟滚动（使用组件库的 VirtualList）
- 只渲染可见区域

**懒加载**:
- 按需通过微内核加载内容
- 预加载即将显示的内容

**节流和防抖**:
- 滚动和拖拽事件节流
- 输入和保存事件防抖
- 通过微内核的批量请求减少调用

**批量更新**:
- 合并多个 DOM 操作
- 使用 requestAnimationFrame

---

### 11.3 降级策略

**低端设备**:
- 减少或禁用动画
- 简化视觉效果
- 限制同时显示的窗口数量
- 禁用部分实时预览

**性能监控**:
- 检测设备性能
- 自动调整功能
- 警告性能问题

---

## 12. 技术实现总结

### 12.1 架构层次

```
用户交互
  ↓
薯片组件库（界面层）
  ↓
编辑引擎（业务逻辑层）
  ↓
薯片微内核（路由层）
  ↓
公共基础层（功能层）
  ↓
插件系统（扩展层）
```

### 12.2 交互流程示例

**用户拖动文件创建卡片**:
```
1. 用户从文件系统拖动文件
   ↓
2. 引擎接收 drag 事件
   ↓
3. 通过基础层 DragDropSystem 处理
   ↓
4. 通过微内核识别文件类型
   Core.request({ service: "file.identify", ... })
   ↓
5. 微内核返回文件类型
   ↓
6. 引擎显示反馈（组件库的 Tooltip）
   ↓
7. 用户释放鼠标
   ↓
8. 通过微内核创建卡片
   Core.request({ service: "card.create", ... })
   ↓
9. 通过微内核添加基础卡片
   Core.request({ service: "card.add_base_card", ... })
   ↓
10. 通过微内核保存资源
    Core.request({ service: "resource.write", ... })
    ↓
11. 通过微内核加载渲染器插件
    ↓
12. 渲染器使用基础层组件显示内容
    ↓
13. 窗口显示（使用组件库构建）
```

### 12.3 组件使用示例

```vue
<template>
  <!-- 使用薯片组件库构建界面 -->
  <ThemeProvider :theme="currentTheme">
    <ChipsProvider>
      <div class="editor-layout">
        <!-- 文件管理器 -->
        <Tree 
          :data="fileTree"
          @select="handleFileSelect"
        />
        
        <!-- 卡片窗口 -->
        <Card :class="cardWindowClass">
          <template #header>
            <Input 
              v-model="cardName"
              @blur="handleNameChange"
            />
            <Button @click="handleClose">
              {{ t('common.close') }}
            </Button>
          </template>
          
          <!-- 基础卡片列表 -->
          <MarkdownCard 
            v-for="card in baseCards"
            :key="card.id"
            :data="card.data"
          />
        </Card>
        
        <!-- 编辑面板 -->
        <Drawer 
          :visible="editPanelVisible"
          placement="right"
        >
          <!-- 编辑组件插件挂载点 -->
          <div id="edit-plugin-container"></div>
        </Drawer>
      </div>
    </ChipsProvider>
  </ThemeProvider>
</template>

<script setup lang="ts">
// 所有操作通过微内核路由
const handleFileSelect = async (fileId: string) => {
  const response = await Core.request({
    service: "card.read",
    payload: { cardId: fileId }
  });
  // 处理响应...
};

const handleNameChange = async () => {
  await Core.request({
    service: "card.update",
    payload: { 
      cardId: currentCardId,
      updates: { metadata: { name: cardName.value } }
    }
  });
};
</script>
```

---

## 13. 总结

编辑引擎的交互设计遵循以下核心理念：

1. **架构一致性**: 所有交互通过微内核路由，遵循中心路由原则
2. **组件化实现**: 完全使用薯片组件库构建界面
3. **基础层依赖**: 所有基础功能调用公共基础层
4. **直观易用**: 拖拽为主的交互方式，符合用户直觉
5. **即时反馈**: 所有操作都有清晰的视觉反馈
6. **高效流畅**: 快捷键支持，流畅的动画，高性能
7. **容错友好**: 自动保存，撤销/重做，友好的错误提示
8. **跨平台适配**: 支持多种输入设备，统一的体验
9. **无障碍**: 考虑不同用户的需求，提供辅助功能

通过精心设计的交互，基于薯片生态的完整技术栈，让用户可以专注于内容创作，而不是操作软件。

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-31  
**状态**: ✅ 生效
