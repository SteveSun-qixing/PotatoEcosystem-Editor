# 卡片编辑引擎 - 用户故事

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 用户故事说明

本文档通过真实的用户场景展示编辑引擎的使用方式和用户体验。每个故事都基于薯片生态的架构原则：
- 通过微内核路由调用所有功能
- 使用公共基础层的通用组件
- 使用薯片组件库构建界面
- 插件提供具体的编辑和渲染功能

---

## 1. 创建卡片场景

### 1.1 快速创建简单卡片

**角色**: 新用户 Alice  
**目标**: 创建第一张包含文字和图片的卡片

**场景描述**:

Alice 第一次打开编辑引擎，看到无限画布布局。界面使用薯片组件库构建，清爽美观。右侧有一个"卡箱库"工具窗口，显示各种卡片类型。

1. Alice 从卡箱库拖动"富文本卡片"图标到桌面空白区域
2. 引擎通过微内核请求创建新卡片（`card.create`）
3. 微内核生成卡片ID并创建文件
4. 松开鼠标后，在该位置创建了一个新的卡片窗口
5. 卡片名称显示"未命名卡片"，Alice 双击名称修改为"我的第一张卡片"
6. 引擎通过微内核更新卡片元数据（`card.update`）
7. 卡片内已经有一个富文本基础卡片，通过基础层的富文本渲染器显示
8. Alice 点击这个富文本卡片，右侧编辑面板自动打开
9. 引擎通过微内核加载富文本编辑组件插件
10. 编辑面板中显示文本编辑器（调用基础层的 TextEditor 组件）
11. Alice 输入"这是我的第一张卡片！"
12. 编辑组件通知引擎数据已修改
13. 引擎通过微内核保存数据，渲染器实时更新显示
14. Alice 继续从卡箱库拖动"图片卡片"到已有卡片窗口下方
15. 插入指示线显示添加位置，松开后通过微内核添加基础卡片（`card.add_base_card`）
16. Alice 点击图片卡片，编辑面板显示图片上传界面
17. Alice 上传照片，引擎通过微内核保存资源（`resource.write`）
18. 照片通过基础层的图片查看器显示在卡片中

所有操作都自动保存，Alice 完成后关闭窗口，卡片已经保存好了。

**技术亮点**:
- 所有操作通过微内核路由
- 富文本渲染使用基础层组件
- 图片显示使用基础层组件
- 界面使用薯片组件库构建

**收益**: Alice 几分钟内就创建了第一张卡片，无需阅读教程，直观的拖拽操作让她快速上手。

---

### 1.2 从文件创建卡片

**角色**: 摄影师 Bob  
**目标**: 快速将电脑里的照片整理成卡片集合

**场景描述**:

Bob 有一个文件夹包含最近拍摄的 50 张照片，想整理成卡片保存。

1. Bob 打开编辑引擎和文件管理器（macOS Finder）
2. 在 Finder 中选中第一张照片，拖动到编辑引擎桌面
3. 引擎通过微内核调用文件识别（`file.identify`）
4. 微内核识别这是图片文件，返回文件类型信息
5. 引擎通过微内核创建卡片（`card.create`）并添加图片基础卡片（`card.add_base_card`）
6. 卡片名称自动使用文件名
7. 图片通过基础层的 ImageViewer 组件显示
8. Bob 继续拖入更多照片到已有卡片中，快速构建相册卡片
9. 每次拖入都通过微内核处理
10. Bob 也可以拖动照片到桌面空白区域，为每张照片创建独立卡片
11. Bob 在卡片设置中上传一张封面图（通过微内核保存到 `.card/cover.html`）
12. 点击"切换到封面"按钮，卡片窗口关闭，创建封面窗口
13. 封面通过基础层的 IFrameWrapper 组件渲染

Bob 在几分钟内将 50 张照片整理成多张卡片，无需一张张手动创建。

**技术亮点**:
- 文件识别通过微内核路由
- 图片显示使用基础层的 ImageViewer
- 封面渲染使用基础层的 IFrameWrapper
- 所有文件操作通过微内核

**收益**: 直接拖拽文件的方式极大提升了效率，自动识别文件类型省去了选择步骤。

---

### 1.3 创建多媒体学习卡片

**角色**: 学生 Carol  
**目标**: 创建一张学习卡片，包含课程笔记、视频讲解和练习题

**场景描述**:

Carol 想创建一张关于"牛顿三定律"的学习卡片。

1. Carol 从卡箱库拖动"Markdown卡片"创建新卡片
2. 通过微内核创建卡片并添加Markdown基础卡片
3. 命名为"牛顿三定律"
4. 在Markdown编辑器（基础层的 TextEditor + MarkdownParser）中输入课程笔记和公式
5. 从卡箱库拖动"视频卡片"添加到笔记下方
6. 上传老师录制的讲解视频
7. 视频通过基础层的 VideoPlayer 组件播放
8. 继续添加"列表卡片"，输入练习题
9. 列表通过薯片组件库的 List 组件渲染
10. 添加"打分卡片"，记录自己对这个知识点的掌握程度
11. 打分组件使用薯片组件库的 Slider 或 Rate 组件
12. 为卡片设置"学术"主题包，通过 ThemeProvider 应用主题
13. 整张卡片的外观立即改变，呈现学术风格

Carol 创建了一张完整的学习卡片，以后复习时可以看笔记、看视频、做练习。

**技术亮点**:
- Markdown解析使用基础层的 MarkdownParser
- 视频播放使用基础层的 VideoPlayer
- 列表和评分使用薯片组件库
- 主题应用使用 ThemeProvider
- 所有操作通过微内核路由

**收益**: 多种基础卡片类型让 Carol 可以自由组合，创建适合自己的学习材料。

---

## 2. 编辑内容场景

### 2.1 编辑现有卡片内容

**角色**: 博主 David  
**目标**: 更新一张旧文章卡片，添加新的图片和修正文字

**场景描述**:

David 之前创建了一张文章卡片，现在想更新内容。

1. David 打开文件管理器（使用薯片组件库的 Tree 组件构建），点击"产品评测文章"卡片
2. 引擎通过微内核读取卡片数据（`card.read`）
3. 卡片窗口在桌面上打开，内容通过渲染器插件显示
4. David 点击文本卡片，编辑面板打开
5. 引擎通过微内核加载文本编辑组件插件
6. 编辑器使用基础层的 TextEditor 组件
7. David 修改文字，数据通过引擎API更新，引擎通过微内核保存（`card.update`）
8. 文本通过基础层的 RichTextRenderer 实时显示在卡片中
9. David 直接从 Finder 拖动图片文件到文本卡片下方
10. 引擎通过微内核识别图片文件（`file.identify`）
11. 通过微内核添加图片基础卡片（`card.add_base_card`）
12. 图片通过基础层的 ImageViewer 显示
13. David 点击图片卡片，在编辑面板中调整显示模式为"铺满宽度"
14. 配置通过微内核更新
15. David 删除过时的视频卡片，通过微内核删除（`card.remove_base_card`）
16. 所有修改自动保存

David 快速更新了文章，无需点击保存按钮。

**技术亮点**:
- 文件读取通过微内核路由
- 文本编辑使用基础层组件
- 图片显示使用基础层组件
- 所有更新通过微内核保存
- 界面使用组件库构建

**收益**: 实时保存让 David 不用担心丢失修改，直观的编辑方式让更新内容变得简单。

---

### 2.2 调整卡片结构

**角色**: 项目经理 Eve  
**目标**: 重新组织项目任务卡片的结构

**场景描述**:

Eve 有一张项目任务卡片，随着项目进展需要调整任务顺序。

1. Eve 打开任务卡片，卡片包含 10 个任务（列表卡片）
2. 列表使用薯片组件库的 List 组件渲染
3. 确认卡片处于编辑模式（查看锁定按钮状态）
4. Eve 按住任务 5 的列表卡片，向上拖动
5. 引擎通过基础层的 DragDropSystem 处理拖拽事件
6. 其他任务自动调整位置让出空间
7. 蓝色插入指示线显示插入位置
8. 拖到任务 2 下方，松开鼠标
9. 引擎通过微内核更新卡片结构（`card.update`）
10. 任务顺序立即改变，编号自动更新
11. Eve 继续调整其他任务的顺序
12. 所有变化通过微内核自动保存

Eve 轻松重组了任务列表，无需复杂的操作。

**技术亮点**:
- 列表渲染使用薯片组件库
- 拖拽处理使用基础层的 DragDropSystem
- 结构更新通过微内核路由
- 自动保存机制

**收益**: 拖拽调整顺序非常直观，实时反馈让 Eve 清楚看到每次调整的效果。

---

## 3. 管理文件场景

### 3.1 浏览和打开文件

**角色**: 教师 Helen  
**目标**: 找到上周创建的课程卡片并打开

**场景描述**:

Helen 创建了很多课程卡片，需要找到特定的一张。

1. Helen 打开编辑引擎，查看文件管理器窗口（使用薯片组件库的 List 和 Tree 组件构建）
2. 文件管理器通过微内核获取文件列表（`file.list`）
3. 显示所有卡片和箱子文件
4. Helen 点击"按修改时间排序"，最近修改的文件排在前面
5. Helen 在搜索框（薯片组件库的 Input 组件）输入"第五章"
6. 搜索通过微内核执行，实时过滤结果
7. 找到"第五章 - 细胞分裂"卡片
8. 点击文件，引擎通过微内核读取卡片（`card.read`）
9. 卡片窗口在桌面上打开，内容通过渲染器插件显示
10. 卡片中的各种内容通过基础层组件渲染：文本、图片、视频等
11. Helen 开始查看和修改内容

Helen 快速找到了需要的卡片。

**技术亮点**:
- 文件列表使用薯片组件库
- 文件操作通过微内核路由
- 搜索功能通过微内核
- 内容渲染使用基础层组件

**收益**: 强大的搜索和排序功能让文件管理变得简单，即使文件很多也能快速定位。

---

### 3.2 整理文件到文件夹

**角色**: 作家 Ian  
**目标**: 将松散的卡片整理到不同的项目文件夹

**场景描述**:

Ian 创建了很多卡片，现在想按小说项目分类整理。

1. Ian 在文件管理器（薯片组件库构建）中点击"新建文件夹"按钮（Button 组件）
2. 创建"科幻小说"、"历史小说"、"短篇集"三个文件夹
3. Ian 拖动相关卡片到对应文件夹
4. 拖拽通过基础层的 DragDropSystem 处理
5. 系统通过微内核移动文件并更新文件列表
6. Ian 可以折叠/展开文件夹查看内容（Tree 组件功能）
7. Ian 为卡片添加标签（通过微内核的 `tag.add` 服务），如"草稿"、"待修改"、"已完成"
8. 标签输入使用薯片组件库的 Tag 组件
9. 以后可以通过微内核按标签筛选文件（`tag.query`）

Ian 的文件管理变得井井有条。

**技术亮点**:
- 文件管理器使用薯片组件库的 Tree 组件
- 拖拽处理使用基础层的 DragDropSystem
- 文件操作通过微内核路由
- 标签系统通过微内核

**收益**: 文件夹和标签系统让大量文件的组织变得容易，不同的组织方式适应不同需求。

---

### 3.3 导入导出文件

**角色**: 内容创作者 Kate  
**目标**: 导出卡片为网页格式分享到博客

**场景描述**:

Kate 创建了一张精美的旅行游记卡片，想分享到个人博客。

1. Kate 打开游记卡片
2. 点击设置按钮（薯片组件库的 Button），打开设置对话框（Modal 组件）
3. 选择"导出"选项卡
4. 选择导出格式为"网页(HTML)"（使用 Select 组件）
5. 设置导出选项：包含所有资源，使用响应式布局（使用 Checkbox 和 Radio 组件）
6. 点击确认，引擎通过微内核执行导出（`card.export`）
7. 微内核调用渲染器插件生成网页
8. 渲染过程使用基础层组件渲染各种内容
9. 生成一个 ZIP 文件包含所有内容（基础层的 ZIPProcessor）
10. 显示导出进度（使用 Progress 组件）
11. 导出完成，显示成功通知（使用 Notification 组件）
12. Kate 解压后上传到博客服务器
13. 在浏览器中访问，看到完整的游记页面

Kate 轻松将卡片内容发布到网上。

**技术亮点**:
- 设置界面使用薯片组件库
- 导出功能通过微内核路由
- 渲染使用基础层组件
- 文件处理使用基础层的 ZIPProcessor

**收益**: 多种导出格式让内容可以在不同场景使用，扩展了卡片的应用范围。

---

## 4. 使用不同布局场景

### 4.1 自由创作模式 - 无限画布

**角色**: 设计师 Leo  
**目标**: 使用无限画布组织设计灵感和参考资料

**场景描述**:

Leo 正在做一个品牌设计项目，需要收集和组织大量灵感。

1. Leo 选择无限画布布局（通过微内核加载布局插件）
2. 布局插件提供无限画布界面（使用薯片组件库构建）
3. Leo 创建多张卡片，每张包含不同的设计参考
4. 卡片内容通过基础层组件渲染：图片、视频、网页等
5. Leo 在桌面上自由摆放卡片，形成灵感墙
6. 相关的卡片放在一起，用空间位置表示关联
7. Leo 使用鼠标滚轮缩小桌面查看全局布局
8. 缩放通过基础层的变换系统实现
9. Leo 放大某个区域专注于细节
10. Leo 拖动桌面平移到不同区域（基础层的 DragDropSystem）
11. Leo 创建箱子，将同类卡片组织在一起
12. 随时调整卡片位置，重新组织思路
13. 所有状态通过微内核自动保存

无限画布给了 Leo 充分的创作自由。

**技术亮点**:
- 无限画布由布局插件提供
- 缩放和平移使用基础层功能
- 内容渲染使用基础层组件
- 界面使用薯片组件库
- 所有操作通过微内核路由

**收益**: 空间化的组织方式符合创意工作的思维模式，自由度高，灵活性强。

---

### 4.2 专注编辑模式 - 工作台布局

**角色**: 作家 Mary  
**目标**: 专注写作，减少干扰

**场景描述**:

Mary 想专注写一篇长文章，不希望看到其他干扰元素。

1. Mary 通过微内核切换到工作台布局
2. 布局插件加载，界面变成传统的三栏布局
3. 布局界面使用薯片组件库构建
4. 左侧文件管理器显示文件树（Tree 组件）
5. 中间预览区显示当前卡片内容
6. 内容通过渲染器插件渲染，使用基础层组件
7. 右侧编辑窗口显示正在编辑的文本
8. 文本编辑器使用基础层的 TextEditor 组件
9. Mary 选中文件，通过微内核读取，中间立即显示预览
10. Mary 点击文本卡片，通过微内核加载编辑组件，右侧显示编辑器
11. 界面紧凑，没有多余元素
12. Mary 专注于写作，所有修改通过微内核自动保存
13. 效率提升

工作台布局提供了传统软件的体验。

**技术亮点**:
- 布局切换通过微内核
- 文件管理器使用组件库
- 文本编辑使用基础层组件
- 所有操作通过微内核路由

**收益**: 熟悉的界面布局降低学习成本，适合喜欢传统界面的用户。

---

### 4.3 在布局间切换

**角色**: 项目管理者 Nancy  
**目标**: 根据不同任务切换最合适的布局

**场景描述**:

Nancy 管理多个项目，不同阶段需要不同的视角。

1. 项目规划阶段，Nancy 使用无限画布布局
2. 在画布上自由摆放任务卡片，规划项目结构
3. 执行阶段，Nancy 通过微内核切换到工作台布局
4. 专注于单个任务的细节编辑
5. 回顾阶段，Nancy 切换到看板布局（未来功能，由布局插件提供）
6. 查看所有任务的状态分布
7. 切换布局时：
   - 引擎保存当前布局状态
   - 通过微内核卸载旧布局插件
   - 通过微内核加载新布局插件
   - 所有打开的文件数据保持不变
   - 新布局恢复窗口状态
   - 界面平滑过渡
8. Nancy 根据需要随时切换

多种布局适应不同工作模式。

**技术亮点**:
- 布局切换完全通过微内核
- 状态保存和恢复机制
- 布局插件独立加载
- 数据保持一致

**收益**: 灵活的布局切换让同一份数据可以用不同方式查看，适应不同场景。

---

## 5. 拖拽交互场景

### 5.1 嵌套卡片创建知识网络

**角色**: 研究员 Oliver  
**目标**: 创建一个有层次结构的知识卡片系统

**场景描述**:

Oliver 研究机器学习，想创建一个知识卡片网络。

1. Oliver 创建一张"机器学习概述"卡片作为主卡片
2. Oliver 创建多张子主题卡片："监督学习"、"非监督学习"、"强化学习"
3. Oliver 拖动"监督学习"卡片窗口到"机器学习概述"卡片窗口
4. 引擎通过基础层的 DragDropSystem 处理拖拽
5. 目标卡片高亮，显示"嵌套到此卡片"提示
6. 释放鼠标，引擎通过微内核执行嵌套操作
7. "监督学习"卡片作为嵌套卡片添加进去，保持完整结构
8. 嵌套卡片通过特殊的渲染组件显示（可展开/收起）
9. Oliver 可以在主卡片中展开或收起嵌套卡片
10. Oliver 继续嵌套其他子主题卡片
11. Oliver 在"监督学习"卡片中再嵌套"决策树"、"神经网络"等更细的主题
12. 所有操作通过微内核路由和保存
13. 形成多层级的知识结构

Oliver 构建了一个有组织的知识体系。

**技术亮点**:
- 卡片嵌套通过微内核处理
- 拖拽使用基础层 DragDropSystem
- 嵌套卡片有专门的渲染组件
- 所有操作通过微内核路由

**收益**: 卡片嵌套功能让知识组织更灵活，可以建立复杂的层次关系。

---

### 5.2 批量文件导入

**角色**: 音乐人 Quinn  
**目标**: 快速将整张专辑的音乐文件导入为卡片

**场景描述**:

Quinn 发布了新专辑，想为每首歌创建一张卡片。

1. Quinn 打开编辑引擎和专辑文件夹
2. Quinn 选中所有 12 首歌曲文件
3. 一次性拖动所有文件到编辑引擎桌面
4. 引擎通过微内核批量识别文件（`file.identify` 批量调用）
5. 微内核返回所有文件都是音频文件
6. 引擎通过微内核为每首歌创建卡片（`card.create` 批量调用）
7. 每张卡片包含一个音乐基础卡片
8. 卡片自动以歌曲名命名
9. 所有卡片整齐排列在桌面上
10. 每张卡片的音乐通过基础层的 AudioPlayer 播放
11. Quinn 逐一打开卡片，通过编辑组件添加歌词和说明
12. 文本编辑使用基础层的 TextEditor
13. Quinn 创建一个"专辑"箱子，通过微内核创建（`box.create`）
14. 将所有歌曲卡片拖动添加到箱子中（`box.add_card`）
15. 箱子使用特定的布局插件渲染

Quinn 几分钟内完成了整张专辑的导入。

**技术亮点**:
- 批量文件识别通过微内核
- 批量创建卡片通过微内核
- 音乐播放使用基础层 AudioPlayer
- 箱子功能通过微内核
- 所有界面使用组件库

**收益**: 批量操作大大提升效率，自动识别省去了重复操作。

---

## 6. 封面和展示场景

### 6.1 创建精美封面

**角色**: 设计师 Rita  
**目标**: 为卡片设计一个吸引人的封面

**场景描述**:

Rita 创建了一张个人简历卡片，想添加专业的封面。

1. Rita 打开卡片设置对话框（薯片组件库的 Modal 组件）
2. 点击"封面"选项卡（Tabs 组件）
3. 选择上传自定义封面
4. Rita 使用 HTML/CSS 制作了一个动态封面网页
5. 通过文件上传组件（Upload 组件）上传封面文件
6. 引擎通过微内核保存封面文件（`resource.write` 到 `.card/cover.html`）
7. 预览封面效果（通过基础层的 IFrameWrapper 在沙箱中显示）
8. Rita 满意后确认
9. Rita 选择封面比例为"名片比例"横版（使用 Select 组件）
10. 引擎通过微内核更新卡片配置（`card.update`）
11. 点击"切换到封面"按钮
12. 卡片窗口关闭，创建封面窗口
13. 封面通过基础层的 IFrameWrapper 渲染
14. 精美的封面展示卡片主题

Rita 的卡片有了专业的外观。

**技术亮点**:
- 设置对话框使用薯片组件库
- 文件保存通过微内核
- 封面渲染使用基础层 IFrameWrapper
- 沙箱安全机制

**收益**: 自定义封面让卡片可以有独特的视觉呈现，支持网页技术提供了最大的创作自由。

---

### 6.2 桌面美化和组织

**角色**: 个人用户 Tom  
**目标**: 将桌面打造成个人工作空间

**场景描述**:

Tom 想让编辑引擎的桌面既美观又实用。

1. Tom 将常用卡片都切换到封面模式
2. 所有封面通过基础层的 IFrameWrapper 渲染
3. 选择统一的封面比例和风格
4. 为不同卡片应用不同主题（使用 ThemeProvider）
5. 在无限画布上精心摆放封面窗口
6. 按主题分区：工作、学习、生活、灵感
7. 每个区域的封面形成视觉上的组合
8. Tom 缩小桌面，整体效果像一面墙
9. 需要编辑时，点击封面展开卡片
10. 展开后内容通过渲染器插件和基础层组件显示
11. 编辑完成，切换回封面保持整洁
12. 所有操作和状态通过微内核处理和保存

Tom 的桌面既美观又高效。

**技术亮点**:
- 封面渲染使用基础层 IFrameWrapper
- 主题应用使用 ThemeProvider
- 桌面操作通过布局插件
- 所有状态通过微内核保存

**收益**: 封面模式让桌面更整洁，空间化的组织方式提升了效率和美感。

---

## 7. 高级使用场景

### 7.1 主题定制

**角色**: 设计爱好者 Uma  
**目标**: 为不同类型的卡片应用不同主题

**场景描述**:

Uma 想让不同类型的卡片有不同的视觉风格。

1. Uma 通过微内核获取已安装的主题包列表（`plugin.list`）
2. Uma 打开工作类卡片设置（Modal 组件）
3. 在主题选择器（Select 组件）中选择"专业"主题
4. 引擎通过微内核更新卡片主题配置（`card.update`）
5. ThemeProvider 自动应用新主题
6. 卡片背景变成简洁的商务风格
7. 主题通过CSS变量注入到组件
8. Uma 打开学习类卡片，选择"学术"主题
9. 卡片背景变成笔记本纸张效果
10. Uma 打开生活类卡片，选择"温馨"主题
11. 卡片背景变成温暖的色调和装饰
12. Uma 也可以为单个基础卡片设置主题（主题嵌套）
13. 实现更精细的视觉控制
14. 所有主题配置通过微内核保存

Uma 的卡片系统变得丰富多彩。

**技术亮点**:
- 主题系统完全遵循组件库规范
- ThemeProvider 支持主题嵌套
- 主题配置通过微内核
- CSS变量系统

**收益**: 灵活的主题系统让用户可以自定义外观，满足个性化需求。

---

### 7.2 插件扩展功能

**角色**: 开发者 Victor  
**目标**: 开发一个新的基础卡片类型插件

**场景描述**:

Victor 想创建一个"代码编辑器卡片"插件。

1. Victor 阅读插件开发文档
2. 创建插件项目，遵循薯片插件规范
3. 开发渲染器：
   - 调用基础层的 CodeHighlighter 显示代码
   - 使用薯片组件库构建界面
   - 通过微内核路由获取数据
4. 开发编辑组件：
   - 调用基础层的 TextEditor 提供编辑器
   - 使用组件库的 Select 选择编程语言
   - 使用组件库的 Button 等控件
   - 通过引擎API（经由微内核）保存数据
5. 定义插件接口，注册到微内核
6. 测试插件功能
7. 打包插件并发布到插件市场
8. 其他用户通过微内核安装插件（`plugin.install`）
9. 安装后，通过微内核注册插件服务
10. 卡箱库中出现"代码编辑器卡片"（通过微内核查询插件列表）
11. 用户可以使用 Victor 开发的新卡片类型
12. 创建、编辑、渲染都通过微内核路由

Victor 为生态系统贡献了新功能。

**技术亮点**:
- 插件完全遵循微内核架构
- 使用基础层的代码相关组件
- 使用薯片组件库构建界面
- 所有通信通过微内核路由
- 插件安装管理通过微内核

**收益**: 开放的插件系统让第三方可以扩展功能，丰富整个生态系统。

---

### 7.3 快捷键工作流

**角色**: 高效用户 Wendy  
**目标**: 完全使用键盘操作，不用鼠标

**场景描述**:

Wendy 是键盘流用户，想用快捷键完成所有操作。

1. Wendy 按 Ctrl+N 创建新卡片
2. 引擎通过微内核创建卡片（`card.create`）
3. 直接输入卡片名称，回车确认
4. 通过微内核保存名称（`card.update`）
5. Wendy 按 Ctrl+K 打开命令面板（使用组件库的 Modal + List）
6. 输入"添加文本"，实时搜索过滤
7. 选择富文本卡片类型，回车确认
8. 通过微内核添加基础卡片（`card.add_base_card`）
9. 自动打开编辑面板，加载编辑组件（通过微内核）
10. Wendy 输入内容，使用基础层的 TextEditor
11. 按 Ctrl+Enter 确认并关闭编辑面板
12. Wendy 按 Ctrl+P 快速打开文件
13. 输入文件名，键盘导航选择，回车打开
14. 通过微内核读取和渲染文件
15. 所有操作都通过键盘完成

Wendy 的工作效率极高。

**技术亮点**:
- 命令面板使用薯片组件库
- 所有操作通过微内核路由
- 文本编辑使用基础层组件
- 完整的键盘导航支持

**收益**: 完善的快捷键支持让高级用户可以高效工作，提升专业用户体验。

---

## 8. 错误处理场景

### 8.1 网络资源加载失败

**角色**: 用户 Xavier  
**目标**: 处理网页卡片中的资源加载失败

**场景描述**:

Xavier 的卡片中包含一个网页卡片，网址失效了。

1. Xavier 打开卡片，引擎通过微内核读取（`card.read`）
2. 网页卡片通过基础层的 IFrameWrapper 加载
3. 网页加载失败，IFrameWrapper 返回错误
4. 系统显示友好的错误提示："无法加载网页"（使用 Alert 组件）
5. 提供重试按钮和编辑按钮（Button 组件）
6. Xavier 点击编辑按钮
7. 引擎通过微内核加载网页卡片编辑组件
8. 编辑面板打开，使用 Input 组件显示URL输入框
9. Xavier 更新网址
10. 通过微内核保存修改（`card.update`）
11. 网页通过 IFrameWrapper 重新加载
12. 正常显示

Xavier 轻松解决了问题。

**技术亮点**:
- 网页加载使用基础层 IFrameWrapper
- 错误组件使用薯片组件库
- 编辑组件通过微内核加载
- 所有更新通过微内核

**收益**: 友好的错误提示和快速修复选项提升了用户体验。

---

### 8.2 文件损坏恢复

**角色**: 用户 Yara  
**目标**: 恢复损坏的卡片文件

**场景描述**:

Yara 的一张重要卡片文件损坏了。

1. Yara 尝试打开卡片
2. 引擎通过微内核读取文件（`card.read`）
3. 微内核检测到文件损坏，返回错误
4. 系统提示："文件可能已损坏，是否尝试恢复？"（使用 Modal 组件）
5. Yara 点击"尝试恢复"按钮
6. 引擎通过微内核请求文件恢复服务
7. 微内核尝试解析文件，使用基础层的 ZIPProcessor
8. 恢复可用的部分
9. 成功恢复大部分内容，但丢失了最后的修改
10. 系统提示恢复情况（使用 Notification 组件）
11. 创建恢复文件
12. Yara 查看恢复的内容，大部分数据都在
13. 通过微内核保存恢复文件

Yara 的重要数据被成功恢复。

**技术亮点**:
- 文件读取通过微内核
- ZIP处理使用基础层 ZIPProcessor
- 恢复机制完善
- 错误提示使用组件库

**收益**: 容错机制和恢复功能保护用户数据，减少损失。

---

### 8.3 插件加载失败处理

**角色**: 用户 Zack  
**目标**: 处理某个基础卡片的插件加载失败

**场景描述**:

Zack 打开一张卡片，其中一个基础卡片的插件无法加载。

1. 卡片打开，引擎通过微内核读取（`card.read`）
2. 尝试渲染基础卡片，通过微内核加载渲染器插件
3. 微内核返回插件加载失败错误
4. 一个基础卡片显示为占位符（使用 Empty 组件）
5. 系统提示："无法加载插件'XXX'，可能未安装或版本不兼容"（Alert 组件）
6. 提供选项："安装插件"、"使用替代插件"、"删除此卡片"（Button 组件）
7. Zack 点击"安装插件"
8. 系统通过微内核查询插件信息（`plugin.info`）
9. 打开插件市场定位到需要的插件
10. Zack 通过微内核安装插件（`plugin.install`）
11. 安装完成，返回卡片
12. 引擎通过微内核重新加载插件
13. 基础卡片正常显示

Zack 解决了插件问题。

**技术亮点**:
- 插件加载通过微内核
- 错误处理机制完善
- 占位符使用组件库
- 插件安装通过微内核

**收益**: 清晰的错误提示和解决方案引导用户解决问题，而不是让用户困惑。

---

## 9. 协作场景（未来功能）

### 9.1 协作编辑

**角色**: 团队成员 Frank 和 Grace  
**目标**: 共同编辑一张项目文档卡片

**场景描述**:

Frank 和 Grace 同时编辑一张共享的项目文档卡片。

1. Frank 打开卡片，通过微内核读取（`card.read`）
2. 开始编辑第一部分，使用基础层的 TextEditor
3. Grace 同时打开同一张卡片
4. 系统通过微内核检测到多人编辑
5. 通过微内核订阅协作事件（`event.subscribe`）
6. 显示其他编辑者的光标位置
7. Frank 的修改通过微内核发布事件（`event.publish`）
8. 实时同步到 Grace 的界面
9. Grace 的修改也实时同步到 Frank 的界面
10. 他们在不同部分工作，没有冲突
11. 如果同时编辑同一位置，系统通过微内核处理冲突
12. 提示冲突并帮助解决（使用 Modal 组件）
13. 所有变更通过微内核保存

团队成员可以实时协作，提升效率。

**技术亮点**:
- 协作通过微内核事件系统
- 编辑使用基础层组件
- 冲突处理通过微内核
- 界面使用组件库

**注**: 这是未来功能，当前版本可能不支持。

---

## 10. 总结

这些用户故事涵盖了编辑引擎的主要使用场景，充分展示了薯片生态的架构优势：

### 10.1 微内核架构的优势

- **模块解耦**: 所有操作通过微内核路由，模块间无直接依赖
- **统一接口**: 所有服务调用使用统一格式
- **权限管理**: 微内核负责权限验证和安全控制
- **事件系统**: 通过事件总线实现松耦合的消息传递

### 10.2 公共基础层的价值

- **避免重复**: 编辑引擎不需要实现媒体播放、文本渲染等基础功能
- **功能完整**: 基础层提供了所有需要的通用组件
- **质量保证**: 基础层组件经过充分测试和优化
- **统一标准**: 所有模块使用相同的基础能力

### 10.3 薯片组件库的作用

- **快速开发**: 丰富的组件库加速界面开发
- **一致体验**: 组件风格统一，用户体验一致
- **主题支持**: 功能与样式分离，支持原子级主题
- **可维护性**: 组件库统一维护，升级方便

### 10.4 插件生态的力量

- **功能扩展**: 第三方可以开发新的卡片类型和布局
- **开放创新**: 社区贡献丰富生态
- **标准接口**: 插件遵循统一标准，互操作性好
- **独立开发**: 插件独立开发和发布

### 10.5 用户体验设计

- **易用性**: 直观的操作，新用户快速上手
- **灵活性**: 多种布局和组织方式，适应不同需求
- **高效性**: 拖拽操作和快捷键支持，提升工作效率
- **可扩展性**: 插件系统让功能不断丰富
- **容错性**: 友好的错误处理，保护用户数据

通过这些场景，我们验证了需求的完整性，指导设计和开发工作，确保编辑引擎满足用户的真实需求。

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-31  
**状态**: ✅ 生效
