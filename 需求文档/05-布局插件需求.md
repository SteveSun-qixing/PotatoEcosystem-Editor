# 卡片编辑引擎 - 布局插件需求

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 布局插件概述

### 1.1 布局插件的定位

布局插件定义了卡片和窗口在编辑引擎中的组织和显示方式。不同的布局插件提供不同的使用体验，适应不同的工作场景。

**架构位置**:
```
编辑引擎
  ↓ 通过微内核加载
布局插件
  ↓ 使用薯片组件库构建界面
  ↓ 通过微内核调用基础层
公共基础层（窗口管理、拖拽系统等）
```

### 1.2 布局插件的职责

**布局插件负责**:
- 定义窗口的组织方式和布局结构
- 提供特定的交互模式
- 管理视图的缩放、平移等变换
- 提供布局特有的功能（如无限画布的缩放）
- 使用薯片组件库构建用户界面

**布局插件不负责**:
- 卡片和箱子的具体渲染（由渲染器插件负责）
- 基础卡片的编辑功能（由编辑组件插件负责）
- 文件的读写和管理（由引擎核心通过微内核负责）
- 基础的拖拽处理（调用基础层的 DragDropSystem）
- 窗口的底层管理（调用基础层的 WindowManager）

### 1.3 与生态的集成

**通过微内核调用**:
- 所有对引擎功能的调用通过微内核路由
- 所有对基础层的调用通过微内核路由
- 使用标准的请求/响应格式

**使用薯片组件库**:
- 所有界面元素使用组件库构建
- Button、Input、Menu、Modal等基础组件
- Grid、Flex、Container等布局组件
- 遵循功能与样式分离原则

**使用公共基础层**:
- 窗口管理：调用基础层的 WindowManager
- 拖拽处理：调用基础层的 DragDropSystem
- 配置管理：调用基础层的 ConfigManager

### 1.4 布局插件接口

所有布局插件必须实现标准接口并通过微内核注册：

```typescript
interface LayoutPlugin {
  // === 插件信息 ===
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  
  // === 生命周期（通过微内核调用）===
  init(context: EngineContext): Promise<void>;
  mount(container: HTMLElement): Promise<void>;
  unmount(): Promise<void>;
  destroy(): Promise<void>;
  
  // === 窗口管理（通过微内核路由）===
  createWindow(file: File, options?: WindowOptions): Promise<Window>;
  closeWindow(windowId: string): Promise<void>;
  focusWindow(windowId: string): Promise<void>;
  getWindows(): Window[];
  
  // === 布局特定功能 ===
  getFeatures(): LayoutFeatures;
  executeCommand(command: string, ...args: any[]): Promise<void>;
}

interface EngineContext {
  // 通过微内核调用引擎功能
  callEngine(service: string, payload: any): Promise<any>;
  
  // 订阅事件（通过微内核事件总线）
  on(eventType: string, handler: Function): void;
  off(eventType: string, handler: Function): void;
  
  // 获取配置（通过微内核）
  getConfig(key: string): Promise<any>;
  setConfig(key: string, value: any): Promise<void>;
}
```

**插件注册**:
```typescript
// 插件向微内核注册
await Core.request({
  service: "plugin.register",
  payload: {
    pluginId: "layout.infinite-canvas",
    type: "layout",
    name: "无限画布布局",
    version: "1.0.0",
    services: [
      {
        name: "layout.infinite-canvas.init",
        handler: "InfiniteCanvasLayout.init"
      },
      {
        name: "layout.infinite-canvas.createWindow",
        handler: "InfiniteCanvasLayout.createWindow"
      }
      // ... 其他服务
    ]
  }
});
```

---

## 2. 无限画布布局插件

### 2.1 产品定位

无限画布布局提供一个自由的空间化工作环境，适合创意工作、头脑风暴、灵感整理等场景。

### 2.2 核心特性

- 无限大的二维画布空间
- 自由放置和移动窗口
- 缩放和平移画布
- 空间化的内容组织
- 两层设计（桌面层和窗口层）

### 2.3 两层设计

#### 2.3.1 桌面层（底层）

**定义**:
- 桌面层是一个无限大的二维画布
- 卡片和箱子窗口放置在桌面上
- 支持缩放和平移变换

**背景**:
- 显示网格图案
- 网格通过 Canvas 或 CSS 渲染
- 网格大小随缩放级别调整
- 网格颜色和样式由主题包提供

**坐标系统**:
- 使用世界坐标系
- 窗口位置相对于桌面原点
- 支持负坐标（无限扩展）

**变换**:
- 缩放：0.1x - 5x（可配置）
- 平移：无限制
- 所有桌面层元素随桌面变换
- 使用 CSS transform 实现（GPU加速）

**技术实现**:
```typescript
// 应用桌面变换
applyTransform = () => {
  const container = document.getElementById('desktop-content');
  container.style.transform = 
    `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
};
```

---

#### 2.3.2 窗口层（顶层）

**定义**:
- 窗口层是固定在屏幕上的透明层
- 工具窗口和UI元素固定在窗口层
- 不受桌面缩放和平移影响

**包含元素**（使用薯片组件库构建）:
- 工具窗口（Drawer、Modal 组件）
- 程序坞（自定义组件）
- 缩放控制滑块（Slider 组件）
- 其他固定UI元素

**坐标系统**:
- 使用屏幕坐标系
- 窗口位置相对于屏幕边缘

**技术实现**:
```vue
<template>
  <div class="infinite-canvas-layout">
    <!-- 桌面层 -->
    <div class="desktop-layer">
      <div class="desktop-background"></div>
      <div class="desktop-content" id="transform-container">
        <!-- 卡片和箱子窗口 -->
      </div>
    </div>
    
    <!-- 窗口层 -->
    <div class="window-layer">
      <!-- 工具窗口（使用组件库） -->
      <Drawer 
        :visible="fileManagerVisible"
        placement="left"
      >
        <FileManager />
      </Drawer>
      
      <Drawer 
        :visible="editPanelVisible"
        placement="right"
      >
        <EditPanel />
      </Drawer>
      
      <!-- 程序坞 -->
      <Dock :tools="toolWindows" />
      
      <!-- 缩放控制器 -->
      <ZoomControl 
        :value="scale"
        :min="0.1"
        :max="5"
        @change="handleZoomChange"
      />
    </div>
  </div>
</template>
```

---

### 2.4 桌面操作需求

#### 2.4.1 平移桌面

**触发方式**:
- 鼠标：在空白区域拖动（通过基础层 DragDropSystem）
- 触摸板：双指滑动
- 触摸屏：双指拖动
- 键盘：方向键 + Space（可选）

**行为**:
- 整个桌面随手势移动
- 所有桌面层窗口保持相对位置
- 窗口层固定不动
- 背景网格随之移动

**边界**:
- 无边界限制
- 可以无限向任何方向平移

**技术实现**:
```typescript
// 通过基础层注册拖拽
await Core.request({
  service: "foundation.drag-drop.register-source",
  payload: {
    sourceId: "desktop-canvas",
    type: "desktop",
    onDragMove: this.handlePan
  }
});

handlePan = (dx: number, dy: number) => {
  this.translateX += dx;
  this.translateY += dy;
  this.applyTransform();
  this.debouncedSave();
};
```

---

#### 2.4.2 缩放桌面

**触发方式**:
- 鼠标滚轮：在空白区域滚动，或 Ctrl + 滚轮
- 触摸板：双指捏合手势
- 触摸屏：双指捏合手势
- 缩放滑块：拖动右下角的滑块（Slider 组件）
- 快捷键：Ctrl/Cmd + `+` / `-` / `0`

**行为**:
- 以鼠标位置或屏幕中心为缩放中心
- 所有桌面层窗口随之缩放
- 窗口内容也随之缩放
- 背景网格密度自适应调整

**缩放算法**:
```typescript
// 缩放到指定级别，保持缩放中心位置不变
zoomTo(newScale: number, centerX: number, centerY: number): void {
  newScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
  
  // 计算缩放中心在世界坐标中的位置（使用旧scale）
  const worldX = (centerX - this.translateX) / this.scale;
  const worldY = (centerY - this.translateY) / this.scale;
  
  // 应用新缩放
  this.scale = newScale;
  
  // 调整平移，使缩放中心保持在相同的屏幕位置
  this.translateX = centerX - worldX * newScale;
  this.translateY = centerY - worldY * newScale;
  
  this.applyTransform();
  this.updateGridDensity();
  this.debouncedSave();
}
```

**缩放范围**:
- 最小：10% (0.1x)
- 最大：500% (5x)
- 默认：100% (1x)

---

#### 2.4.3 适应视图

**功能**: 自动调整缩放和位置，使所有窗口可见

**触发方式**:
- 快捷键：Ctrl/Cmd + Shift + 0
- 右键菜单选择"适应所有内容"
- 工具栏按钮（Button 组件）

**行为**:
1. 通过微内核获取所有窗口位置和大小
2. 计算所有桌面层窗口的边界框
3. 计算合适的缩放比例和平移
4. 平滑动画到新的视图（CSS transition）

**验收标准**:
- ✅ 适应视图功能正常
- ✅ 动画流畅
- ✅ 所有窗口可见

---

### 2.5 窗口管理需求

#### 2.5.1 卡片和箱子窗口

**位置**:
- 放置在桌面层
- 使用世界坐标
- 可自由移动（通过基础层 DragDropSystem）

**大小**:
- 宽度可调整
- 高度根据内容或状态确定
- 最小宽度限制（如400px）

**状态**:
- 展开：显示所有内容，高度自适应
- 收起：固定高度（16:9比例），内容滚动
- 封面：显示封面，固定尺寸
- 最小化：不在桌面显示

**交互**（通过基础层和组件库）:
- 拖动标题栏移动窗口
- 拖动边缘调整大小
- 点击聚焦窗口
- 双击标题栏切换展开/收起

**渲染优化**:
- 超出屏幕的窗口不渲染（视口裁剪）
- 或渲染为简化版本（LOD）
- 缩放很小时简化渲染

**技术实现**:
```typescript
// 通过微内核创建窗口
createWindow = async (fileId: string, position: Position) => {
  // 读取文件数据
  const cardData = await Core.request({
    service: "card.read",
    payload: { cardId: fileId }
  });
  
  // 创建窗口（使用组件库构建）
  const window = {
    id: generateId(),
    type: 'card',
    fileId,
    position,  // 世界坐标
    size: { width: 600, height: 800 },
    state: 'expanded',
    zIndex: this.getNextZIndex(),
    layer: 'desktop'
  };
  
  this.windows.set(window.id, window);
  
  // 通过微内核加载渲染器
  await Core.request({
    service: "plugin.load",
    payload: { 
      pluginType: "renderer",
      cardType: cardData.structure[0].type 
    }
  });
  
  // 渲染窗口
  this.renderWindow(window, cardData);
};
```

---

#### 2.5.2 工具窗口

**类型**:
- 文件管理器窗口
- 编辑面板窗口
- 卡箱库窗口
- 设置窗口
- 其他辅助窗口

**位置**:
- 放置在窗口层
- 使用屏幕坐标
- 固定在屏幕位置

**特征**（使用薯片组件库的 Drawer 或 Modal 组件）:
- 悬浮在桌面之上
- 不受桌面缩放影响
- 半透明背景（主题包定义）
- 可拖动、调整大小（通过基础层 DragDropSystem）
- 可收起、最小化

**默认位置**:
- 文件管理器：左侧（Drawer placement="left"）
- 编辑面板：右侧（Drawer placement="right"）
- 卡箱库：左下或右下
- 用户可调整并通过微内核保存位置

**窗口状态**:
- 展开：显示完整内容
- 收起：只显示标题栏
- 最小化：图标显示在程序坞

**技术实现**:
```vue
<template>
  <!-- 文件管理器工具窗口 -->
  <Drawer 
    :visible="fileManagerVisible"
    :placement="fileManagerPlacement"
    :width="fileManagerWidth"
    @close="handleFileManagerClose"
  >
    <template #header>
      <div class="tool-header">
        <span>{{ t('tools.file_manager') }}</span>
        <Button @click="handleMinimize" type="text" size="small">
          {{ t('common.minimize') }}
        </Button>
      </div>
    </template>
    
    <FileManager />
  </Drawer>
</template>

<script setup lang="ts">
// 通过微内核读取配置
const fileManagerPlacement = ref('left');
const loadConfig = async () => {
  const config = await Core.request({
    service: "config.get",
    payload: { key: "layout.infinite-canvas.file-manager.placement" }
  });
  fileManagerPlacement.value = config.value || 'left';
};
</script>
```

---

### 2.6 程序坞需求

**LD-001: 程序坞功能**

**位置**:
- 窗口层底部或侧边
- 用户通过微内核保存的配置选择位置

**功能**:
- 显示工具窗口图标
- 最小化的工具窗口图标保存在这里
- 点击图标展开对应窗口
- 图标顺序可拖拽调整（通过基础层 DragDropSystem）

**外观**（使用薯片组件库）:
- 使用自定义的 Dock 组件
- 半透明背景（主题包定义）
- 图标排列（使用 Flex 布局）
- 悬停显示工具提示（Tooltip 组件）

**交互**:
- 点击图标：展开/聚焦窗口
- 右键图标：显示窗口菜单（Menu 组件）
- 拖动图标：调整顺序

**技术实现**:
```vue
<template>
  <div class="chips-dock">
    <div 
      v-for="tool in tools" 
      :key="tool.id"
      class="dock-icon"
      @click="handleIconClick(tool.id)"
      @contextmenu="handleIconRightClick(tool.id, $event)"
    >
      <Tooltip :content="tool.name">
        <img :src="tool.icon" :alt="tool.name" />
      </Tooltip>
      <div v-if="tool.running" class="running-indicator"></div>
    </div>
  </div>
</template>

<script setup lang="ts">
const handleIconClick = async (toolId: string) => {
  const tool = tools.value.find(t => t.id === toolId);
  if (tool.minimized) {
    // 通过引擎API展开窗口
    await Core.request({
      service: "editor.tool.show",
      payload: { toolId }
    });
  } else {
    // 聚焦窗口
    await Core.request({
      service: "editor.tool.focus",
      payload: { toolId }
    });
  }
};
</script>
```

---

### 2.7 缩放控制器需求

**LD-002: 缩放控制器**

**位置**:
- 窗口层右下角（默认）
- 用户可通过配置调整位置

**组成**（使用薯片组件库）:
- 缩放滑块（Slider 组件）
- 当前缩放百分比显示
- `-` `+` 按钮（Button 组件）
- "适应视图"按钮（Button 组件）

**交互**:
- 拖动滑块实时改变缩放
- 点击百分比输入精确值（Input 组件）
- 点击 `+` `-` 按钮增减缩放（10%步进）

**显示/隐藏**:
- 默认显示
- 可在设置中隐藏
- 悬停时显示（如果隐藏）

**技术实现**:
```vue
<template>
  <div class="zoom-control">
    <Button @click="zoomOut" size="small">-</Button>
    
    <Slider 
      v-model="scalePercentage"
      :min="10"
      :max="500"
      :step="10"
      @change="handleSliderChange"
    />
    
    <span 
      class="zoom-percentage"
      @click="showPercentageInput"
    >
      {{ scalePercentage }}%
    </span>
    
    <Button @click="zoomIn" size="small">+</Button>
    
    <Button @click="fitView" size="small" type="text">
      {{ t('zoom.fit_view') }}
    </Button>
  </div>
</template>

<script setup lang="ts">
const scalePercentage = computed(() => Math.round(scale.value * 100));

const handleSliderChange = (value: number) => {
  const newScale = value / 100;
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  zoomTo(newScale, centerX, centerY);
};

const zoomIn = () => {
  const newScale = Math.min(scale.value * 1.1, 5);
  zoomTo(newScale, window.innerWidth / 2, window.innerHeight / 2);
};

const fitView = async () => {
  // 通过微内核获取所有窗口
  const response = await Core.request({
    service: "editor.window.list",
    payload: {}
  });
  
  const bounds = calculateBounds(response.windows);
  const { scale, translateX, translateY } = calculateFitTransform(bounds);
  
  animateTransform(scale, translateX, translateY);
};
</script>
```

---

### 2.8 网格背景需求

**LD-003: 网格背景**

**网格样式**:
- 点状网格（默认）
- 线状网格
- 或其他样式（由主题包提供）

**网格大小**:
- 默认间距（如50px）
- 随缩放调整密度
- 缩小时显示更粗的网格
- 放大时显示更细的网格

**颜色和透明度**（由主题包定义）:
- 可配置
- 适应主题
- 不干扰内容

**对齐辅助**（可选）:
- 窗口移动时可吸附到网格
- 按住 Shift 禁用吸附
- 可在设置中启用/禁用

**技术实现**:
```typescript
// 更新网格密度
updateGridDensity = () => {
  const canvas = document.getElementById('desktop-background');
  const ctx = canvas.getContext('2d');
  
  // 根据缩放级别调整网格
  const gridSize = this.calculateGridSize(this.scale);
  this.drawGrid(ctx, gridSize);
};

calculateGridSize = (scale: number) => {
  const baseSize = 50;  // 基础网格大小
  
  if (scale < 0.5) {
    return baseSize * 2;  // 缩小时用更粗网格
  } else if (scale > 2) {
    return baseSize / 2;  // 放大时用更细网格
  } else {
    return baseSize;
  }
};
```

---

### 2.9 性能优化需求

**LD-004: 视口裁剪**

**需求**: 只渲染可见区域及周边的窗口

**实现**:
```typescript
// 计算可见窗口
updateVisibility = () => {
  const viewportBounds = this.getViewportBounds();
  
  for (const window of this.windows.values()) {
    const isVisible = this.isWindowInViewport(window, viewportBounds);
    const element = document.getElementById(`window-${window.id}`);
    
    if (element) {
      element.style.display = isVisible ? '' : 'none';
    }
  }
};

getViewportBounds = () => {
  // 计算当前屏幕视口对应的世界坐标范围
  const topLeft = this.screenToWorld(0, 0);
  const bottomRight = this.screenToWorld(window.innerWidth, window.innerHeight);
  
  // 添加缓冲区
  const buffer = 200;  // 200px 缓冲区
  
  return {
    left: topLeft.x - buffer,
    top: topLeft.y - buffer,
    right: bottomRight.x + buffer,
    bottom: bottomRight.y + buffer
  };
};

isWindowInViewport = (window: Window, viewport: Bounds) => {
  const { position, size } = window;
  
  return !(
    position.x + size.width < viewport.left ||
    position.x > viewport.right ||
    position.y + size.height < viewport.top ||
    position.y > viewport.bottom
  );
};
```

**验收标准**:
- ✅ 视口裁剪正确工作
- ✅ 性能提升明显
- ✅ 无可见延迟

---

**LD-005: LOD（细节层次）优化**

**需求**: 根据缩放级别调整窗口渲染细节

**LOD策略**:
```typescript
updateWindowLOD = () => {
  for (const window of this.windows.values()) {
    const element = document.getElementById(`window-${window.id}`);
    
    // 移除旧的LOD类
    element.classList.remove('lod-minimal', 'lod-simple', 'lod-full');
    
    // 根据缩放级别添加新的LOD类
    if (this.scale < 0.3) {
      element.classList.add('lod-minimal');  // 只显示封面
    } else if (this.scale < 0.7) {
      element.classList.add('lod-simple');   // 简化显示
    } else {
      element.classList.add('lod-full');     // 完整显示
    }
  }
};
```

**LOD样式**（由主题包定义）:
```css
/* 最简化 - 只显示封面或缩略图 */
.card-window.lod-minimal .card-content {
  display: none;
}

.card-window.lod-minimal {
  background: var(--chips-card-minimal-bg);
}

/* 简化显示 - 减少细节 */
.card-window.lod-simple {
  font-size: 12px;
}

.card-window.lod-simple .card-metadata {
  display: none;
}

/* 完整显示 */
.card-window.lod-full {
  /* 正常渲染 */
}
```

**验收标准**:
- ✅ LOD切换流畅
- ✅ 性能提升明显
- ✅ 视觉效果合理

---

**LD-006: 性能指标**

**强制性能要求**:
- 缩放操作：≥ 60fps
- 平移操作：≥ 60fps
- 窗口数量：支持 ≥100 个窗口流畅运行
- 视口裁剪计算：< 10ms
- 帧渲染时间：< 16ms（60fps）

**优化技术**:
- 使用 CSS Transform（GPU加速）
- 事件节流（100ms）
- 防抖保存（1s）
- requestAnimationFrame 优化渲染
- 虚拟化长列表

---

### 2.10 无限画布特有功能

**LD-007: 迷你地图**（可选功能）

**功能**: 显示整个桌面的缩略图

**特性**:
- 显示所有窗口的位置
- 显示当前视口位置
- 点击跳转到对应位置
- 拖动视口框平移桌面

**位置**: 右上角或左上角（可配置）

**技术实现**:
- 使用 Canvas 绘制缩略图
- 定期更新（节流500ms）
- 点击事件转换为桌面平移

---

**LD-008: 书签功能**（可选功能）

**功能**: 保存和快速跳转到特定视图

**特性**:
- 保存当前视图位置和缩放
- 为书签命名
- 快速跳转到书签
- 管理书签列表

**实现**:
- 书签数据通过微内核保存（config.set）
- 书签列表使用组件库的 List 组件
- 跳转使用平滑动画

---

## 3. 工作台布局插件

### 3.1 产品定位

工作台布局提供传统的分区窗口工作环境，适合专注编辑、结构化工作、喜欢传统界面的用户。

### 3.2 核心特性

- 分区窗口组合
- 固定的窗口布局
- 可调整的窗格大小
- 可停靠的窗口
- 标签页支持

### 3.3 布局结构需求

**LD-009: 基础布局结构**

**布局区域**（使用薯片组件库的布局组件）:
- **左侧栏**: 文件管理器（使用 Tree 组件）
- **中央区域**: 预览区（使用 Tabs 组件支持多文档）
- **右侧栏**: 编辑面板（使用 Drawer 或固定面板）
- **底部栏**（可选）: 工具栏
- **顶部**: 菜单栏和工具栏

**布局代码示例**:
```vue
<template>
  <div class="workbench-layout">
    <!-- 顶部菜单栏 -->
    <div class="menubar">
      <Menu :items="menuItems" mode="horizontal" />
    </div>
    
    <!-- 主体区域 -->
    <div class="main-area">
      <!-- 左侧栏 -->
      <div class="sidebar-left" :style="{ width: leftWidth + 'px' }">
        <Tree 
          :data="fileTree"
          @select="handleFileSelect"
        />
      </div>
      
      <!-- 分隔条 -->
      <Divider 
        direction="vertical"
        draggable
        @drag="handleLeftResize"
      />
      
      <!-- 中央预览区 -->
      <div class="preview-area">
        <Tabs 
          v-model:activeKey="activeTab"
          @edit="handleTabEdit"
        >
          <TabPane 
            v-for="file in openedFiles"
            :key="file.id"
            :tab="file.name"
            :closable="true"
          >
            <CardPreview :fileId="file.id" />
          </TabPane>
        </Tabs>
      </div>
      
      <!-- 分隔条 -->
      <Divider 
        direction="vertical"
        draggable
        @drag="handleRightResize"
      />
      
      <!-- 右侧编辑面板 -->
      <div class="sidebar-right" :style="{ width: rightWidth + 'px' }">
        <EditPanel />
      </div>
    </div>
  </div>
</template>
```

---

**LD-010: 窗格管理**

**调整大小**:
- 拖动窗格之间的分隔条（Divider 组件）
- 双击分隔条恢复默认大小
- 最小/最大尺寸限制

**折叠/展开**:
- 点击折叠按钮隐藏窗格
- 内容区自动扩展
- 再次点击展开窗格
- 使用 CSS transition 动画

**窗格切换**:
- 同一位置可能有多个窗格（如工具）
- 通过标签（Tabs 组件）或下拉菜单（Select 组件）切换

**大小保存**:
- 通过微内核保存窗格大小（config.set）
- 重启后恢复

---

### 3.4 文件管理器需求

**LD-011: 树状文件管理器**

**视图类型**:
- 树状视图（默认，使用 Tree 组件）
- 列表视图（使用 List 组件）
- 图标视图（使用 Grid 组件）

**树状视图特征**:
- 显示文件层级结构
- 展开/折叠文件夹
- 文件和文件夹图标
- 选中高亮（主题包定义）
- 拖拽支持（通过基础层 DragDropSystem）

**操作**（通过微内核路由）:
- 点击文件：在预览区显示
- 双击文件：通过微内核打开（`card.read`）
- 右键：上下文菜单（Menu 组件）
- 拖拽：移动/复制文件

**技术实现**:
```vue
<template>
  <Tree 
    :data="fileTree"
    :expanded-keys="expandedKeys"
    :selected-keys="selectedKeys"
    draggable
    @select="handleSelect"
    @expand="handleExpand"
    @drop="handleDrop"
  >
    <template #title="{ node }">
      <div class="tree-node">
        <Icon :type="node.icon" />
        <span>{{ node.name }}</span>
      </div>
    </template>
  </Tree>
</template>

<script setup lang="ts">
const handleSelect = async (keys: string[]) => {
  const fileId = keys[0];
  const response = await Core.request({
    service: "card.read",
    payload: { cardId: fileId, includeContent: true }
  });
  
  // 在预览区显示
  showPreview(response.card);
};

const handleDrop = async (info: DropInfo) => {
  await Core.request({
    service: "file.move",
    payload: {
      fileId: info.dragNode.key,
      targetFolder: info.node.key
    }
  });
};
</script>
```

---

### 3.5 预览区需求

**LD-012: 预览区功能**

**功能**:
- 显示选中文件的内容
- 只读预览或可查看状态
- 点击基础卡片进入编辑（右侧编辑面板激活）
- 支持标签页（Tabs 组件），同时打开多个文件
- 标签切换和关闭

**预览模式**:
- 查看模式：只读，可以与内容交互（如播放视频，通过基础层组件）
- 编辑模式：点击基础卡片通过微内核加载编辑组件

**多文档支持**:
- 标签页显示打开的文件（Tabs 组件）
- 标签切换
- 标签关闭（点击 × 按钮）
- 标签拖拽排序（通过基础层 DragDropSystem）

**技术实现**:
```vue
<template>
  <div class="preview-area">
    <Tabs 
      v-model:activeKey="activeFileId"
      type="editable-card"
      @edit="handleTabEdit"
      @tab-click="handleTabClick"
    >
      <TabPane 
        v-for="file in openedFiles"
        :key="file.id"
        :tab="file.name"
        :closable="true"
      >
        <!-- 卡片渲染 -->
        <CardRenderer 
          :card-id="file.id"
          :mode="viewMode"
          @base-card-click="handleBaseCardClick"
        />
      </TabPane>
    </Tabs>
  </div>
</template>

<script setup lang="ts">
const handleTabEdit = async (targetKey: string, action: 'add' | 'remove') => {
  if (action === 'remove') {
    await closeFile(targetKey);
  }
};

const handleBaseCardClick = async (baseCardId: string) => {
  if (viewMode.value === 'edit') {
    // 通过微内核加载编辑组件
    await Core.request({
      service: "editor.load-editor",
      payload: { 
        cardId: activeFileId.value,
        baseCardId 
      }
    });
  }
};
</script>
```

---

### 3.6 窗格停靠需求

**LD-013: 窗格停靠功能**

**功能**:
- 拖动窗格标题栏（通过基础层 DragDropSystem）
- 显示停靠指示器（上下左右中）
- 停靠到指定位置
- 窗格可脱离成浮动窗口
- 浮动窗口可重新停靠

**停靠区域**:
- 上方：停靠到顶部
- 下方：停靠到底部
- 左侧：停靠到左侧
- 右侧：停靠到右侧
- 中央：创建标签页

**技术实现**: 参考 VS Code 的停靠系统

---

### 3.7 工作台特有功能

**LD-014: 专注模式**

**功能**: 隐藏所有辅助窗格，只显示预览区和编辑面板

**触发**: 
- 快捷键：Ctrl/Cmd + Shift + F
- 菜单选择
- 工具栏按钮（Button 组件）

**行为**:
- 左侧栏折叠
- 底部栏折叠（如果有）
- 只显示中央预览区和右侧编辑面板
- 最大化工作空间

---

**LD-015: 分屏编辑**

**功能**: 预览区分割为多个窗格，同时查看多个文件

**分割方式**:
- 垂直分割
- 水平分割
- 网格分割

**操作**: 
- 拖拽标签页到分割区域
- 通过菜单选择分割
- 快捷键分割

---

## 4. 未来布局插件设想

### 4.1 看板布局

**特征**:
- 横向多列结构
- 每列代表一个分类或状态
- 卡片在列之间移动

**适用场景**:
- 项目管理
- 任务跟踪
- 流程管理

**技术实现**:
- 使用薯片组件库的 Grid 和 Card 组件
- 拖拽通过基础层 DragDropSystem
- 数据通过微内核路由

---

### 4.2 网格布局

**特征**:
- 网格排列卡片封面
- 自动适应屏幕宽度（响应式）
- 点击封面进入详情

**适用场景**:
- 图片库
- 卡片浏览
- 灵感墙

**技术实现**:
- 使用薯片组件库的 Grid 组件
- 封面通过基础层 IFrameWrapper 渲染
- 响应式布局

---

### 4.3 时间轴布局

**特征**:
- 按时间顺序排列卡片
- 纵向或横向时间轴
- 时间刻度显示

**适用场景**:
- 日记
- 项目历史
- 学习记录

**技术实现**:
- 使用薯片组件库的 Timeline 组件
- 时间数据通过微内核读取

---

## 5. 布局切换需求

### 5.1 切换机制

**LD-016: 布局切换流程**

**触发方式**:
- 菜单：视图 > 布局 > 选择布局（Menu 组件）
- 快捷键：Ctrl/Cmd + L（打开布局选择器，使用 Modal 组件）
- 工具栏：布局切换按钮（Button 组件）

**切换流程**:
1. 用户触发布局切换
2. 引擎保存当前布局的状态（通过微内核 `config.set`）
3. 通过微内核卸载当前布局插件（`plugin.unload`）
4. 通过微内核加载新布局插件（`plugin.load`）
5. 新布局初始化（`layout.init`）
6. 新布局恢复窗口状态
7. 界面过渡动画（CSS transition）
8. 切换完成，新布局可用

**技术实现**:
```typescript
switchLayout = async (newLayoutId: string) => {
  // 1. 保存当前布局状态
  await Core.request({
    service: "config.set",
    payload: {
      key: `layout.${this.currentLayoutId}.state`,
      value: this.currentLayout.getState()
    }
  });
  
  // 2. 卸载当前布局
  await Core.request({
    service: "plugin.unload",
    payload: { pluginId: this.currentLayoutId }
  });
  
  // 3. 显示加载指示器（Loading 组件）
  showLoading();
  
  // 4. 加载新布局
  const response = await Core.request({
    service: "plugin.load",
    payload: { pluginId: newLayoutId }
  });
  
  // 5. 初始化新布局
  await response.plugin.init(this.engineContext);
  
  // 6. 挂载新布局
  await response.plugin.mount(this.layoutContainer);
  
  // 7. 恢复状态
  const savedState = await Core.request({
    service: "config.get",
    payload: { key: `layout.${newLayoutId}.state` }
  });
  
  if (savedState.value) {
    await response.plugin.restoreState(savedState.value);
  }
  
  // 8. 隐藏加载指示器
  hideLoading();
  
  // 9. 更新当前布局
  this.currentLayout = response.plugin;
  this.currentLayoutId = newLayoutId;
  
  // 10. 触发事件
  this.eventBus.emit('layout:changed', { 
    from: this.currentLayoutId,
    to: newLayoutId 
  });
};
```

---

### 5.2 状态保持

**LD-017: 布局状态保存和恢复**

**保存的状态**:
- 打开的文件列表
- 窗口位置和大小（如果适用）
- 滚动位置
- 选中状态
- 窗格大小
- 折叠状态

**保存时机**:
- 切换布局前
- 应用退出前
- 定期自动保存（防抖1s）

**恢复策略**:
- 在新布局中尽可能恢复状态
- 位置和大小可能需要重新计算
- 保持文件的打开状态
- 通过微内核读取保存的配置

---

### 5.3 平滑过渡

**LD-018: 布局切换动画**

**过渡动画**:
- 旧布局淡出（opacity 1 → 0，200ms）
- 新布局淡入（opacity 0 → 1，200ms，延迟100ms）
- 可能有位移效果（translateY: 10px → 0）
- 总时长：400ms

**加载指示**（使用 Loading 组件）:
- 显示加载进度
- 避免界面闪烁
- 显示加载消息

---

### 5.4 布局兼容性

**LD-019: 功能一致性**

**核心功能一致**:
- 所有布局都提供基本的卡片管理功能
- 文件操作方式一致
- 编辑功能一致
- 快捷键统一

**布局特有功能**:
- 某些功能仅在特定布局可用
- 切换时相关功能变为不可用
- 界面会相应调整
- 显示功能可用性提示

---

## 6. 布局设置需求

### 6.1 全局设置

**LD-020: 布局全局设置**

**设置项**（使用 Form 组件构建）:
- **默认布局**: 选择启动时使用的布局（Select 组件）
- **布局管理**: 查看、安装、更新、卸载布局插件

**实现**（通过微内核）:
```vue
<template>
  <Form :model="layoutSettings">
    <FormItem :label="t('settings.default_layout')">
      <Select 
        v-model="layoutSettings.defaultLayout"
        @change="handleDefaultLayoutChange"
      >
        <Option 
          v-for="layout in installedLayouts"
          :key="layout.id"
          :value="layout.id"
        >
          {{ layout.name }}
        </Option>
      </Select>
    </FormItem>
    
    <FormItem :label="t('settings.installed_layouts')">
      <List :data-source="installedLayouts">
        <template #renderItem="{ item }">
          <ListItem>
            <ListItemMeta 
              :title="item.name"
              :description="item.description"
            />
            <template #actions>
              <Button @click="updateLayout(item.id)">
                {{ t('common.update') }}
              </Button>
              <Button @click="uninstallLayout(item.id)" danger>
                {{ t('common.uninstall') }}
              </Button>
            </template>
          </ListItem>
        </template>
      </List>
    </FormItem>
  </Form>
</template>

<script setup lang="ts">
const handleDefaultLayoutChange = async (layoutId: string) => {
  await Core.request({
    service: "config.set",
    payload: {
      key: "editor.default_layout",
      value: layoutId
    }
  });
};

const uninstallLayout = async (layoutId: string) => {
  await Core.request({
    service: "plugin.uninstall",
    payload: { pluginId: layoutId }
  });
  
  // 刷新列表
  await loadInstalledLayouts();
};
</script>
```

---

### 6.2 布局特定设置

**LD-021: 无限画布布局设置**

**设置项**（使用薯片组件库构建）:
- 默认缩放级别（Slider 组件）
- 缩放范围（InputNumber 组件）
- 网格样式和大小（Select + InputNumber）
- 窗口吸附开关（Switch 组件）
- 程序坞位置（Radio 组件）
- 工具窗口默认位置

**实现**（通过微内核保存配置）:
```vue
<template>
  <Form>
    <FormItem :label="t('settings.default_scale')">
      <Slider 
        v-model="settings.defaultScale"
        :min="10"
        :max="200"
        :marks="{ 10: '10%', 100: '100%', 200: '200%' }"
      />
    </FormItem>
    
    <FormItem :label="t('settings.grid_size')">
      <InputNumber 
        v-model="settings.gridSize"
        :min="20"
        :max="100"
        suffix="px"
      />
    </FormItem>
    
    <FormItem :label="t('settings.snap_to_grid')">
      <Switch v-model="settings.snapToGrid" />
    </FormItem>
    
    <FormItem :label="t('settings.dock_position')">
      <Radio.Group v-model="settings.dockPosition">
        <Radio value="bottom">{{ t('position.bottom') }}</Radio>
        <Radio value="left">{{ t('position.left') }}</Radio>
        <Radio value="right">{{ t('position.right') }}</Radio>
      </Radio.Group>
    </FormItem>
  </Form>
</template>

<script setup lang="ts">
// 所有设置通过微内核保存
watch(settings, async (newSettings) => {
  await Core.request({
    service: "config.set",
    payload: {
      key: "layout.infinite-canvas.settings",
      value: newSettings
    }
  });
}, { deep: true });
</script>
```

---

**LD-022: 工作台布局设置**

**设置项**:
- 默认窗格大小
- 侧栏折叠状态
- 标签页行为
- 文件管理器视图类型（Tree、List、Grid）
- 快捷键自定义

**实现**（通过微内核保存配置）

---

### 6.3 个性化

**LD-023: 主题和个性化设置**

**主题**（通过 ThemeProvider）:
- 不同布局可能支持不同主题
- 主题应该跨布局一致
- 使用 ThemeProvider 提供主题上下文

**自定义**（由主题包提供）:
- 调整颜色（CSS变量）
- 调整字体大小
- 调整间距
- 调整圆角等

---

## 7. 布局插件开发需求

### 7.1 开发文档

**PD-001: 插件开发文档**

**提供给开发者**:
- 插件API文档
- 布局插件接口说明
- 示例布局插件（模板）
- 开发工具和SDK
- 微内核调用指南
- 组件库使用指南
- 基础层调用指南

### 7.2 插件结构

**PD-002: 插件文件结构**

**必需文件**:
```
layout-plugin/
├── manifest.json          # 插件元数据
├── index.ts              # 插件入口
├── README.md             # 插件说明
├── package.json          # 依赖声明
└── src/
    ├── layout.ts         # 布局实现
    ├── components/       # 使用薯片组件库构建
    └── types.ts          # 类型定义
```

**manifest.json 示例**:
```json
{
  "id": "layout.infinite-canvas",
  "name": "无限画布布局",
  "version": "1.0.0",
  "type": "layout",
  "description": "自由的无限画布工作空间",
  "author": "Chips官方",
  "main": "dist/index.js",
  "dependencies": {
    "@chips/sdk": "^1.0.0",
    "@chips/components": "^1.0.0"
  },
  "permissions": [
    "window.create",
    "window.manage",
    "file.read",
    "config.read",
    "config.write"
  ],
  "services": [
    {
      "name": "layout.infinite-canvas.init",
      "description": "初始化无限画布布局"
    }
  ]
}
```

---

### 7.3 开发规范

**PD-003: 布局插件开发规范**

**强制要求**:
- ✅ 所有调用通过微内核路由
- ✅ 所有界面使用薯片组件库构建
- ✅ 调用基础层功能通过微内核
- ✅ 遵循薯片协议规范
- ✅ 零硬编码文本，使用多语言系统
- ✅ 实现标准的布局插件接口
- ❌ 禁止直接调用其他模块
- ❌ 禁止包含样式代码（由主题包提供）

**代码示例**:
```typescript
// ✅ 正确：通过微内核调用
export class InfiniteCanvasLayout implements LayoutPlugin {
  async createWindow(file: File, options?: WindowOptions): Promise<Window> {
    // 通过微内核读取文件
    const cardData = await this.context.callEngine("card.read", {
      cardId: file.id
    });
    
    // 通过微内核调用基础层窗口管理
    const windowHandle = await this.context.callEngine(
      "foundation.window-manager.create",
      {
        title: cardData.metadata.name,
        width: options?.width || 600,
        height: options?.height || 800
      }
    );
    
    // 创建窗口数据
    const window = {
      id: windowHandle.id,
      type: 'card',
      fileId: file.id,
      position: options?.position || this.getDefaultPosition(),
      size: { width: 600, height: 800 },
      zIndex: this.getNextZIndex(),
      layer: 'desktop'
    };
    
    this.windows.set(window.id, window);
    
    // 渲染窗口（使用组件库）
    await this.renderWindow(window, cardData);
    
    return window;
  }
}

// ❌ 错误：直接调用
import { WindowManager } from './window-manager';  // 禁止！
const window = WindowManager.create({ ... });  // 禁止！
```

---

### 7.4 测试和发布

**PD-004: 插件测试要求**

**测试类型**:
- 单元测试：测试插件核心逻辑
- 集成测试：测试与引擎的集成
- E2E测试：测试完整用户流程
- 性能测试：测试性能指标

**测试覆盖率**: ≥ 80%

---

**PD-005: 插件发布流程**

**发布步骤**:
1. 完成开发和测试
2. 更新版本号（遵循语义化版本规范）
3. 打包插件（包含所有依赖）
4. 提交到插件市场（未来功能）
5. 通过审核后发布
6. 用户可通过微内核安装（`plugin.install`）

---

## 8. 技术实现总结

### 8.1 布局插件架构

```
布局插件
  ├── 界面层（使用薯片组件库）
  │     ├── Button、Input、Menu等基础组件
  │     ├── Grid、Flex、Container等布局组件
  │     ├── Tree、List、Tabs等数据组件
  │     └── ThemeProvider主题支持
  │
  ├── 逻辑层（插件实现）
  │     ├── 窗口管理逻辑
  │     ├── 布局计算逻辑
  │     └── 交互处理逻辑
  │
  └── 集成层（通过微内核）
        ├── 调用引擎功能
        ├── 调用基础层功能
        ├── 读写配置
        └── 发布订阅事件
```

### 8.2 核心原则

1. **微内核路由**: 所有模块调用通过微内核
2. **组件库构建**: 所有界面使用薯片组件库
3. **基础层依赖**: 调用基础层的通用功能
4. **插件独立**: 布局插件完全独立开发
5. **标准接口**: 遵循统一的插件接口标准

### 8.3 开发流程

```
1. 创建插件项目
   ↓
2. 集成薯片SDK和组件库
   ↓
3. 实现布局插件接口
   ↓
4. 使用组件库构建界面
   ↓
5. 通过微内核调用功能
   ↓
6. 测试插件功能
   ↓
7. 打包和发布
   ↓
8. 用户通过微内核安装
```

---

## 9. 总结

布局插件是编辑引擎灵活性的核心体现：

### 9.1 技术栈集成

- **微内核**: 所有调用通过微内核路由，模块完全解耦
- **公共基础层**: 调用基础层的窗口管理、拖拽系统等通用功能
- **薯片组件库**: 使用组件库构建所有界面，样式由主题包提供
- **插件系统**: 布局作为插件独立开发和分发

### 9.2 布局模式

- **无限画布布局**: 自由创意，空间化组织
- **工作台布局**: 传统界面，专注编辑
- **未来扩展**: 更多布局适应更多场景

### 9.3 开发支持

- 完整的开发文档和示例
- 标准化的插件接口
- 丰富的组件库支持
- 强大的基础层功能
- 通过微内核的统一调用方式

通过插件化的布局系统，用户可以选择最适合自己的工作方式，开发者可以创造新的布局模式，丰富整个生态系统。两种基础布局代表了两种典型的使用模式，为用户提供了多样的选择。

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-31  
**状态**: ✅ 生效
